webpackJsonp([1,18],Array(403).concat([
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.IndexPage = undefined;
	
	var _getPrototypeOf = __webpack_require__(304);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(309);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(310);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(314);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(348);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(24);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(404);
	
	var _IsPcOrNot = __webpack_require__(385);
	
	var _IsPcOrNot2 = _interopRequireDefault(_IsPcOrNot);
	
	var _reactRouter = __webpack_require__(224);
	
	var _Constant = __webpack_require__(389);
	
	var _Constant2 = _interopRequireDefault(_Constant);
	
	var _Header = __webpack_require__(375);
	
	var _Header2 = _interopRequireDefault(_Header);
	
	var _Footer = __webpack_require__(406);
	
	var _Footer2 = _interopRequireDefault(_Footer);
	
	var _en = __webpack_require__(386);
	
	var _en2 = _interopRequireDefault(_en);
	
	var _zh = __webpack_require__(387);
	
	var _zh2 = _interopRequireDefault(_zh);
	
	var _nZepto = __webpack_require__(401);
	
	var _nZepto2 = _interopRequireDefault(_nZepto);
	
	var _wuhan = __webpack_require__(407);
	
	var _wuhan2 = _interopRequireDefault(_wuhan);
	
	var _langchao = __webpack_require__(408);
	
	var _langchao2 = _interopRequireDefault(_langchao);
	
	var _pc_intel = __webpack_require__(409);
	
	var _pc_intel2 = _interopRequireDefault(_pc_intel);
	
	var _m_intel = __webpack_require__(410);
	
	var _m_intel2 = _interopRequireDefault(_m_intel);
	
	var _BaseComponent = __webpack_require__(381);
	
	var _lunbo = __webpack_require__(411);
	
	var _lunbo2 = _interopRequireDefault(_lunbo);
	
	var _lunbo3 = __webpack_require__(412);
	
	var _lunbo4 = _interopRequireDefault(_lunbo3);
	
	var _lunbo5 = __webpack_require__(413);
	
	var _lunbo6 = _interopRequireDefault(_lunbo5);
	
	var _lunbo7 = __webpack_require__(414);
	
	var _lunbo8 = _interopRequireDefault(_lunbo7);
	
	var _lunbo9 = __webpack_require__(415);
	
	var _lunbo10 = _interopRequireDefault(_lunbo9);
	
	var _lunbo11 = __webpack_require__(416);
	
	var _lunbo12 = _interopRequireDefault(_lunbo11);
	
	var _lunbo13 = __webpack_require__(417);
	
	var _lunbo14 = _interopRequireDefault(_lunbo13);
	
	var _lunbo15 = __webpack_require__(418);
	
	var _lunbo16 = _interopRequireDefault(_lunbo15);
	
	var _lunbo17 = __webpack_require__(419);
	
	var _lunbo18 = _interopRequireDefault(_lunbo17);
	
	var _web = __webpack_require__(420);
	
	var _web2 = _interopRequireDefault(_web);
	
	var _web3 = __webpack_require__(421);
	
	var _web4 = _interopRequireDefault(_web3);
	
	var _web5 = __webpack_require__(422);
	
	var _web6 = _interopRequireDefault(_web5);
	
	var _web7 = __webpack_require__(423);
	
	var _web8 = _interopRequireDefault(_web7);
	
	var _web9 = __webpack_require__(424);
	
	var _web10 = _interopRequireDefault(_web9);
	
	var _web11 = __webpack_require__(425);
	
	var _web12 = _interopRequireDefault(_web11);
	
	var _web13 = __webpack_require__(426);
	
	var _web14 = _interopRequireDefault(_web13);
	
	var _web15 = __webpack_require__(427);
	
	var _web16 = _interopRequireDefault(_web15);
	
	var _web17 = __webpack_require__(428);
	
	var _web18 = _interopRequireDefault(_web17);
	
	var _swiper = __webpack_require__(429);
	
	var _swiper2 = _interopRequireDefault(_swiper);
	
	__webpack_require__(430);
	
	var _lottieWeb = __webpack_require__(432);
	
	var _lottieWeb2 = _interopRequireDefault(_lottieWeb);
	
	var _subForums_right_icon = __webpack_require__(433);
	
	var _subForums_right_icon2 = _interopRequireDefault(_subForums_right_icon);
	
	var _m_banner = __webpack_require__(434);
	
	var _m_banner2 = _interopRequireDefault(_m_banner);
	
	var _m_add_icon = __webpack_require__(435);
	
	var _m_add_icon2 = _interopRequireDefault(_m_add_icon);
	
	var _m_video = __webpack_require__(436);
	
	var _m_video2 = _interopRequireDefault(_m_video);
	
	var _m_video_bg = __webpack_require__(437);
	
	var _m_video_bg2 = _interopRequireDefault(_m_video_bg);
	
	var _m_video_back = __webpack_require__(438);
	
	var _m_video_back2 = _interopRequireDefault(_m_video_back);
	
	var _m_order = __webpack_require__(439);
	
	var _m_order2 = _interopRequireDefault(_m_order);
	
	var _m_meet_desc = __webpack_require__(440);
	
	var _m_meet_desc2 = _interopRequireDefault(_m_meet_desc);
	
	var _m_agenda = __webpack_require__(441);
	
	var _m_agenda2 = _interopRequireDefault(_m_agenda);
	
	var _m_guest = __webpack_require__(442);
	
	var _m_guest2 = _interopRequireDefault(_m_guest);
	
	var _m_science = __webpack_require__(443);
	
	var _m_science2 = _interopRequireDefault(_m_science);
	
	var _m_news = __webpack_require__(444);
	
	var _m_news2 = _interopRequireDefault(_m_news);
	
	var _m_history = __webpack_require__(445);
	
	var _m_history2 = _interopRequireDefault(_m_history);
	
	var _m_bottom_icon = __webpack_require__(446);
	
	var _m_bottom_icon2 = _interopRequireDefault(_m_bottom_icon);
	
	var _m_daoyu_ = __webpack_require__(447);
	
	var _m_daoyu_2 = _interopRequireDefault(_m_daoyu_);
	
	var _m_daoyu_3 = __webpack_require__(448);
	
	var _m_daoyu_4 = _interopRequireDefault(_m_daoyu_3);
	
	var _m_daoyu_5 = __webpack_require__(449);
	
	var _m_daoyu_6 = _interopRequireDefault(_m_daoyu_5);
	
	var _m_daoyu_7 = __webpack_require__(450);
	
	var _m_daoyu_8 = _interopRequireDefault(_m_daoyu_7);
	
	var _m_daoyu_9 = __webpack_require__(451);
	
	var _m_daoyu_10 = _interopRequireDefault(_m_daoyu_9);
	
	var _m_daoyu_11 = __webpack_require__(452);
	
	var _m_daoyu_12 = _interopRequireDefault(_m_daoyu_11);
	
	var _m_daoyu_01_en = __webpack_require__(453);
	
	var _m_daoyu_01_en2 = _interopRequireDefault(_m_daoyu_01_en);
	
	var _m_daoyu_02_en = __webpack_require__(454);
	
	var _m_daoyu_02_en2 = _interopRequireDefault(_m_daoyu_02_en);
	
	var _m_daoyu_03_en = __webpack_require__(455);
	
	var _m_daoyu_03_en2 = _interopRequireDefault(_m_daoyu_03_en);
	
	var _m_daoyu_04_en = __webpack_require__(456);
	
	var _m_daoyu_04_en2 = _interopRequireDefault(_m_daoyu_04_en);
	
	var _m_daoyu_05_en = __webpack_require__(457);
	
	var _m_daoyu_05_en2 = _interopRequireDefault(_m_daoyu_05_en);
	
	var _m_daoyu_06_en = __webpack_require__(458);
	
	var _m_daoyu_06_en2 = _interopRequireDefault(_m_daoyu_06_en);
	
	var _media_bg = __webpack_require__(459);
	
	var _media_bg2 = _interopRequireDefault(_media_bg);
	
	var _pc_banner = __webpack_require__(460);
	
	var _pc_banner2 = _interopRequireDefault(_pc_banner);
	
	var _pc_preface_left = __webpack_require__(461);
	
	var _pc_preface_left2 = _interopRequireDefault(_pc_preface_left);
	
	var _pc_preface_right = __webpack_require__(462);
	
	var _pc_preface_right2 = _interopRequireDefault(_pc_preface_right);
	
	var _pc_right_arror = __webpack_require__(463);
	
	var _pc_right_arror2 = _interopRequireDefault(_pc_right_arror);
	
	var _pc_add_icon = __webpack_require__(464);
	
	var _pc_add_icon2 = _interopRequireDefault(_pc_add_icon);
	
	var _pc_video = __webpack_require__(465);
	
	var _pc_video2 = _interopRequireDefault(_pc_video);
	
	var _pc_video_bg = __webpack_require__(466);
	
	var _pc_video_bg2 = _interopRequireDefault(_pc_video_bg);
	
	var _pc_video_back = __webpack_require__(467);
	
	var _pc_video_back2 = _interopRequireDefault(_pc_video_back);
	
	var _pc_order = __webpack_require__(468);
	
	var _pc_order2 = _interopRequireDefault(_pc_order);
	
	var _pc_meeting_desc = __webpack_require__(469);
	
	var _pc_meeting_desc2 = _interopRequireDefault(_pc_meeting_desc);
	
	var _pc_agenda = __webpack_require__(470);
	
	var _pc_agenda2 = _interopRequireDefault(_pc_agenda);
	
	var _pc_guest = __webpack_require__(471);
	
	var _pc_guest2 = _interopRequireDefault(_pc_guest);
	
	var _pc_science = __webpack_require__(472);
	
	var _pc_science2 = _interopRequireDefault(_pc_science);
	
	var _pc_news = __webpack_require__(473);
	
	var _pc_news2 = _interopRequireDefault(_pc_news);
	
	var _pc_history = __webpack_require__(474);
	
	var _pc_history2 = _interopRequireDefault(_pc_history);
	
	var _pc_bottom_icon = __webpack_require__(475);
	
	var _pc_bottom_icon2 = _interopRequireDefault(_pc_bottom_icon);
	
	var _previous_ = __webpack_require__(476);
	
	var _previous_2 = _interopRequireDefault(_previous_);
	
	var _previous_3 = __webpack_require__(477);
	
	var _previous_4 = _interopRequireDefault(_previous_3);
	
	var _pc_daoyu_ = __webpack_require__(478);
	
	var _pc_daoyu_2 = _interopRequireDefault(_pc_daoyu_);
	
	var _pc_daoyu_3 = __webpack_require__(479);
	
	var _pc_daoyu_4 = _interopRequireDefault(_pc_daoyu_3);
	
	var _pc_daoyu_5 = __webpack_require__(480);
	
	var _pc_daoyu_6 = _interopRequireDefault(_pc_daoyu_5);
	
	var _pc_daoyu_7 = __webpack_require__(481);
	
	var _pc_daoyu_8 = _interopRequireDefault(_pc_daoyu_7);
	
	var _pc_daoyu_9 = __webpack_require__(482);
	
	var _pc_daoyu_10 = _interopRequireDefault(_pc_daoyu_9);
	
	var _pc_daoyu_11 = __webpack_require__(483);
	
	var _pc_daoyu_12 = _interopRequireDefault(_pc_daoyu_11);
	
	var _pc_daoyu_01_en = __webpack_require__(484);
	
	var _pc_daoyu_01_en2 = _interopRequireDefault(_pc_daoyu_01_en);
	
	var _pc_daoyu_02_en = __webpack_require__(485);
	
	var _pc_daoyu_02_en2 = _interopRequireDefault(_pc_daoyu_02_en);
	
	var _pc_daoyu_03_en = __webpack_require__(486);
	
	var _pc_daoyu_03_en2 = _interopRequireDefault(_pc_daoyu_03_en);
	
	var _pc_daoyu_04_en = __webpack_require__(487);
	
	var _pc_daoyu_04_en2 = _interopRequireDefault(_pc_daoyu_04_en);
	
	var _pc_daoyu_05_en = __webpack_require__(488);
	
	var _pc_daoyu_05_en2 = _interopRequireDefault(_pc_daoyu_05_en);
	
	var _pc_daoyu_06_en = __webpack_require__(489);
	
	var _pc_daoyu_06_en2 = _interopRequireDefault(_pc_daoyu_06_en);
	
	var _pc_media = __webpack_require__(490);
	
	var _pc_media2 = _interopRequireDefault(_pc_media);
	
	var _limit_zh = __webpack_require__(491);
	
	var _limit_zh2 = _interopRequireDefault(_limit_zh);
	
	var _limit_buy_en = __webpack_require__(492);
	
	var _limit_buy_en2 = _interopRequireDefault(_limit_buy_en);
	
	var _terminal = __webpack_require__(493);
	
	var _danao_r = __webpack_require__(497);
	
	var _danao_r2 = _interopRequireDefault(_danao_r);
	
	var _danao_b = __webpack_require__(498);
	
	var _danao_b2 = _interopRequireDefault(_danao_b);
	
	var _znst_r = __webpack_require__(499);
	
	var _znst_r2 = _interopRequireDefault(_znst_r);
	
	var _znst_b = __webpack_require__(500);
	
	var _znst_b2 = _interopRequireDefault(_znst_b);
	
	var _znjs_r = __webpack_require__(501);
	
	var _znjs_r2 = _interopRequireDefault(_znjs_r);
	
	var _znjs_b = __webpack_require__(502);
	
	var _znjs_b2 = _interopRequireDefault(_znjs_b);
	
	var _xcx_r = __webpack_require__(503);
	
	var _xcx_r2 = _interopRequireDefault(_xcx_r);
	
	var _xcx_b = __webpack_require__(504);
	
	var _xcx_b2 = _interopRequireDefault(_xcx_b);
	
	var _xiaodu_r = __webpack_require__(505);
	
	var _xiaodu_r2 = _interopRequireDefault(_xiaodu_r);
	
	var _xiaodu_b = __webpack_require__(506);
	
	var _xiaodu_b2 = _interopRequireDefault(_xiaodu_b);
	
	var _zny_r = __webpack_require__(507);
	
	var _zny_r2 = _interopRequireDefault(_zny_r);
	
	var _zny_b = __webpack_require__(508);
	
	var _zny_b2 = _interopRequireDefault(_zny_b);
	
	var _Aijh_r = __webpack_require__(509);
	
	var _Aijh_r2 = _interopRequireDefault(_Aijh_r);
	
	var _Aijh_b = __webpack_require__(510);
	
	var _Aijh_b2 = _interopRequireDefault(_Aijh_b);
	
	var _g_r = __webpack_require__(511);
	
	var _g_r2 = _interopRequireDefault(_g_r);
	
	var _g_b = __webpack_require__(512);
	
	var _g_b2 = _interopRequireDefault(_g_b);
	
	var _inter_r = __webpack_require__(513);
	
	var _inter_r2 = _interopRequireDefault(_inter_r);
	
	var _inter_b = __webpack_require__(514);
	
	var _inter_b2 = _interopRequireDefault(_inter_b);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// PC Start
	
	// web Start
	var messages = {};
	
	//2019 create start
	
	messages['en'] = _en2.default;
	messages['zh-CN'] = _zh2.default;
	messages['zh-cn'] = _zh2.default;
	
	var OrderButton = function (_Component) {
	    (0, _inherits3.default)(OrderButton, _Component);
	
	    function OrderButton(props) {
	        (0, _classCallCheck3.default)(this, OrderButton);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (OrderButton.__proto__ || (0, _getPrototypeOf2.default)(OrderButton)).call(this, props));
	
	        _this.order = false;
	        _this.playBack = false;
	        _this.error = {
	            text: 'sure'
	        };
	        return _this;
	    }
	
	    (0, _createClass3.default)(OrderButton, [{
	        key: 'backVideo',
	        value: function backVideo(text) {
	            var _this2 = this;
	
	            if (text == 'order') {
	                if (this.props.order == true) {
	                    return;
	                } else {
	                    _nZepto2.default.get(_Constant2.default.url + 'hasLoginBaidu.do', function (data) {
	                        if (data.error_no !== '0') {
	                            if (_IsPcOrNot2.default.get()) {
	                                window.instance.show();
	                            } else {
	                                (0, _nZepto2.default)('#login-wrap').css("display", "block");
	                                (0, _nZepto2.default)('#login').css("display", "block");
	                            }
	                        } else {
	                            _nZepto2.default.get(_Constant2.default.url + 'orderVideo.do', function (data) {
	                                // console.log(data.data)
	                                if (data.error_no == '0') {
	                                    _this2.props.changeState("order");
	                                } else {
	                                    _this2.error.text = "not_bound_phone";
	                                    _this2.setState(_this2.error);
	                                    _this2.refs.Menu.open();
	                                }
	                            });
	                        }
	                    });
	                }
	            }
	
	            if (text == 'backtip') {
	                if (this.props.playBack == true) {
	                    return;
	                } else {
	                    _nZepto2.default.get(_Constant2.default.url + 'hasLoginBaidu.do', function (data) {
	                        if (data.error_no !== '0') {
	                            if (_IsPcOrNot2.default.get()) {
	                                window.instance.show();
	                            } else {
	                                (0, _nZepto2.default)('#login-wrap').css("display", "block");
	                                (0, _nZepto2.default)('#login').css("display", "block");
	                            }
	                        } else {
	                            _nZepto2.default.get(_Constant2.default.url + 'playBackReminding.do.do', function (data) {
	                                // console.log(data.data)
	                                if (data.error_no == '0') {
	                                    _this2.props.changeState("playback");
	                                } else {
	                                    _this2.error.text = "not_bound_phone";
	                                    _this2.setState(_this2.error);
	                                    _this2.refs.Menu.open();
	                                }
	                            });
	                        }
	                    });
	                }
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(_BaseComponent.Menu, { ref: 'Menu', text: this.error.text }),
	                _react2.default.createElement(
	                    'div',
	                    { onClick: this.backVideo.bind(this, this.props.text), className: 'base_btn_c', style: {
	                            position: "relative",
	                            width: _IsPcOrNot2.default.get() ? "200px" : '1.63rem',
	                            height: _IsPcOrNot2.default.get() ? "60px" : '.47rem',
	                            color: "#fff",
	                            textAlign: "center",
	                            backgroundColor: this.props.bgColor,
	                            cursor: "pointer",
	                            display: "flex",
	                            zIndex: "10",
	                            fontSize: _IsPcOrNot2.default.get() ? '20px' : '.2rem',
	                            alignItems: "center",
	                            justifyContent: "center"
	                        } },
	                    _react2.default.createElement(_BaseComponent.FormattedMessage, { id: this.props.text })
	                )
	            );
	        }
	    }]);
	    return OrderButton;
	}(_react.Component);
	
	var OrderArea = function (_Component2) {
	    (0, _inherits3.default)(OrderArea, _Component2);
	
	    function OrderArea(props) {
	        (0, _classCallCheck3.default)(this, OrderArea);
	
	        var _this3 = (0, _possibleConstructorReturn3.default)(this, (OrderArea.__proto__ || (0, _getPrototypeOf2.default)(OrderArea)).call(this, props));
	
	        _this3.changeState = function (flag) {
	            // console.log(flag)
	            if (flag == 'playback') {
	                _this3.playBack = true;
	                _this3.setState({
	                    playBack: _this3.playBack
	                });
	            }
	            if (flag == 'order') {
	                _this3.order = true;
	                _this3.setState({
	                    order: _this3.order
	                });
	            }
	        };
	
	        _this3.order = false;
	        _this3.playBack = false;
	        return _this3;
	    }
	
	    (0, _createClass3.default)(OrderArea, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this4 = this;
	
	            _nZepto2.default.get(_Constant2.default.url + 'ifOrderVideo.do', function (data) {
	                if (data.data.isOrderVideo == 1) {
	                    _this4.order = true;
	                    _this4.setState({
	                        order: _this4.order
	                    });
	                }
	                if (data.data.isPlayback == 1) {
	                    _this4.playBack = true;
	                    _this4.setState({
	                        playBack: _this4.playBack
	                    });
	                }
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _IsPcOrNot2.default.get() ? _react2.default.createElement(
	                'div',
	                { style: {
	                        position: 'relative',
	                        width: '1200px',
	                        margin: '0 auto',
	                        padding: '50px 0'
	                    } },
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: "670px",
	                            margin: '0 auto',
	                            height: "80px",
	                            display: 'flex',
	                            alignItems: "center",
	                            justifyContent: 'space-between',
	                            position: 'relative'
	                        } },
	                    _react2.default.createElement('div', { style: {
	                            width: '50px',
	                            height: '50px',
	                            background: 'url(' + _pc_order2.default + ') no-repeat center center',
	                            backgroundSize: 'cover',
	                            position: 'absolute',
	                            left: '0'
	                        } }),
	                    _react2.default.createElement(
	                        'div',
	                        { style: { marginLeft: _IsPcOrNot2.default.get() ? '80px' : '1.4rem' } },
	                        _react2.default.createElement(OrderButton, { bgColor: '#49c1c7', text: this.playBack == true ? 'already_backtip' : 'backtip',
	                            order: this.order,
	                            playBack: this.playBack, changeState: this.changeState })
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { style: { marginRight: _IsPcOrNot2.default.get() ? '80px' : '1.4rem' } },
	                        _react2.default.createElement(OrderButton, { bgColor: '#0080ff', text: this.order == true ? 'already_order' : 'order',
	                            order: this.order,
	                            playBack: this.playBack, changeState: this.changeState })
	                    ),
	                    _react2.default.createElement('div', { style: {
	                            width: '50px',
	                            height: '50px',
	                            background: 'url(' + _pc_video_back2.default + ') no-repeat center center',
	                            backgroundSize: 'cover',
	                            position: 'absolute',
	                            right: '0'
	                        } })
	                )
	            ) : _react2.default.createElement(
	                'div',
	                { style: {
	                        position: 'relative'
	                    } },
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: "100%",
	                            height: "1.45rem",
	                            display: 'flex',
	                            alignItems: "center",
	                            justifyContent: 'space-between',
	                            padding: '0 0.17rem'
	                        } },
	                    _react2.default.createElement('div', { style: {
	                            width: '.45rem',
	                            height: '.45rem',
	                            background: 'url(' + _m_video_back2.default + ') no-repeat center center',
	                            backgroundSize: 'cover',
	                            position: 'absolute',
	                            right: '.9rem'
	                        } }),
	                    _react2.default.createElement(
	                        'div',
	                        { style: { marginLeft: '1.4rem' } },
	                        _react2.default.createElement(OrderButton, { bgColor: '#49c1c7', text: this.playBack == true ? 'already_backtip' : 'backtip',
	                            order: this.order,
	                            playBack: this.playBack, changeState: this.changeState })
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { style: { marginRight: '1.4rem' } },
	                        _react2.default.createElement(OrderButton, { bgColor: '#0080ff', text: this.order == true ? 'already_order' : 'order',
	                            order: this.order,
	                            playBack: this.playBack, changeState: this.changeState })
	                    ),
	                    _react2.default.createElement('div', { style: {
	                            width: '.45rem',
	                            height: '.45rem',
	                            background: 'url(' + _m_order2.default + ') no-repeat center center',
	                            backgroundSize: 'cover',
	                            position: 'absolute',
	                            left: '.9rem'
	                        } })
	                )
	            );
	        }
	    }]);
	    return OrderArea;
	}(_react.Component);
	
	var PhoneMeeting = function (_Component3) {
	    (0, _inherits3.default)(PhoneMeeting, _Component3);
	
	    function PhoneMeeting(props) {
	        (0, _classCallCheck3.default)(this, PhoneMeeting);
	        return (0, _possibleConstructorReturn3.default)(this, (PhoneMeeting.__proto__ || (0, _getPrototypeOf2.default)(PhoneMeeting)).call(this, props));
	    }
	
	    (0, _createClass3.default)(PhoneMeeting, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement('div', { style: {
	                        width: '100%',
	                        height: '.8rem',
	                        backgroundImage: "url(" + _m_meet_desc2.default + ")",
	                        backgroundSize: 'cover',
	                        backgroundRepeat: 'no-repeat',
	                        position: 'relative'
	                    } }),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: "6.88rem",
	                            height: "auto",
	                            margin: '0 auto',
	                            lineHeight: '20px',
	                            fontSize: '14px',
	                            userSelect: 'none',
	                            textAlign: 'justify',
	                            overflow: 'hidden',
	                            padding: '.25rem'
	                        } },
	                    _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'meeting_desc_text' })
	                )
	            );
	        }
	    }]);
	    return PhoneMeeting;
	}(_react.Component);
	
	var Banner = function (_Component4) {
	    (0, _inherits3.default)(Banner, _Component4);
	
	    function Banner(props) {
	        (0, _classCallCheck3.default)(this, Banner);
	
	        var _this6 = (0, _possibleConstructorReturn3.default)(this, (Banner.__proto__ || (0, _getPrototypeOf2.default)(Banner)).call(this, props));
	
	        _this6.terminalShow = function (r) {
	            if (r == 'c') {
	                _this6.terminalFlag.value = false;
	            } else {
	                _this6.terminalFlag.value = !_this6.terminalFlag.value;
	            }
	            _this6.setState(_this6.terminalFlag);
	        };
	
	        _this6.terminalFlag = {
	            value: false
	        };
	        _this6.width = window.innerWidth;
	        return _this6;
	    }
	
	    (0, _createClass3.default)(Banner, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }, {
	        key: 'render',
	        value: function render() {
	            return _IsPcOrNot2.default.get() ? _react2.default.createElement(
	                'div',
	                { className: 'pc-banner', style: { width: '100%', minHeight: "656px", position: 'relative' } },
	                _react2.default.createElement('img', { src: _pc_banner2.default, style: { width: '100%', display: 'block', userSelect: 'none' }, alt: '' }),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: '890px',
	                            height: '600px',
	                            position: 'absolute',
	                            top: '25px',
	                            right: '10%',
	                            borderTopRightRadius: '6px',
	                            borderTopLeftRadius: "6px",
	                            overflow: 'hidden'
	                        } },
	                    this.terminalFlag.value ? _react2.default.createElement(
	                        'div',
	                        { className: 'pc', style: {
	                                width: '100%',
	                                height: '100%',
	                                overflow: 'hidden',
	                                position: "relative"
	                            } },
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    width: "100%",
	                                    height: '25px',
	                                    background: '#666666',
	                                    display: 'flex',
	                                    alignItems: 'center',
	                                    paddingLeft: "10px"
	                                } },
	                            _react2.default.createElement(
	                                'div',
	                                { onClick: this.terminalShow.bind(this, 'c'), style: {
	                                        fontSize: '20px',
	                                        color: '#fff',
	                                        cursor: 'pointer'
	                                    } },
	                                '\xD7'
	                            )
	                        ),
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    width: '100%',
	                                    height: '575px',
	                                    position: 'relative'
	                                } },
	                            _react2.default.createElement(_terminal.TerminalOutput, { flag: this.terminalFlag })
	                        )
	                    ) : null,
	                    _react2.default.createElement(
	                        'div',
	                        { onClick: this.terminalShow.bind(this, 'r'), style: {
	                                display: this.terminalFlag.value ? 'none' : 'block'
	                            } },
	                        _react2.default.createElement(TerminalC, null)
	                    )
	                )
	            ) : _react2.default.createElement(
	                'div',
	                { style: {
	                        backgroundImage: "url(" + (localStorage['language'] === 'en' ? _m_banner2.default : _m_banner2.default) + ")",
	                        backgroundRepeat: "no-repeat",
	                        backgroundSize: "100% auto",
	                        backgroundPosition: "top",
	                        position: "relative",
	                        width: "100%",
	                        height: _IsPcOrNot2.default.get() ? "725px" : "6.35rem",
	                        overflow: 'hidden'
	                    } },
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: "100%",
	                            textAlign: "center",
	                            fontSize: localStorage['language'] == 'en' ? '16px' : '18px',
	                            position: 'absolute',
	                            bottom: '0',
	                            color: '#01007a',
	                            fontWeight: 'bold'
	                        } },
	                    _react2.default.createElement(
	                        'p',
	                        { style: { margin: 0 } },
	                        '2019.07.03-07.04'
	                    ),
	                    _react2.default.createElement(
	                        'p',
	                        { style: { margin: 0 } },
	                        _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'address_2019' })
	                    )
	                )
	            );
	        }
	    }]);
	    return Banner;
	}(_react.Component);
	
	var Live = function (_Component5) {
	    (0, _inherits3.default)(Live, _Component5);
	
	    function Live(props) {
	        (0, _classCallCheck3.default)(this, Live);
	
	        var _this7 = (0, _possibleConstructorReturn3.default)(this, (Live.__proto__ || (0, _getPrototypeOf2.default)(Live)).call(this, props));
	
	        _this7.ordered = { ordered: false };
	        _this7.data = {};
	        _this7.error = {
	            text: ''
	        };
	        return _this7;
	    }
	
	    (0, _createClass3.default)(Live, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (localStorage.getItem("order") != undefined) {
	                this.ordered.ordered = localStorage.getItem("order");
	                this.setState(this.ordered);
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        width: "100%",
	                        height: _IsPcOrNot2.default.get() ? '670px' : '3.38rem',
	                        display: 'flex',
	                        overflow: 'hidden',
	                        position: 'relative',
	                        marginTop: _IsPcOrNot2.default.get() ? '' : '.5rem',
	                        margin: '0 auto',
	                        background: _IsPcOrNot2.default.get() ? '' : 'url(' + _m_video_bg2.default + ') no-repeat left bottom',
	                        backgroundSize: 'contain'
	                    } },
	                _react2.default.createElement(_BaseComponent.Menu, { ref: 'Menu', text: this.error.text }),
	                _react2.default.createElement(
	                    'div',
	                    { style: _IsPcOrNot2.default.get() ? {
	                            width: '1200px',
	                            height: '670px',
	                            margin: '0 auto',
	                            background: 'url(' + _pc_video2.default + ') no-repeat top left',
	                            backgroundSize: "contain",
	                            position: "absolute",
	                            left: 0,
	                            right: 0,
	                            bottom: "0",
	                            marginLeft: 'auto',
	                            marginRight: 'auto',
	                            zIndex: '9'
	
	                        } : {
	                            width: "6rem",
	                            height: '100%',
	                            backgroundImage: 'url(' + _m_video2.default + ')',
	                            backgroundSize: 'cover',
	                            backgroundRepeat: "no-repeat",
	                            margin: '0 auto'
	
	                        } },
	                    localStorage['language'] == 'en' ? _react2.default.createElement('iframe', { className: _IsPcOrNot2.default.get() ? "live" : "wap-live",
	                        style: _IsPcOrNot2.default.get() ? { height: "100%" } : { height: '100%' }
	                        // src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=c37265ddb525b03e3ff62260b75dd7ed&tvId=1137345900&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="true" width="100%" height="100%"
	                    }) : _react2.default.createElement('iframe', { className: _IsPcOrNot2.default.get() ? "live" : "wap-live",
	                        style: _IsPcOrNot2.default.get() ? { height: "100%" } : { height: '100%' }
	                        // src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=c37265ddb525b03e3ff62260b75dd7ed&tvId=1137345900&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="true" width="100%" height="100%"
	                    })
	                ),
	                _IsPcOrNot2.default.get() ? _react2.default.createElement('img', { src: _pc_video_bg2.default, style: {
	                        display: 'block',
	                        position: 'absolute',
	                        bottom: '0'
	                    }, alt: '' }) : null
	            );
	        }
	    }]);
	    return Live;
	}(_react.Component);
	
	var BuyTicketsArea = function (_Component6) {
	    (0, _inherits3.default)(BuyTicketsArea, _Component6);
	
	    function BuyTicketsArea(props) {
	        (0, _classCallCheck3.default)(this, BuyTicketsArea);
	
	        var _this8 = (0, _possibleConstructorReturn3.default)(this, (BuyTicketsArea.__proto__ || (0, _getPrototypeOf2.default)(BuyTicketsArea)).call(this, props));
	
	        _this8.buy = function () {
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + '/ticket_type');
	        };
	
	        _this8.webDaoyu = [_m_daoyu_2.default, _m_daoyu_4.default, _m_daoyu_6.default, _m_daoyu_8.default, _m_daoyu_10.default, _m_daoyu_12.default];
	        _this8.pcDaoyu = [_pc_daoyu_2.default, _pc_daoyu_4.default, _pc_daoyu_6.default, _pc_daoyu_8.default, _pc_daoyu_10.default, _pc_daoyu_12.default];
	        _this8.webDaoyuEn = [_m_daoyu_01_en2.default, _m_daoyu_02_en2.default, _m_daoyu_03_en2.default, _m_daoyu_04_en2.default, _m_daoyu_05_en2.default, _m_daoyu_06_en2.default];
	        _this8.pcDaoyuEn = [_pc_daoyu_01_en2.default, _pc_daoyu_02_en2.default, _pc_daoyu_03_en2.default, _pc_daoyu_04_en2.default, _pc_daoyu_05_en2.default, _pc_daoyu_06_en2.default];
	        _this8.daoyuList = [];
	        return _this8;
	    }
	
	    (0, _createClass3.default)(BuyTicketsArea, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (_IsPcOrNot2.default.get()) {
	                if (localStorage['language'] != 'en') {
	                    // pc中文
	                    this.daoyuList = this.pcDaoyu;
	                } else {
	                    this.daoyuList = this.pcDaoyuEn;
	                }
	            } else {
	                if (localStorage['language'] != 'en') {
	                    //web 中文
	                    this.daoyuList = this.webDaoyu;
	                } else {
	                    this.daoyuList = this.webDaoyuEn;
	                }
	            }
	            this.setState({
	                daoyuList: this.daoyuList
	            }, function () {
	                var daoyuSwiper = new _swiper2.default('.daoyu-container', {
	                    slidesPerView: 1,
	                    spaceBetween: 0,
	                    loop: true,
	                    autoplay: {
	                        disableOnInteraction: false
	                    },
	                    noSwiping: true,
	                    observer: true,
	                    observeParents: true
	                });
	                (0, _nZepto2.default)('.swiper-slide').mouseenter(function () {
	                    daoyuSwiper.autoplay.stop();
	                });
	                (0, _nZepto2.default)('.swiper-slide').mouseleave(function () {
	                    daoyuSwiper.autoplay.start();
	                });
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        textAlign: "center",
	                        position: 'relative'
	                    } },
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: '100%',
	                            position: "relative"
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'daoyu-container', style: {
	                                position: "relative",
	                                margin: '0 auto',
	                                overflow: 'hidden',
	                                marginTop: _IsPcOrNot2.default.get() ? '' : ".4rem",
	                                width: _IsPcOrNot2.default.get() ? '1200px' : '6.2rem',
	                                height: _IsPcOrNot2.default.get() ? '350px' : '4.5rem'
	                            } },
	                        _react2.default.createElement(
	                            'div',
	                            { className: 'swiper-wrapper' },
	                            this.daoyuList.map(function (item, key) {
	                                return _react2.default.createElement('div', { key: key,
	                                    className: 'swiper-slide', style: {
	                                        backgroundImage: 'url(' + item + ')',
	                                        width: _IsPcOrNot2.default.get() ? '1200px' : '6.2rem',
	                                        height: _IsPcOrNot2.default.get() ? '350px' : '4.5rem',
	                                        backgroundSize: 'contain',
	                                        backgroundPosition: 'center',
	                                        backgroundRepeat: 'no-repeat',
	                                        cursor: 'pointer'
	                                    } });
	                            })
	                        )
	                    )
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? '1200px' : 'auto',
	                            height: _IsPcOrNot2.default.get() ? '300px' : '3rem',
	                            position: "relative",
	                            display: "flex",
	                            alignItems: "center",
	                            margin: '0 auto'
	                        } },
	                    _react2.default.createElement('div', { style: {
	                            width: _IsPcOrNot2.default.get() ? '45px' : ".45rem",
	                            height: _IsPcOrNot2.default.get() ? '45px' : '.45rem',
	                            background: "url(" + _pc_add_icon2.default + ") no-repeat center center",
	                            backgroundSize: 'contain',
	                            position: "absolute",
	                            left: _IsPcOrNot2.default.get() ? '310px' : '.7rem'
	                        } }),
	                    _react2.default.createElement(
	                        'div',
	                        { onClick: this.buy, className: 'base_btn_c', style: {
	                                cursor: "pointer",
	                                background: "#de4752",
	                                // background: localStorage['language'] == 'en' ? 'url(' + limit_buy_en + ') center center' : 'url(' + limit_buy_zh + ') center center',
	                                backgroundSize: 'contain',
	                                backgroundRepeat: 'no-repeat',
	                                width: _IsPcOrNot2.default.get() ? '330px' : '3rem',
	                                height: _IsPcOrNot2.default.get() ? '85px' : "1rem",
	                                fontSize: _IsPcOrNot2.default.get() ? '24px' : '0.35rem',
	                                textAlign: "center",
	                                lineHeight: _IsPcOrNot2.default.get() ? '85px' : '1rem',
	                                color: "#fff",
	                                position: 'absolute',
	                                top: 0,
	                                bottom: "0",
	                                left: 0,
	                                right: '0',
	                                margin: 'auto',
	                                boxShadow: '0 0 3px 1px rgba(79, 26, 30,.2) '
	                            } },
	                        _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'join_meeting_buy_tickets' })
	                    ),
	                    _IsPcOrNot2.default.get() ? _react2.default.createElement('div', { style: {
	                            width: '80px',
	                            height: '32px',
	                            background: "url(" + _pc_right_arror2.default + ") no-repeat center center",
	                            backgroundSize: 'cover',
	                            position: 'absolute',
	                            right: '310px'
	                        } }) : null
	                ),
	                _react2.default.createElement(Live, null)
	            );
	        }
	    }]);
	    return BuyTicketsArea;
	}(_react.Component);
	
	var MeetingDesc = function (_Component7) {
	    (0, _inherits3.default)(MeetingDesc, _Component7);
	
	    function MeetingDesc(props) {
	        (0, _classCallCheck3.default)(this, MeetingDesc);
	        return (0, _possibleConstructorReturn3.default)(this, (MeetingDesc.__proto__ || (0, _getPrototypeOf2.default)(MeetingDesc)).call(this, props));
	    }
	
	    (0, _createClass3.default)(MeetingDesc, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        position: "relative",
	                        width: "100%",
	                        minWidth: '1200px'
	                    } },
	                _react2.default.createElement('img', { src: _pc_meeting_desc2.default, alt: '', style: {
	                        width: "100%"
	                    } }),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: "800px",
	                            margin: "20px auto",
	                            color: "#777"
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { id: 'meeting_desc_text', style: {
	                                position: "relative",
	                                lineHeight: "45px",
	                                padding: "30px 0",
	                                fontSize: '20px',
	                                userSelect: 'none',
	                                textAlign: 'justify'
	                            }, className: localStorage['language'] == 'en' ? "meeting_desc_text_en" : "meeting_desc_text" },
	                        _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'meeting_desc_text' })
	                    )
	                )
	            );
	        }
	    }]);
	    return MeetingDesc;
	}(_react.Component);
	
	var Program = function (_Component8) {
	    (0, _inherits3.default)(Program, _Component8);
	
	    function Program(props) {
	        (0, _classCallCheck3.default)(this, Program);
	
	        var _this10 = (0, _possibleConstructorReturn3.default)(this, (Program.__proto__ || (0, _getPrototypeOf2.default)(Program)).call(this, props));
	
	        _this10.go_sub = function (i) {
	            if (i == 1 || i == 2) {
	                i = 1;
	            }
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + "/agenda?i=" + i);
	        };
	
	        _this10.goAgenda = function () {
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + "/agenda");
	        };
	
	        return _this10;
	    }
	
	    (0, _createClass3.default)(Program, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this11 = this;
	
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                    'div',
	                    null,
	                    _IsPcOrNot2.default.get() ? _react2.default.createElement('img', { style: { width: '100%' }, src: _pc_agenda2.default, alt: '' }) : null,
	                    _react2.default.createElement(
	                        'div',
	                        { className: _IsPcOrNot2.default.get() ? "program-title" : "wap-program-title",
	                            style: {
	                                width: _IsPcOrNot2.default.get() ? '1200px' : "100%",
	                                height: _IsPcOrNot2.default.get() ? '50px' : '1.7rem',
	                                backgroundImage: _IsPcOrNot2.default.get() ? '' : "url(" + _m_agenda2.default + ")",
	                                backgroundRepeat: 'no-repeat',
	                                backgroundSize: 'contain',
	                                position: 'relative',
	                                overflow: 'hidden',
	                                margin: '0 auto'
	                            } },
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    fontSize: _IsPcOrNot2.default.get() ? '20px' : "14px",
	                                    textAlign: _IsPcOrNot2.default.get() ? "right" : "center",
	                                    position: _IsPcOrNot2.default.get() ? 'relative' : 'absolute',
	                                    right: '.4rem',
	                                    bottom: '0rem',
	                                    color: "#01007a",
	                                    cursor: "pointer"
	                                } },
	                            _react2.default.createElement(
	                                'span',
	                                { onClick: this.goAgenda },
	                                _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'more_meeting' }),
	                                ' >>'
	                            )
	                        )
	                    )
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { style: _IsPcOrNot2.default.get() ? {
	                            width: "1200px",
	                            margin: "0 auto",
	                            position: "relative"
	                        } : { padding: "0" } },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: _IsPcOrNot2.default.get() ? '1200px' : "100%",
	                                position: "relative",
	                                margin: '0 auto',
	                                cursor: 'pointer'
	                            } },
	                        this.props.data.map(function (item, key) {
	                            return _react2.default.createElement(
	                                'div',
	                                { key: key },
	                                key == 0 ? _react2.default.createElement(
	                                    'div',
	                                    { style: _IsPcOrNot2.default.get() ? {
	                                            width: '100%',
	                                            height: '90px',
	                                            lineHeight: '90px',
	                                            fontSize: '40px',
	                                            backgroundColor: '#fff',
	                                            color: '#01007a',
	                                            fontWeight: '600',
	                                            margin: '0 auto'
	                                        } : {
	                                            width: '6.88rem',
	                                            height: '.7rem',
	                                            lineHeight: '.7rem',
	                                            fontSize: '.4rem',
	                                            backgroundColor: '#fff',
	                                            color: '#01007a',
	                                            fontWeight: '600',
	                                            margin: '0 auto',
	                                            marginTop: '.15rem'
	                                        } },
	                                    _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'agenda_day1_19' })
	                                ) : key == 2 ? _react2.default.createElement(
	                                    'div',
	                                    { style: _IsPcOrNot2.default.get() ? {
	                                            width: '100%',
	                                            height: '90px',
	                                            lineHeight: '90px',
	                                            fontSize: '40px',
	                                            backgroundColor: '#fff',
	                                            color: '#01007a',
	                                            fontWeight: '600',
	                                            margin: '0 auto'
	                                        } : {
	                                            height: '.7rem',
	                                            lineHeight: '.7rem',
	                                            fontSize: '.4rem',
	                                            backgroundColor: '#fff',
	                                            color: '#01007a',
	                                            fontWeight: '600',
	                                            width: '6.88rem',
	                                            margin: '0 auto',
	                                            marginTop: '.15rem'
	                                        } },
	                                    _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'agenda_day2_19' })
	                                ) : null,
	                                _react2.default.createElement(
	                                    'div',
	                                    { onClick: _this11.go_sub.bind(_this11, key), className: 'base_btn_c', key: key,
	                                        style: {
	                                            width: _IsPcOrNot2.default.get() ? '1200px' : '6.88rem',
	                                            height: _IsPcOrNot2.default.get() ? '140px' : '1.42rem',
	                                            padding: _IsPcOrNot2.default.get() ? '20px' : '.2rem .3rem',
	                                            margin: '0 auto',
	                                            marginTop: '.15rem',
	                                            backgroundColor: key == 0 ? '#01007a' : key % 2 == 0 ? '#49c1c7' : '#008fff',
	                                            fontWeight: '600',
	                                            fontSize: _IsPcOrNot2.default.get() ? localStorage['language'] == 'en' ? '35px' : '35px' : localStorage['language'] == 'en' ? '.3rem' : '.35rem'
	                                        } },
	                                    _react2.default.createElement(
	                                        'div',
	                                        { style: {
	                                                display: 'flex',
	                                                justifyContent: 'center',
	                                                alignItems: 'center',
	                                                borderRight: '1px dashed #fff',
	                                                float: 'left',
	                                                width: _IsPcOrNot2.default.get() ? '300px' : '2.6rem',
	                                                height: '100%',
	                                                boxSizing: 'border-box',
	                                                color: '#fff'
	                                            } },
	                                        item.time
	                                    ),
	                                    _react2.default.createElement(
	                                        'div',
	                                        { style: {
	                                                float: 'left',
	                                                width: _IsPcOrNot2.default.get() ? '860px' : '3.68rem',
	                                                height: '100%',
	                                                paddingLeft: '.25rem',
	                                                overflow: 'hidden',
	                                                display: 'flex',
	                                                alignItems: "center",
	                                                flexWrap: 'wrap'
	                                            } },
	                                        _react2.default.createElement(
	                                            'span',
	                                            { style: {
	                                                    display: 'block',
	                                                    color: key == 0 ? '#d2ff00' : '#fff'
	                                                } },
	                                            item.content
	                                        )
	                                    )
	                                )
	                            );
	                        })
	                    )
	                )
	            );
	        }
	    }]);
	    return Program;
	}(_react.Component);
	
	//分论坛
	
	
	var SubForums = function (_Component9) {
	    (0, _inherits3.default)(SubForums, _Component9);
	
	    function SubForums(props) {
	        (0, _classCallCheck3.default)(this, SubForums);
	
	        var _this12 = (0, _possibleConstructorReturn3.default)(this, (SubForums.__proto__ || (0, _getPrototypeOf2.default)(SubForums)).call(this, props));
	
	        _this12.goSubFroums = function (i) {
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + "/agenda?s=" + i);
	        };
	
	        _this12.subFormsRender = function () {
	            var m = 2;
	            var flag = true;
	            return _this12.props.data.map(function (item, key) {
	                if (key == m) {
	                    m = m + 2;
	                    flag = !flag;
	                }
	                return item.forum_type == 1 ? _react2.default.createElement(
	                    'div',
	                    { className: 'base_btn_c', onClick: _this12.goSubFroums.bind(_this12, key), key: key, style: {
	                            width: _IsPcOrNot2.default.get() ? '300px' : "2.9rem",
	                            height: _IsPcOrNot2.default.get() ? '180px' : '1.8rem',
	                            cursor: 'pointer',
	                            color: '#fff',
	                            fontSize: _IsPcOrNot2.default.get() ? '20px' : localStorage['language'] == 'en' ? '12px' : '14px',
	                            backgroundColor: !_IsPcOrNot2.default.get() ? flag ? key % 2 == 0 ? '#0080ff' : '#ef5864' : key % 2 == 0 ? '#ef5864' : '#0080ff' : key % 2 == 0 ? '#ef5864' : '#0080ff',
	                            marginBottom: _IsPcOrNot2.default.get() ? '50px' : '.2rem',
	                            position: 'relative',
	                            fontWeight: '600'
	                        } },
	                    _react2.default.createElement('div', { style: {
	                            width: _IsPcOrNot2.default.get() ? '140px' : '1.4rem',
	                            height: _IsPcOrNot2.default.get() ? '130px' : '1.3rem',
	                            background: 'url(' + _this12.iconList[key] + ') no-repeat center center',
	                            backgroundSize: "cover",
	                            position: 'absolute',
	                            top: 0,
	                            bottom: 0,
	                            marginTop: 'auto',
	                            marginBottom: 'auto',
	                            left: _IsPcOrNot2.default.get() ? '-20px' : '-0.2rem'
	                        } }),
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: _IsPcOrNot2.default.get() ? '160px' : '1.7rem',
	                                height: '100%',
	                                position: 'absolute',
	                                top: 0,
	                                right: 0,
	                                padding: '.2rem .2rem .2rem 0'
	                            } },
	                        _react2.default.createElement(
	                            'span',
	                            { style: { textAlign: 'center' } },
	                            localStorage['language'] === 'en' ? item.title_en : item.title_ch
	                        ),
	                        _react2.default.createElement('img', { src: _subForums_right_icon2.default, style: {
	                                width: _IsPcOrNot2.default.get() ? '63px' : '..63rem',
	                                height: _IsPcOrNot2.default.get() ? '22px' : '.22rem',
	                                marginLeft: _IsPcOrNot2.default.get() ? '10px' : '',
	                                display: "block",
	                                position: 'absolute',
	                                bottom: _IsPcOrNot2.default.get() ? '20px' : '.2rem',
	                                right: _IsPcOrNot2.default.get() ? '20px' : '.2rem'
	                            }, alt: '' })
	                    )
	                ) : null;
	            });
	        };
	
	        _this12.pcList = [_danao_r2.default, _znst_b2.default, _znjs_r2.default, _xcx_b2.default, _xiaodu_r2.default, _zny_b2.default, _Aijh_r2.default, _g_b2.default, _inter_r2.default];
	        _this12.webList = [_danao_b2.default, _znst_r2.default, _znjs_r2.default, _xcx_b2.default, _xiaodu_b2.default, _zny_r2.default, _Aijh_r2.default, _g_b2.default, _inter_b2.default];
	        _this12.iconList = [];
	        return _this12;
	    }
	
	    (0, _createClass3.default)(SubForums, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            if (_IsPcOrNot2.default.get()) {
	                this.iconList = this.pcList;
	            } else {
	                this.iconList = this.webList;
	            }
	            this.setState({
	                iconList: this.iconList
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? '1200px' : '100%',
	                            margin: '0 auto',
	                            padding: _IsPcOrNot2.default.get() ? '' : '0 .31rem'
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: '100%',
	                                height: '1rem',
	                                display: 'flex',
	                                alignItems: "center",
	                                margin: '0 auto'
	                            } },
	                        _react2.default.createElement('div', { style: {
	                                background: 'url(' + _m_add_icon2.default + ') no-repeat center center',
	                                backgroundSize: 'cover',
	                                width: '.45rem',
	                                height: '.45rem'
	                            } }),
	                        _react2.default.createElement(
	                            'div',
	                            { style: { padding: '0 .1rem', fontSize: '.4rem', fontWeight: '600', color: '#01007a' } },
	                            _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'subForums_title_19' })
	                        ),
	                        _react2.default.createElement('div', { style: {
	                                background: 'url(' + _m_add_icon2.default + ') no-repeat center center',
	                                backgroundSize: 'cover',
	                                width: '.45rem',
	                                height: '.45rem'
	                            } })
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: '100%',
	                                display: 'flex',
	                                justifyContent: 'space-between',
	                                flexWrap: 'wrap',
	                                padding: '0 .2rem'
	                            } },
	                        this.subFormsRender()
	                    )
	                )
	            );
	        }
	    }]);
	    return SubForums;
	}(_react.Component);
	
	//公开课
	
	
	var OpenClass = function (_Component10) {
	    (0, _inherits3.default)(OpenClass, _Component10);
	
	    function OpenClass(props) {
	        (0, _classCallCheck3.default)(this, OpenClass);
	
	        var _this13 = (0, _possibleConstructorReturn3.default)(this, (OpenClass.__proto__ || (0, _getPrototypeOf2.default)(OpenClass)).call(this, props));
	
	        _this13.renderOpenClass = function () {
	            var flag = false;
	            var m = 1;
	            var bg = void 0;
	            return _this13.props.data.map(function (item, key) {
	                if (key == m) {
	                    m = m + 2;
	                    flag = !flag;
	                }
	                if (flag) {
	                    if (key % 2 == 0) {
	                        bg = '#008fff';
	                    } else {
	                        bg = '#49c1c7';
	                    }
	                } else {
	                    if (key % 2 == 0) {
	                        bg = '#49c1c7';
	                    } else {
	                        bg = '#008fff';
	                    }
	                }
	                return item.forum_type == '2' ? _react2.default.createElement(
	                    'div',
	                    { key: key, style: {
	                            width: _IsPcOrNot2.default.get() ? '50%' : '100%',
	                            overflow: "hidden",
	                            fontSize: _IsPcOrNot2.default.get() ? '19px' : '14px',
	                            marginBottom: _IsPcOrNot2.default.get() ? '25px' : '8px',
	                            minHeight: _IsPcOrNot2.default.get() ? '46px' : '.64rem',
	                            cursor: "pointer",
	                            paddingLeft: _IsPcOrNot2.default.get() ? '' : ".1rem",
	                            display: 'flex',
	                            flexWrap: 'no-wrap'
	                        } },
	                    _react2.default.createElement('span', { style: {
	                            display: 'inline-block',
	                            width: _IsPcOrNot2.default.get() ? '20px' : '8px',
	                            height: _IsPcOrNot2.default.get() ? '20px' : '8px',
	                            transform: "rotate(45deg)",
	                            backgroundColor: _IsPcOrNot2.default.get() ? bg : key % 2 == 0 ? '#49c1c7' : '#008fff',
	                            margin: _IsPcOrNot2.default.get() ? '5px 0 0 5px' : '.05rem 0 0 .05rem',
	                            float: "left",
	                            verticalAlign: 'center'
	                        } }),
	                    _react2.default.createElement(
	                        'span',
	                        { style: {
	                                display: 'inline-block',
	                                paddingLeft: '8px',
	                                width: _IsPcOrNot2.default.get() ? "500px" : '6.7rem',
	                                float: 'left',
	                                verticalAlign: 'center',
	                                lineHeight: _IsPcOrNot2.default.get() ? '25px' : '18px'
	                            } },
	                        localStorage['language'] === 'en' ? item.title_en : item.title_ch
	                    )
	                ) : null;
	            });
	        };
	
	        return _this13;
	    }
	    //indexChange
	
	
	    (0, _createClass3.default)(OpenClass, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? '1200px' : '100%',
	                            margin: '0 auto',
	                            padding: _IsPcOrNot2.default.get() ? '' : '0 .31rem'
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: '100%',
	                                height: '1rem',
	                                display: 'flex',
	                                alignItems: "center",
	                                margin: '0 auto'
	                            } },
	                        _react2.default.createElement('div', { style: {
	                                background: 'url(' + _m_add_icon2.default + ') no-repeat center center',
	                                backgroundSize: 'cover',
	                                width: '.45rem',
	                                height: '.45rem'
	                            } }),
	                        _react2.default.createElement(
	                            'div',
	                            { style: { padding: '0 .1rem', fontSize: '.4rem', fontWeight: '600', color: '#01007a' } },
	                            _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'openClass_title_19' })
	                        ),
	                        _react2.default.createElement('div', { style: {
	                                background: 'url(' + _m_add_icon2.default + ') no-repeat center center',
	                                backgroundSize: 'cover',
	                                width: '.45rem',
	                                height: '.45rem'
	                            } })
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: '100%',
	                                display: 'flex',
	                                justifyContent: 'space-between',
	                                flexWrap: 'wrap'
	                            } },
	                        this.renderOpenClass()
	                    )
	                )
	            );
	        }
	    }]);
	    return OpenClass;
	}(_react.Component);
	
	// 会议嘉宾
	
	
	var Guests = function (_Component11) {
	    (0, _inherits3.default)(Guests, _Component11);
	
	    function Guests(props) {
	        (0, _classCallCheck3.default)(this, Guests);
	
	        var _this14 = (0, _possibleConstructorReturn3.default)(this, (Guests.__proto__ || (0, _getPrototypeOf2.default)(Guests)).call(this, props));
	
	        _this14.more_guests = function () {
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + "/speakers");
	        };
	
	        _this14.titleArray = function (arr, flag) {
	            if (arr != undefined) {
	                arr = arr.split('/n');
	                return arr.map(function (i, k) {
	                    return _react2.default.createElement(
	                        'p',
	                        { key: k, style: {
	                                margin: '0',
	                                marginTop: '.1rem',
	                                color: '#fff',
	                                fontSize: _IsPcOrNot2.default.get() ? '16px' : '12px',
	                                width: '100%',
	                                height: 'auto',
	                                float: 'left',
	                                fontWeight: '600'
	                            } },
	                        i
	                    );
	                });
	            }
	        };
	
	        return _this14;
	    }
	
	    (0, _createClass3.default)(Guests, [{
	        key: 'guestRender',
	        value: function guestRender() {
	            var _this15 = this;
	
	            var m = 2;
	            var flag = true;
	            return this.props.data.map(function (item, key) {
	                if (key == m) {
	                    m = m + 2;
	                    flag = !flag;
	                }
	                return item.order_index < 10 ? _react2.default.createElement(
	                    'div',
	                    { key: key },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: _IsPcOrNot2.default.get() ? '590px' : '6.88rem',
	                                height: _IsPcOrNot2.default.get() ? '250px' : '2.6rem',
	                                backgroundColor: '#01007a',
	                                marginBottom: _IsPcOrNot2.default.get() ? '25px' : ".2rem",
	                                alignItems: "center",
	                                flexWrap: 'wrap',
	                                marginTop: item.order_index == 10 ? _IsPcOrNot2.default.get() ? '' : '3.1rem' : '',
	                                position: 'relative',
	                                zIndex: '9'
	                            } },
	                        _react2.default.createElement('img', { src: item.head_img, style: {
	                                height: '100%',
	                                display: 'block',
	                                boxSizing: 'border-box',
	                                float: _IsPcOrNot2.default.get() ? flag ? 'left' : 'right' : key % 2 == 0 ? 'left' : 'right'
	                            }, alt: '' }),
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    width: _IsPcOrNot2.default.get() ? '340px' : '4.2rem',
	                                    height: '100%',
	                                    overflow: 'hidden',
	                                    padding: _IsPcOrNot2.default.get() ? '30px 30px 0 30px' : '.3rem',
	                                    float: _IsPcOrNot2.default.get() ? flag ? 'right' : 'left' : key % 2 == 0 ? 'left' : 'right'
	                                } },
	                            _react2.default.createElement(
	                                'span',
	                                { style: {
	                                        display: 'block',
	                                        borderBottom: '2px solid #49c1c7',
	                                        paddingBottom: '.05rem',
	                                        boxSizing: 'border-box',
	                                        fontSize: _IsPcOrNot2.default.get() ? '20px' : "14px",
	                                        color: '#fff',
	                                        float: 'left',
	                                        fontWeight: '600'
	                                    } },
	                                localStorage['language'] === 'en' ? item.name_en : item.name_ch
	                            ),
	                            _this15.titleArray.bind(_this15, localStorage['language'] == 'en' ? item.desc_en : item.desc_ch)()
	                        )
	                    )
	                ) : null;
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: { position: "relative" } },
	                _IsPcOrNot2.default.get() ? _react2.default.createElement(
	                    'div',
	                    { style: {
	                            overflow: "hidden"
	                        } },
	                    _react2.default.createElement('img', { src: _pc_guest2.default, style: { width: '100%' }, alt: '' })
	                ) : _react2.default.createElement('div', { style: {
	                        background: 'url(' + _m_guest2.default + ') no-repeat center center',
	                        backgroundSize: 'cover',
	                        height: '4.8rem',
	                        position: "relative",
	                        overflow: 'hidden'
	                    } }),
	                _react2.default.createElement(
	                    'div',
	                    { style: _IsPcOrNot2.default.get() ? {
	                            width: '1200px',
	                            fontSize: "22px",
	                            textAlign: 'right',
	                            bottom: "20px",
	                            color: "#01007a",
	                            cursor: "pointer",
	                            padding: '20px 0 40px 0',
	                            margin: '0 auto'
	                        } : {
	                            color: '#01007a',
	                            fontSize: "14px",
	                            padding: "20px 0",
	                            textAlign: "center",
	                            position: 'absolute',
	                            top: '2.15rem',
	                            right: '.35rem'
	                        } },
	                    _react2.default.createElement(
	                        'span',
	                        { onClick: this.more_guests },
	                        _react2.default.createElement(_BaseComponent.FormattedMessage, { id: 'more_guests' }),
	                        ' >>'
	                    )
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? "1200px" : "100%",
	                            margin: _IsPcOrNot2.default.get() ? "60px auto 0px auto" : "0",
	                            position: "relative"
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: '100%',
	                                padding: _IsPcOrNot2.default.get() ? '' : '0 .31rem',
	                                display: "flex",
	                                justifyContent: 'space-between',
	                                flexWrap: 'wrap',
	                                marginTop: _IsPcOrNot2.default.get() ? '' : '-1.2rem'
	                            } },
	                        this.guestRender()
	                    )
	                )
	            );
	        }
	    }]);
	    return Guests;
	}(_react.Component);
	
	var Scientist = function (_Component12) {
	    (0, _inherits3.default)(Scientist, _Component12);
	
	    function Scientist(props) {
	        (0, _classCallCheck3.default)(this, Scientist);
	
	        var _this16 = (0, _possibleConstructorReturn3.default)(this, (Scientist.__proto__ || (0, _getPrototypeOf2.default)(Scientist)).call(this, props));
	
	        _this16.more_guests = function () {
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + "/speakers");
	        };
	
	        _this16.titleArray = function (str, flag) {
	            if (str != undefined) {
	                var arr = str.split('\n');
	                return arr.map(function (i, k) {
	                    return _react2.default.createElement(
	                        'p',
	                        { key: k, style: {
	                                margin: '0',
	                                marginTop: '.1rem',
	                                color: '#000',
	                                fontSize: _IsPcOrNot2.default.get() ? '16px' : '12px',
	                                width: '100%',
	                                height: 'auto',
	                                float: 'left',
	                                fontWeight: '600'
	                            } },
	                        i
	                    );
	                });
	            }
	        };
	
	        return _this16;
	    }
	
	    (0, _createClass3.default)(Scientist, [{
	        key: 'guestRender',
	        value: function guestRender() {
	            var _this17 = this;
	
	            var flag = true;
	            var changeFlag = false;
	            var m = void 0;
	            return this.props.data.map(function (item, key) {
	                if (item.order_index == 10) {
	                    m = key + 2;
	                }
	                if (key == m) {
	                    m = m + 2;
	                    flag = !flag;
	                }
	                return item.order_index >= 10 ? _react2.default.createElement(
	                    'div',
	                    { key: key },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: _IsPcOrNot2.default.get() ? '590px' : '6.88rem',
	                                height: _IsPcOrNot2.default.get() ? '250px' : '3rem',
	                                backgroundColor: '#ffffff',
	                                alignItems: "center",
	                                flexWrap: 'wrap',
	                                position: 'relative',
	                                zIndex: '9',
	                                borderBottom: "1px solid #999999",
	                                padding: _IsPcOrNot2.default.get() ? '30px 0' : '.25rem 0'
	                            } },
	                        _react2.default.createElement('img', { src: item.head_img, style: {
	                                height: '100%',
	                                display: 'block',
	                                boxSizing: 'border-box',
	                                border: '1px solid #b4b4b6',
	                                borderRadius: '50%',
	                                float: _IsPcOrNot2.default.get() ? flag ? 'right' : 'left' : key % 2 == 0 ? 'left' : 'right'
	                            }, alt: '' }),
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    width: _IsPcOrNot2.default.get() ? '401px' : '4.2rem',
	                                    height: '100%',
	                                    overflow: 'hidden',
	                                    padding: _IsPcOrNot2.default.get() ? '30px 30px 0 30px' : '0 .1rem',
	                                    float: _IsPcOrNot2.default.get() ? flag ? 'left' : 'right' : key % 2 == 0 ? 'left' : 'right'
	                                } },
	                            _react2.default.createElement(
	                                'span',
	                                { style: {
	                                        display: 'block',
	                                        borderBottom: '2px solid #49c1c7',
	                                        paddingBottom: '.05rem',
	                                        boxSizing: 'border-box',
	                                        fontSize: _IsPcOrNot2.default.get() ? '20px' : "14px",
	                                        color: '#01007a',
	                                        float: 'left',
	                                        fontWeight: '600'
	                                    } },
	                                localStorage['language'] === 'en' ? item.name_en : item.name_ch
	                            ),
	                            _this17.titleArray.bind(_this17, localStorage['language'] === 'en' ? item.desc_en : item.desc_ch)()
	                        )
	                    )
	                ) : null;
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: { position: "relative" } },
	                _IsPcOrNot2.default.get() ? _react2.default.createElement(
	                    'div',
	                    { style: {
	                            overflow: "hidden"
	                        } },
	                    _react2.default.createElement('img', { src: _pc_science2.default, style: { width: '100%' }, alt: '' })
	                ) : _react2.default.createElement('div', { style: {
	                        background: 'url(' + _m_science2.default + ') no-repeat center center',
	                        backgroundSize: 'cover',
	                        height: '4.8rem',
	                        position: "relative",
	                        overflow: 'hidden',
	                        marginTop: "-.5rem"
	                    } }),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? "1200px" : "100%",
	                            margin: _IsPcOrNot2.default.get() ? "60px auto 0px auto" : "0",
	                            position: "relative"
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                width: '100%',
	                                padding: _IsPcOrNot2.default.get() ? '' : '0 .31rem',
	                                display: "flex",
	                                justifyContent: 'space-between',
	                                flexWrap: 'wrap',
	                                marginTop: _IsPcOrNot2.default.get() ? '' : '-1.2rem'
	                            } },
	                        this.guestRender()
	                    )
	                )
	            );
	        }
	    }]);
	    return Scientist;
	}(_react.Component);
	
	//会议咨询
	
	
	var NewsArea = function (_Component13) {
	    (0, _inherits3.default)(NewsArea, _Component13);
	
	    function NewsArea(props) {
	        (0, _classCallCheck3.default)(this, NewsArea);
	
	        var _this18 = (0, _possibleConstructorReturn3.default)(this, (NewsArea.__proto__ || (0, _getPrototypeOf2.default)(NewsArea)).call(this, props));
	
	        _this18.more = function () {
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + '/news');
	        };
	
	        _this18.goNewsDetail = function (href) {
	            window.open(href);
	        };
	
	        _this18.news = [];
	        return _this18;
	    }
	
	    (0, _createClass3.default)(NewsArea, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this19 = this;
	
	            _nZepto2.default.get('/json/new2019.json' + "?timestamp=" + new Date().getTime(), function (data) {
	                if (data.error_no == '0') {
	                    _this19.news = data.data;
	                    _this19.setState(_this19.news);
	                    var newsSwiper = new _swiper2.default('.news-swiper-container', {
	                        slidesPerView: 1,
	                        spaceBetween: 0,
	                        loop: true,
	                        pagination: {
	                            el: '.swiper-pagination',
	                            clickable: true
	                        },
	                        navigation: {
	                            nextEl: '.swiper-button-next',
	                            prevEl: '.swiper-button-prev'
	                        },
	                        autoplay: {
	                            disableOnInteraction: false
	                        },
	                        noSwiping: true,
	                        observer: true,
	                        observeParents: true
	                    });
	                    (0, _nZepto2.default)('.swiper-slide').mouseenter(function () {
	                        newsSwiper.autoplay.stop();
	                    });
	                    (0, _nZepto2.default)('.swiper-slide').mouseleave(function () {
	                        newsSwiper.autoplay.start();
	                    });
	                }
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        position: 'relative',
	                        overflow: 'hidden',
	                        width: '100%'
	                    } },
	                _IsPcOrNot2.default.get() ? _react2.default.createElement('img', { src: _pc_news2.default, style: { width: '100%' }, alt: '' }) : _react2.default.createElement('div', { style: {
	                        width: '100%',
	                        height: '.99rem',
	                        marginTop: '.35rem',
	                        background: 'url(' + _m_news2.default + ') no-repeat center center',
	                        backgroundSize: 'contain'
	
	                    } }),
	                _react2.default.createElement('div', { style: {
	                        fontSize: _IsPcOrNot2.default.get() ? '20px' : "14px",
	                        textAlign: _IsPcOrNot2.default.get() ? 'right' : 'center',
	                        width: _IsPcOrNot2.default.get() ? '1200px' : '100%',
	                        padding: _IsPcOrNot2.default.get() ? "" : '.1rem .31rem',
	                        margin: '0 auto',
	                        color: "#01007a",
	                        cursor: "pointer"
	                    } }),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'news-swiper-container', style: {
	                            width: _IsPcOrNot2.default.get() ? "1200px" : '100%',
	                            height: _IsPcOrNot2.default.get() ? '480px' : '3rem',
	                            position: "relative",
	                            margin: '0 auto',
	                            overflow: 'hidden'
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'swiper-wrapper', style: { position: 'relative' } },
	                        this.news.map(function (item, key) {
	                            return _react2.default.createElement(
	                                'a',
	                                { key: key, className: 'swiper-slide', target: '_blank', href: item.link },
	                                _react2.default.createElement(
	                                    'div',
	                                    {
	                                        style: {
	                                            backgroundImage: 'url(' + item.img + '@q_90' + ')',
	                                            width: '100%',
	                                            height: '100%',
	                                            backgroundSize: 'contain',
	                                            backgroundPosition: 'center',
	                                            backgroundRepeat: 'no-repeat',
	                                            cursor: 'pointer',
	                                            position: 'relative'
	                                        } },
	                                    _react2.default.createElement(
	                                        'div',
	                                        { style: {
	                                                position: 'absolute',
	                                                width: '100%',
	                                                bottom: '0',
	                                                right: '0',
	                                                height: '.5rem',
	                                                fontSize: _IsPcOrNot2.default.get() ? "20px" : '.14rem',
	                                                textAlign: 'left',
	                                                zIndex: '9',
	                                                color: '#fff',
	                                                lineHeight: '.5rem',
	                                                boxShadow: _IsPcOrNot2.default.get() ? '0px 31px 40px rgba(0,0,0,0.8) inset' : '0px -12px 22px rgba(0,0,0,0.8) inset'
	                                            } },
	                                        _react2.default.createElement(
	                                            'div',
	                                            { style: {
	                                                    marginLeft: '20px'
	                                                } },
	                                            item.title
	                                        )
	                                    )
	                                )
	                            );
	                        })
	                    ),
	                    _react2.default.createElement('div', { className: 'swiper-pagination news-swiper-pagination', style: {
	                            position: "absolute",
	                            bottom: '0',
	                            right: '0',
	                            width: 'auto',
	                            zIndex: '9999',
	                            height: '.5rem',
	                            display: 'flex',
	                            alignItems: "center",
	                            justifyContent: 'flex-end',
	                            marginRight: '20px'
	                        } }),
	                    _IsPcOrNot2.default.get() ? _react2.default.createElement(
	                        'div',
	                        null,
	                        _react2.default.createElement('div', { className: 'swiper-button-next', style: { color: '#fff' } }),
	                        _react2.default.createElement('div', { className: 'swiper-button-prev', style: { color: '#fff' } })
	                    ) : null
	                )
	            );
	        }
	    }]);
	    return NewsArea;
	}(_react.Component);
	
	var News = function (_Component14) {
	    (0, _inherits3.default)(News, _Component14);
	
	    function News(props) {
	        (0, _classCallCheck3.default)(this, News);
	
	        var _this20 = (0, _possibleConstructorReturn3.default)(this, (News.__proto__ || (0, _getPrototypeOf2.default)(News)).call(this, props));
	
	        _this20.details = function () {
	            window.open(_this20.props.data.link);
	        };
	
	        return _this20;
	    }
	
	    (0, _createClass3.default)(News, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'news', style: {
	                        width: '100%',
	                        marginTop: '.5rem',
	                        height: _IsPcOrNot2.default.get() ? "160px" : "2rem"
	                    } },
	                _react2.default.createElement(
	                    'div',
	                    { style: { height: '100%' } },
	                    _react2.default.createElement('div', { style: {
	                            backgroundImage: "url(" + this.props.data.img + ")",
	                            backgroundColor: "#f7f7f7",
	                            backgroundRepeat: "no-repeat",
	                            backgroundSize: "cover",
	                            backgroundPosition: "center",
	                            width: _IsPcOrNot2.default.get() ? "240px" : "2rem",
	                            height: '100%',
	                            display: "inline-block",
	                            verticalAlign: "top",
	                            cursor: "pointer"
	                        },
	                        onClick: this.details
	                    }),
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                position: "relative",
	                                height: '100%',
	                                display: "inline-block",
	                                width: _IsPcOrNot2.default.get() ? "940px" : "4.88rem",
	                                paddingLeft: _IsPcOrNot2.default.get() ? "20px" : "0.3rem",
	                                verticalAlign: "top"
	                            } },
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    color: "#01007a",
	                                    display: "-webkit-box",
	                                    overflow: "hidden",
	                                    textOverflow: "ellipsis",
	                                    WebkitLineClamp: "2",
	                                    WebkitBoxOrient: "vertical",
	                                    cursor: "pointer",
	                                    fontSize: _IsPcOrNot2.default.get() ? "22px" : "0.3rem"
	                                },
	                                onClick: this.details
	                            },
	                            this.props.data.title
	                        ),
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    color: "#777",
	                                    lineHeight: _IsPcOrNot2.default.get() ? "22px" : ".32rem",
	                                    marginTop: _IsPcOrNot2.default.get() ? "20px" : ".2rem",
	                                    fontSize: _IsPcOrNot2.default.get() ? "16px" : "0.25rem",
	                                    display: "-webkit-box",
	                                    overflow: "hidden",
	                                    textOverflow: "ellipsis",
	                                    WebkitLineClamp: "2",
	                                    cursor: "pointer",
	                                    WebkitBoxOrient: "vertical"
	                                },
	                                onClick: this.details
	                            },
	                            this.props.data.desc
	                        ),
	                        _react2.default.createElement(
	                            'div',
	                            { style: {
	                                    width: "100%",
	                                    whiteSpace: "nowrap",
	                                    marginTop: _IsPcOrNot2.default.get() ? '' : '.1rem',
	                                    fontSize: _IsPcOrNot2.default.get() ? "14px" : "0.25rem"
	                                } },
	                            _react2.default.createElement(
	                                'div',
	                                { style: { display: "inline-block", width: "50%", textAlign: "left" } },
	                                _react2.default.createElement(_BaseComponent.FormattedMessage, {
	                                    id: 'from' }),
	                                this.props.data.from
	                            ),
	                            _react2.default.createElement(
	                                'div',
	                                { style: {
	                                        display: "inline-block",
	                                        width: "50%",
	                                        textAlign: "right"
	                                    } },
	                                this.props.data.time
	                            )
	                        )
	                    )
	                )
	            );
	        }
	    }]);
	    return News;
	}(_react.Component);
	
	var Title = function (_Component15) {
	    (0, _inherits3.default)(Title, _Component15);
	
	    function Title(props) {
	        (0, _classCallCheck3.default)(this, Title);
	        return (0, _possibleConstructorReturn3.default)(this, (Title.__proto__ || (0, _getPrototypeOf2.default)(Title)).call(this, props));
	    }
	
	    (0, _createClass3.default)(Title, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        padding: _IsPcOrNot2.default.get() ? '20px 0' : '0 .31rem',
	                        height: _IsPcOrNot2.default.get() ? 'auto' : '.8rem',
	                        marginBottom: _IsPcOrNot2.default.get() ? "" : ".2rem",
	                        marginTop: _IsPcOrNot2.default.get() ? '' : '.2rem',
	                        display: 'flex',
	                        alignItems: "center",
	                        overflow: 'hidden'
	
	                    } },
	                _react2.default.createElement('div', { style: {
	                        width: _IsPcOrNot2.default.get() ? "45px" : ".55rem",
	                        height: _IsPcOrNot2.default.get() ? "45px" : ".55rem",
	                        verticalAlign: "middle",
	                        marginRight: _IsPcOrNot2.default.get() ? "40px" : "10px",
	                        display: "inline-block",
	                        backgroundImage: _IsPcOrNot2.default.get() ? 'url(' + _pc_bottom_icon2.default + ')' : 'url(' + _m_bottom_icon2.default + ')',
	                        backgroundSize: 'contain',
	                        backgroundRepeat: 'no-repeat'
	                    } }),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            fontSize: _IsPcOrNot2.default.get() ? "30px" : "16px",
	                            color: "#07067d",
	                            verticalAlign: "middle",
	                            display: "inline-block",
	                            marginTop: _IsPcOrNot2.default.get() ? '' : '.2rem'
	                        } },
	                    _react2.default.createElement(_BaseComponent.FormattedMessage, { id: this.props.data })
	                )
	            );
	        }
	    }]);
	    return Title;
	}(_react.Component);
	
	//顶级合作伙伴
	
	
	var TopSponsor = function (_Component16) {
	    (0, _inherits3.default)(TopSponsor, _Component16);
	
	    function TopSponsor() {
	        var _ref;
	
	        var _temp, _this22, _ret;
	
	        (0, _classCallCheck3.default)(this, TopSponsor);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this22 = (0, _possibleConstructorReturn3.default)(this, (_ref = TopSponsor.__proto__ || (0, _getPrototypeOf2.default)(TopSponsor)).call.apply(_ref, [this].concat(args))), _this22), _this22.jump = function () {
	            window.open('https://www.intel.cn/content/www/cn/zh/business/overview.html');
	        }, _temp), (0, _possibleConstructorReturn3.default)(_this22, _ret);
	    }
	
	    (0, _createClass3.default)(TopSponsor, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        width: _IsPcOrNot2.default.get() ? '1200px' : 'auto',
	                        margin: '0 auto'
	                    } },
	                _react2.default.createElement(Title, { data: 'top_sponsor' }),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? "1200px" : "100%",
	                            padding: _IsPcOrNot2.default.get() ? '' : '0 .31rem',
	                            margin: _IsPcOrNot2.default.get() ? "0 auto" : "",
	                            position: "relative"
	                        } },
	                    _react2.default.createElement('div', { onClick: this.jump, className: _IsPcOrNot2.default.get() ? "banner" : "banner-wap",
	                        style: {
	                            backgroundImage: _IsPcOrNot2.default.get() ? 'url(' + _pc_intel2.default + ')' : "url(" + _m_intel2.default + ")",
	                            backgroundRepeat: 'no-repeat',
	                            backgroundSize: 'cover',
	                            cursor: 'pointer',
	                            height: _IsPcOrNot2.default.get() ? '148px' : '.85rem'
	                        } })
	                )
	            );
	        }
	    }]);
	    return TopSponsor;
	}(_react.Component);
	
	var PartnerCard = function (_Component17) {
	    (0, _inherits3.default)(PartnerCard, _Component17);
	
	    function PartnerCard() {
	        var _ref2;
	
	        var _temp2, _this23, _ret2;
	
	        (0, _classCallCheck3.default)(this, PartnerCard);
	
	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	        }
	
	        return _ret2 = (_temp2 = (_this23 = (0, _possibleConstructorReturn3.default)(this, (_ref2 = PartnerCard.__proto__ || (0, _getPrototypeOf2.default)(PartnerCard)).call.apply(_ref2, [this].concat(args))), _this23), _this23.go = function () {
	            window.open(_this23.props.url);
	        }, _temp2), (0, _possibleConstructorReturn3.default)(_this23, _ret2);
	    }
	
	    (0, _createClass3.default)(PartnerCard, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        display: "inline-block",
	                        width: _IsPcOrNot2.default.get() ? "360px" : "3.6rem",
	                        height: _IsPcOrNot2.default.get() ? "120px" : "1.2rem",
	                        cursor: "pointer"
	                    } },
	                _react2.default.createElement('div', { style: {
	                        backgroundImage: "url(" + this.props.img + ")",
	                        backgroundRepeat: "no-repeat",
	                        backgroundPosition: "center center",
	                        backgroundSize: "contain",
	                        width: "100%",
	                        height: "100%"
	                    }, onClick: this.go })
	            );
	        }
	    }]);
	    return PartnerCard;
	}(_react.Component);
	
	var Partner = function (_Component18) {
	    (0, _inherits3.default)(Partner, _Component18);
	
	    function Partner(props) {
	        (0, _classCallCheck3.default)(this, Partner);
	        return (0, _possibleConstructorReturn3.default)(this, (Partner.__proto__ || (0, _getPrototypeOf2.default)(Partner)).call(this, props));
	    }
	
	    (0, _createClass3.default)(Partner, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? "1200px" : "100%",
	                            margin: _IsPcOrNot2.default.get() ? "0 auto" : ""
	                        } },
	                    _react2.default.createElement(Title, { data: 'partner_2019' }),
	                    _react2.default.createElement(
	                        'div',
	                        null,
	                        _react2.default.createElement(PartnerCard, { url: _IsPcOrNot2.default.get() ? "http://www.inspur.com" : "http://wap.inspur.com/", img: _langchao2.default }),
	                        _react2.default.createElement(PartnerCard, { url: 'http://www.wedz.com.cn', img: _wuhan2.default })
	                    )
	                )
	            );
	        }
	    }]);
	    return Partner;
	}(_react.Component);
	
	var Media = function (_Component19) {
	    (0, _inherits3.default)(Media, _Component19);
	
	    function Media(props) {
	        (0, _classCallCheck3.default)(this, Media);
	        return (0, _possibleConstructorReturn3.default)(this, (Media.__proto__ || (0, _getPrototypeOf2.default)(Media)).call(this, props));
	    }
	
	    (0, _createClass3.default)(Media, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: { width: _IsPcOrNot2.default.get() ? '1200px' : '100%', margin: '0 auto', paddingBottom: "50px" } },
	                _react2.default.createElement(Title, { data: 'media' }),
	                _react2.default.createElement('div', { style: {
	                        width: _IsPcOrNot2.default.get() ? '1002px' : '6.79rem',
	                        height: _IsPcOrNot2.default.get() ? '562px' : '15.48rem',
	                        background: _IsPcOrNot2.default.get() ? 'url(' + _pc_media2.default + ') no-repeat center center' : 'url(' + _media_bg2.default + ') no-repeat center center',
	                        backgroundSize: 'contain',
	                        backgroundRepeat: 'no-repeat',
	                        margin: '0 auto'
	                    } })
	            );
	        }
	    }]);
	    return Media;
	}(_react.Component);
	
	//往期回顾
	
	
	var PastReview = function (_Component20) {
	    (0, _inherits3.default)(PastReview, _Component20);
	
	    function PastReview(props) {
	        (0, _classCallCheck3.default)(this, PastReview);
	
	        var _this26 = (0, _possibleConstructorReturn3.default)(this, (PastReview.__proto__ || (0, _getPrototypeOf2.default)(PastReview)).call(this, props));
	
	        _this26.pastList = [{ pic: _previous_2.default, href: 'http://create2017.baidu.com/' }, { pic: _previous_4.default, href: 'http://create2018.baidu.com/' }];
	        return _this26;
	    }
	
	    (0, _createClass3.default)(PastReview, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }, {
	        key: 'goOldCreate',
	        value: function goOldCreate(href) {
	            window.open(href);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this27 = this;
	
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        position: 'relative'
	                    } },
	                _IsPcOrNot2.default.get() ? _react2.default.createElement('img', { src: _pc_history2.default, style: { width: '100%' }, alt: '' }) : _react2.default.createElement('div', { style: {
	                        width: "100%",
	                        height: '.9rem',
	                        marginTop: '.6rem',
	                        background: 'url(' + _m_history2.default + ') no-repeat center center',
	                        backgroundSize: 'cover'
	                    } }),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            width: _IsPcOrNot2.default.get() ? '950px' : '6.5rem',
	                            height: _IsPcOrNot2.default.get() ? '480px' : '4rem',
	                            display: 'flex',
	                            alignItems: 'center',
	                            justifyContent: 'space-between',
	                            margin: '0 auto'
	                        } },
	                    this.pastList.map(function (item, key) {
	                        return _react2.default.createElement('div', { key: key, onClick: _this27.goOldCreate.bind(_this27, item.href), style: {
	                                width: _IsPcOrNot2.default.get() ? '450px' : '3rem',
	                                height: _IsPcOrNot2.default.get() ? '450px' : '3rem',
	                                background: 'url(' + item.pic + ') no-repeat center center',
	                                backgroundSize: 'contain',
	                                cursor: 'pointer'
	                            } });
	                    })
	                )
	            );
	        }
	    }]);
	    return PastReview;
	}(_react.Component);
	
	var ActivityArea = function (_Component21) {
	    (0, _inherits3.default)(ActivityArea, _Component21);
	
	    function ActivityArea(props) {
	        (0, _classCallCheck3.default)(this, ActivityArea);
	
	        var _this28 = (0, _possibleConstructorReturn3.default)(this, (ActivityArea.__proto__ || (0, _getPrototypeOf2.default)(ActivityArea)).call(this, props));
	
	        _this28.webList = [_web2.default, _web18.default, _web4.default, _web16.default, _web6.default, _web14.default, _web12.default, _web10.default, _web8.default];
	        _this28.pcList = [_lunbo2.default, _lunbo4.default, _lunbo18.default, _lunbo6.default, _lunbo16.default, _lunbo14.default, _lunbo8.default, _lunbo12.default, _lunbo10.default];
	        return _this28;
	    }
	
	    (0, _createClass3.default)(ActivityArea, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.setState({
	                webList: this.webList
	            });
	            var activitySwiper = new _swiper2.default('.activity-swiper-container', {
	                slidesPerView: 1,
	                spaceBetween: 0,
	                loop: true,
	                pagination: {
	                    el: '.swiper-pagination',
	                    clickable: true
	                },
	                navigation: {
	                    nextEl: '.swiper-button-next',
	                    prevEl: '.swiper-button-prev'
	                },
	                autoplay: {
	                    disableOnInteraction: false
	                },
	                noSwiping: true,
	                observer: true,
	                observeParents: true
	            });
	            (0, _nZepto2.default)('.swiper-slide').mouseenter(function () {
	                activitySwiper.autoplay.stop();
	            });
	            (0, _nZepto2.default)('.swiper-slide').mouseleave(function () {
	                activitySwiper.autoplay.start();
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: {
	                        width: _IsPcOrNot2.default.get() ? '1200px' : '100%',
	                        margin: '0 auto'
	                    } },
	                _react2.default.createElement(Title, { data: 'xcTitle' }),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'activity-swiper-container', ref: 'swiperContainer', style: {
	                            width: _IsPcOrNot2.default.get() ? "1200px" : '100%',
	                            height: _IsPcOrNot2.default.get() ? '675px' : '4.21rem',
	                            position: "relative",
	                            overflow: 'hidden'
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'swiper-wrapper' },
	                        _IsPcOrNot2.default.get() ? this.pcList.map(function (item, key) {
	                            return _react2.default.createElement('div', { key: key, className: 'swiper-slide', style: {
	                                    backgroundImage: 'url(' + item + ')',
	                                    width: '100%',
	                                    height: '100%',
	                                    backgroundSize: 'cover',
	                                    backgroundPosition: 'center',
	                                    backgroundRepeat: 'no-repeat'
	                                } });
	                        }) : this.webList.map(function (item, key) {
	                            return _react2.default.createElement('div', { key: key, className: 'swiper-slide', style: {
	                                    backgroundImage: 'url(' + item + ')',
	                                    width: '100%',
	                                    height: '100%',
	                                    backgroundSize: 'cover',
	                                    backgroundPosition: 'center',
	                                    backgroundRepeat: 'no-repeat'
	                                } });
	                        })
	                    ),
	                    _react2.default.createElement('div', { className: 'swiper-pagination' }),
	                    _IsPcOrNot2.default.get() ? _react2.default.createElement(
	                        'div',
	                        null,
	                        _react2.default.createElement('div', { className: 'swiper-button-next ', style: { color: '#fff' } }),
	                        _react2.default.createElement('div', { className: 'swiper-button-prev', style: { color: '#fff' } })
	                    ) : null
	                )
	            );
	        }
	    }]);
	    return ActivityArea;
	}(_react.Component);
	
	var TerminalC = function (_Component22) {
	    (0, _inherits3.default)(TerminalC, _Component22);
	
	    function TerminalC(props) {
	        (0, _classCallCheck3.default)(this, TerminalC);
	
	        var _this29 = (0, _possibleConstructorReturn3.default)(this, (TerminalC.__proto__ || (0, _getPrototypeOf2.default)(TerminalC)).call(this, props));
	
	        _this29.showTerminalBox = function (event) {
	            _this29.showTerminal = !_this29.showTerminal;
	            _this29.setState({
	                showTerminal: _this29.showTerminal
	            });
	        };
	
	        _this29.goTerminal = function () {
	            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + '/terminal');
	        };
	
	        _this29.showTerminal = false;
	        return _this29;
	    }
	
	    (0, _createClass3.default)(TerminalC, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var element = this.refs.terminalBox;
	            var create = _lottieWeb2.default.loadAnimation({
	                container: element, // the dom element that will contain the animation
	                renderer: 'svg',
	                loop: true,
	                autoplay: true,
	                path: '/json/c.json' });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _IsPcOrNot2.default.get() ? _react2.default.createElement('div', { ref: 'terminalBox', className: 'terminal-box', onClick: this.showTerminalBox, style: {
	                    width: '130px',
	                    height: '130px',
	                    backgroundSize: 'cover',
	                    position: 'absolute',
	                    bottom: '0px',
	                    right: '0',
	                    zIndex: '999',
	                    cursor: 'pointer'
	                } }) : _react2.default.createElement('div', { ref: 'terminalBox', onClick: this.goTerminal, style: {
	                    width: '1.4rem',
	                    height: '1.4rem',
	                    backgroundSize: 'cover',
	                    borderRadius: '50%',
	                    position: 'fixed',
	                    right: '.3rem',
	                    bottom: '8%',
	                    zIndex: '99'
	                } });
	        }
	    }]);
	    return TerminalC;
	}(_react.Component);
	
	var PC = function (_Component23) {
	    (0, _inherits3.default)(PC, _Component23);
	
	    function PC(props) {
	        (0, _classCallCheck3.default)(this, PC);
	
	        var _this30 = (0, _possibleConstructorReturn3.default)(this, (PC.__proto__ || (0, _getPrototypeOf2.default)(PC)).call(this, props));
	
	        _this30.speakersList = [];
	        return _this30;
	    }
	
	    (0, _createClass3.default)(PC, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this31 = this;
	
	            _nZepto2.default.get('/json/speakers.json' + "?timestamp=" + new Date().getTime(), function (data) {
	                _this31.speakersList = data;
	                _this31.setState({
	                    speakersList: _this31.speakersList
	                });
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: { backgroundColor: "#fff" } },
	                _react2.default.createElement(_Header2.default, null),
	                _react2.default.createElement(Banner, null),
	                _react2.default.createElement(BuyTicketsArea, null),
	                _react2.default.createElement(OrderArea, null),
	                _react2.default.createElement(MeetingDesc, null),
	                _react2.default.createElement(Program, { data: this.props.agendaPlan }),
	                _react2.default.createElement(SubForums, { data: this.props.subForums }),
	                _react2.default.createElement(OpenClass, { data: this.props.subForums }),
	                _react2.default.createElement(Guests, { data: this.speakersList }),
	                _react2.default.createElement(Scientist, { data: this.speakersList }),
	                _react2.default.createElement(NewsArea, null),
	                _react2.default.createElement(PastReview, null),
	                _react2.default.createElement(ActivityArea, null),
	                _react2.default.createElement(TopSponsor, null),
	                _react2.default.createElement(Partner, null),
	                _react2.default.createElement(Media, null),
	                _react2.default.createElement(_Footer2.default, null)
	            );
	        }
	    }]);
	    return PC;
	}(_react.Component);
	
	var Phone = function (_Component24) {
	    (0, _inherits3.default)(Phone, _Component24);
	
	    function Phone(props) {
	        (0, _classCallCheck3.default)(this, Phone);
	
	        var _this32 = (0, _possibleConstructorReturn3.default)(this, (Phone.__proto__ || (0, _getPrototypeOf2.default)(Phone)).call(this, props));
	
	        _this32.agendaPlan = _zh2.default.agendaPlanData;
	        _this32.subForums = [];
	        _this32.speakersList = [];
	        return _this32;
	    }
	
	    (0, _createClass3.default)(Phone, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this33 = this;
	
	            _nZepto2.default.get('/json/speakers.json' + "?timestamp=" + new Date().getTime(), function (data) {
	                _this33.speakersList = data;
	                _this33.setState({
	                    speakersList: _this33.speakersList
	                });
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: { backgroundColor: "#fff" } },
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            position: 'fixed',
	                            top: 0,
	                            left: 0,
	                            right: 0,
	                            zIndex: '999'
	                        } },
	                    _react2.default.createElement(_Header2.default, null)
	                ),
	                _react2.default.createElement(TerminalC, null),
	                _react2.default.createElement(Banner, null),
	                _react2.default.createElement(BuyTicketsArea, null),
	                _react2.default.createElement(OrderArea, null),
	                _react2.default.createElement(PhoneMeeting, null),
	                _react2.default.createElement(Program, { data: this.props.agendaPlan }),
	                _react2.default.createElement(SubForums, { data: this.props.subForums }),
	                _react2.default.createElement(OpenClass, { data: this.props.subForums }),
	                _react2.default.createElement(Guests, { data: this.speakersList }),
	                _react2.default.createElement(Scientist, { data: this.speakersList }),
	                _react2.default.createElement(NewsArea, null),
	                _react2.default.createElement(PastReview, null),
	                _react2.default.createElement(ActivityArea, null),
	                _react2.default.createElement(TopSponsor, null),
	                _react2.default.createElement(Partner, null),
	                _react2.default.createElement(Media, null),
	                _react2.default.createElement(_Footer2.default, null)
	            );
	        }
	    }]);
	    return Phone;
	}(_react.Component);
	
	var IndexPage = exports.IndexPage = function (_Component25) {
	    (0, _inherits3.default)(IndexPage, _Component25);
	
	    function IndexPage(props) {
	        (0, _classCallCheck3.default)(this, IndexPage);
	
	        var _this34 = (0, _possibleConstructorReturn3.default)(this, (IndexPage.__proto__ || (0, _getPrototypeOf2.default)(IndexPage)).call(this, props));
	
	        _this34.login = function () {
	            _IsPcOrNot2.default.get() ? window.instance.show() : window.instance.render((0, _nZepto2.default)("#login")[0]);
	        };
	
	        _this34.agendaPlan = localStorage['language'] == 'en' ? _en2.default.agendaPlanData : _zh2.default.agendaPlanData;
	        _this34.subForums = [];
	        return _this34;
	    }
	
	    (0, _createClass3.default)(IndexPage, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this35 = this;
	
	            _nZepto2.default.get('/json/agenda.json' + "?timestamp=" + new Date().getTime(), function (data) {
	                _this35.subForums = data.slice(1);
	                _this35.setState({
	                    subForums: _this35.subForums
	                });
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _IsPcOrNot2.default.get() ? _react2.default.createElement(PC, { agendaPlan: this.agendaPlan, subForums: this.subForums }) : _react2.default.createElement(Phone, { agendaPlan: this.agendaPlan, subForums: this.subForums })
	            );
	        }
	    }]);
	    return IndexPage;
	}(_react.Component);
	
	exports.default = IndexPage;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(405);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(379)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(405, function() {
				var newContent = __webpack_require__(405);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(378)();
	// imports
	
	
	// module
	exports.push([module.id, ".news-title{height:220px}.news-title,.wap-news-title{background-size:auto 100%;background-position:0 0;background-repeat:no-repeat}.wap-news-title{height:1.8rem}.meeting_c{position:absolute;width:50%;background-size:auto 100%;background-position:0 0;background-repeat:no-repeat;left:0;top:0;height:100%}.meeting_c .meeting{width:100%;position:absolute;top:397px;left:167px;z-index:100}.meeting_c .meeting .meeting_desc_title{font-size:42px;font-weight:600;text-align:right}.meeting_c .meeting .meeting_desc_title_en{font-size:33px;text-align:right;font-weight:600}.meeting_c .meeting .meeting_desc_text{margin-top:10px;text-align:justify;font-size:19px;font-weight:400;line-height:27px}.meeting_c .meeting .meeting_desc_text_en{margin-top:10px;text-align:justify;font-size:18px;line-height:24px}.wap-meeting_c{position:absolute;width:.3rem;background-size:100% auto;background-position:0 0;background-repeat:no-repeat;left:0;top:0;height:100%}.wap-meeting_c .meeting{width:.6rem;position:absolute;top:.13rem;left:.35rem}.wap-meeting_c .meeting .meeting_desc_title{font-size:.05rem;font-weight:600}.wap-meeting_c .meeting .meeting_desc_text{margin-top:.03rem;font-size:.03rem;text-align:justify;line-height:.05rem}.wap-meeting_c .meeting .meeting_desc_title_en{font-size:.05rem;font-weight:600}.wap-meeting_c .meeting .meeting_desc_text_en{margin-top:.03rem;font-size:.03rem;text-align:justify;line-height:.05rem}.meeting_right_addon{top:0;width:50%;z-index:5}.meeting_right_addon,.meeting_right_video{background-size:auto 100%;background-position:0 0;background-repeat:no-repeat;position:absolute;left:50%;height:100%}.meeting_right_video{right:0;width:700px;z-index:7}@keyframes blink{0%{opacity:0}to{opacity:1}}.i_blink{animation:terminal-blink 1s infinite step-start}@keyframes terminal-blink{0%,to{background-color:#000;color:#000}50%{background-color:#bbb;color:#000}}.actor__content{-ms-flex-positive:1;flex-grow:1}.actor__content--typing:after{content:\"|\";animation:blink .5s infinite}.program-title{margin-bottom:30px;height:180px}.program-title,.wap-program-title{background-size:auto 100%;background-position:100% 0;background-repeat:no-repeat;width:100%}.wap-program-title{height:.27rem}.main-right-c{position:absolute;right:0;width:500px;height:100%;background-size:auto 100%;background-position:100% 0;background-repeat:no-repeat}.guest-title{margin-bottom:60px;height:220px}.guest-title,.wap-guest-title{background-size:auto 100%;background-position:0 0;background-repeat:no-repeat;width:100%}.wap-guest-title{height:2.03rem}.agend1{margin-bottom:60px}.agend1,.agend2{background-size:100% auto;background-position:0 0;background-repeat:no-repeat;width:100%;height:263px}.agend2{margin-bottom:20px}.agend3{background-size:100% auto;background-position:0 0;background-repeat:no-repeat;width:100%;height:263px;margin-bottom:150px}.guestCard{margin-left:100px;margin-bottom:40px}.guestCard:first-child{margin-left:0}.WapguestCard{margin-left:.04rem;margin-bottom:.03rem}.WapguestCard:first-child{margin-left:0}.banner{height:440px}.banner,.banner-wap{background-size:100% auto;background-position:0 0;background-repeat:no-repeat;width:100%}.banner-wap{height:.3rem}.wap-guest_c{position:absolute;width:.3rem;background-size:100% auto;background-position:0 0;background-repeat:no-repeat;right:0;top:-.32rem;height:100%}.live{height:306px}.live,.wap-live{border:0;width:100%}.swiper-pagination span{background:#fff;margin:0 .1rem}.news-swiper-pagination span{display:block}", "", {"version":3,"sources":["/Users/baidu/Desktop/project/ai-web-2019/src/routes/IndexPage/components/src/routes/IndexPage/components/IndexPage.scss"],"names":[],"mappings":"AACA,YAIE,YAAY,CACb,4BAJC,0BAAyB,wBACG,2BACD,CAG7B,gBAIE,aAAa,CACd,WAEC,kBAAiB,UACR,0BAEgB,wBACG,4BACD,OACrB,MACD,WACM,CATb,oBAWI,WAAU,kBACO,UACR,WACC,WACC,CAff,wCAiBM,eAAc,gBACC,gBACC,CAnBtB,2CAsBM,eAAc,iBACE,eACD,CAxBrB,uCA2BM,gBAAe,mBACI,eACL,gBACC,gBACE,CA/BvB,0CAkCM,gBAAe,mBACI,eACL,gBACG,CAClB,eAKH,kBAAiB,YACL,0BACa,wBACG,4BACD,OACrB,MACD,WACM,CARb,wBAUI,YAAY,kBACK,WACN,WACC,CAbhB,4CAeM,iBAAiB,eACF,CAhBrB,2CAmBM,kBAAkB,iBACD,mBACE,kBACC,CAtB1B,+CAyBM,iBAAiB,eACF,CA1BrB,8CA6BM,kBAAkB,iBACD,mBACE,kBACC,CACrB,qBAUH,MAAK,UAEI,SACA,CAEV,0CAVC,0BAAyB,wBACG,4BACD,kBACV,SACT,WAEG,CAMb,qBAKE,QAAO,YAGI,SACF,CAEV,iBAEC,GAAO,SAAU,CAAA,GACZ,SAAU,CAAA,CAAA,SAGf,+CAAqD,CACtD,0BAEC,MACE,sBAAsB,UACX,CAAA,IAGX,sBAAsB,UACX,CAAA,CAAA,gBAIb,oBAAA,WAAY,CACb,8BAEC,YAAY,4BACmB,CAChC,eAOC,mBAAkB,YACN,CACb,kCANC,0BAAyB,2BACI,4BACF,UACjB,CAIZ,mBAKE,aAAc,CAEf,cAEC,kBAAiB,QACV,YACI,YACA,0BACc,2BACI,2BACF,CAC5B,aAMC,mBAAkB,YACN,CACb,8BANC,0BAAyB,wBACG,4BACD,UACjB,CAIZ,iBAKE,cAAc,CAEf,QAOC,kBAAkB,CACnB,gBANC,0BAAyB,wBACG,4BACD,WACjB,YACE,CAGd,QAME,kBAAkB,CACnB,QAEC,0BAAyB,wBACG,4BACD,WACjB,aACE,mBACO,CACpB,WAEC,kBAAiB,kBACC,CAFpB,uBAII,aAAa,CAEd,cAGD,mBAAmB,oBACE,CAFvB,0BAII,aAAa,CAEd,QAOD,YAAY,CACb,oBALC,0BAAyB,wBACG,4BACD,UACjB,CAGZ,YAKE,YAAa,CACd,aAEC,kBAAiB,YACL,0BACa,wBACG,4BACD,QACpB,YAEK,WAED,CAEZ,MAMC,YAAY,CACb,gBAHC,SAAQ,UACE,CAMX,wBAGG,gBAAe,cACD,CACf,6BAIC,aAAc,CACf","file":"IndexPage.scss","sourcesContent":["\n.news-title {\n  background-size:auto 100%;\n  background-position:left top;\n  background-repeat:no-repeat;\n  height:220px;\n}\n.wap-news-title {\n  background-size:auto 100%;\n  background-position:left top;\n  background-repeat:no-repeat;\n  height:1.8rem;\n}\n.meeting_c {\n  position:absolute;\n  width:50%;\n\n  background-size:auto 100%;\n  background-position:left top;\n  background-repeat:no-repeat;\n  left:0;\n  top:0;\n  height:100%;\n  .meeting {\n    width:100%;\n    position:absolute;\n    top:397px;\n    left:167px;\n    z-index:100;\n    .meeting_desc_title {\n      font-size:42px;\n      font-weight:600;\n      text-align:right;\n    }\n    .meeting_desc_title_en {\n      font-size:33px;\n      text-align:right;\n      font-weight:600;\n    }\n    .meeting_desc_text {\n      margin-top:10px;\n      text-align: justify;\n      font-size:19px;\n      font-weight:400;\n      line-height: 27px;\n    }\n    .meeting_desc_text_en {\n      margin-top:10px;\n      text-align: justify;\n      font-size:18px;\n      line-height: 24px;\n    }\n  }\n\n}\n.wap-meeting_c {\n  position:absolute;\n  width:0.3rem;\n  background-size:100% auto;\n  background-position:left top;\n  background-repeat:no-repeat;\n  left:0;\n  top:0;\n  height:100%;\n  .meeting {\n    width:0.6rem;\n    position:absolute;\n    top:0.13rem;\n    left:0.35rem;\n    .meeting_desc_title {\n      font-size:0.05rem;\n      font-weight:600;\n    }\n    .meeting_desc_text {\n      margin-top:0.03rem;\n      font-size:0.03rem;\n      text-align: justify;\n      line-height: 0.05rem;\n    }\n    .meeting_desc_title_en {\n      font-size:0.05rem;\n      font-weight:600;\n    }\n    .meeting_desc_text_en {\n      margin-top:0.03rem;\n      font-size:0.03rem;\n      text-align: justify;\n      line-height: 0.05rem;\n    }\n  }\n\n}\n.meeting_right_addon {\n  background-size:auto 100%;\n  background-position:top left;\n  background-repeat:no-repeat;\n  position:absolute;\n  left:50%;\n  top:0;\n  height:100%;\n  width:50%;\n  z-index:5;\n\n}\n\n.meeting_right_video {\n  background-size:auto 100%;\n  background-position:top left;\n  background-repeat:no-repeat;\n  position:absolute;\n  right:0;\n  left:50%;\n  height:100%;\n  width:700px;\n  z-index:7;\n\n}\n@keyframes blink {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n.i_blink {\n  animation: terminal-blink 1s infinite steps(1, start);\n}\n@keyframes terminal-blink {\n  0%, 100% {\n    background-color: #000;\n    color: #000;\n  }\n  50% {\n    background-color: #bbb;\n    color: #000;\n  }\n}\n.actor__content {\n  flex-grow: 1;\n}\n.actor__content--typing::after {\n  content: '|';\n  animation: blink 500ms infinite;\n}\n\n.program-title {\n  background-size:auto 100%;\n  background-position:top right;\n  background-repeat:no-repeat;\n  width:100%;\n  margin-bottom:30px;\n  height:180px;\n}\n.wap-program-title {\n  background-size:auto 100%;\n  background-position:top right;\n  background-repeat:no-repeat;\n  width:100%;\n  height:0.27rem;\n\n}\n.main-right-c {\n  position:absolute;\n  right:0;\n  width:500px;\n  height:100%;\n  background-size:auto 100%;\n  background-position:top right;\n  background-repeat:no-repeat;\n}\n.guest-title {\n  background-size:auto 100%;\n  background-position:top left;\n  background-repeat:no-repeat;\n  width:100%;\n  margin-bottom:60px;\n  height:220px;\n}\n.wap-guest-title {\n  background-size:auto 100%;\n  background-position:top left;\n  background-repeat:no-repeat;\n  width:100%;\n  height:2.03rem;\n\n}\n.agend1 {\n  background-size:100% auto;\n  background-position:top left;\n  background-repeat:no-repeat;\n  width:100%;\n  height:263px;\n  margin-bottom:60px;\n}\n.agend2 {\n  background-size:100% auto;\n  background-position:top left;\n  background-repeat:no-repeat;\n  width:100%;\n  height:263px;\n  margin-bottom:20px;\n}\n.agend3 {\n  background-size:100% auto;\n  background-position:top left;\n  background-repeat:no-repeat;\n  width:100%;\n  height:263px;\n  margin-bottom:150px;\n}\n.guestCard {\n  margin-left:100px;\n  margin-bottom:40px;\n  &:first-child {\n    margin-left:0;\n\n  }\n}\n.WapguestCard {\n  margin-left:0.04rem;\n  margin-bottom:0.03rem;\n  &:first-child {\n    margin-left:0;\n\n  }\n}\n.banner {\n  background-size:100% auto;\n  background-position:top left;\n  background-repeat:no-repeat;\n  width:100%;\n  height:440px;\n}\n.banner-wap {\n  background-size:100% auto;\n  background-position:top left;\n  background-repeat:no-repeat;\n  width:100%;\n  height:0.3rem;\n}\n.wap-guest_c {\n  position:absolute;\n  width:0.3rem;\n  background-size:100% auto;\n  background-position:left top;\n  background-repeat:no-repeat;\n  right:0;\n\n  top:-0.32rem;\n\n  height:100%;\n\n}\n.partner-title {\n}\n.live {\n  border:0;\n  width:100%;\n  height:306px;\n}\n.wap-live {\n  border:0;\n  width:100%;\n}\n.swiper-pagination{\n  span{\n    background:#fff;\n    margin:0 .1rem;\n  }\n}\n.news-swiper-pagination{\n  span{\n    display: block;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"sourceRoot":""}]);
	
	// exports


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getPrototypeOf = __webpack_require__(304);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(309);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(310);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(314);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(348);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(24);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Footer = function (_Component) {
	    (0, _inherits3.default)(Footer, _Component);
	
	    function Footer() {
	        (0, _classCallCheck3.default)(this, Footer);
	        return (0, _possibleConstructorReturn3.default)(this, (Footer.__proto__ || (0, _getPrototypeOf2.default)(Footer)).apply(this, arguments));
	    }
	
	    (0, _createClass3.default)(Footer, [{
	        key: "render",
	        value: function render() {
	            return _react2.default.createElement(
	                "div",
	                { style: { backgroundColor: "#000", fontSize: "12px", color: "#fff", padding: "25px 0", textAlign: "center" } },
	                _react2.default.createElement(
	                    "span",
	                    { "data-v-ba5e338c": "" },
	                    localStorage['language'] == 'en' ? 'customer service' : '客服邮箱',
	                    ":",
	                    _react2.default.createElement(
	                        "a",
	                        { href: "mailto:create_help@baidu.com", style: { color: '#fff' } },
	                        "create_help@baidu.com"
	                    )
	                ),
	                _react2.default.createElement(
	                    "div",
	                    { style: { marginTop: "8px" } },
	                    "Copyright \xA92019 Baidu, Inc. All Rights Reserved."
	                )
	            );
	        }
	    }]);
	    return Footer;
	}(_react.Component);
	
	exports.default = Footer;

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9c924d2c29d89f7cfc5a8d34ba9164da.png";

/***/ }),
/* 408 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAB4CAYAAADfRGj6AAAfqElEQVR4nO3dZ4AUVbYH8H9Vx+mewOScmCHNoOQkCAoIPlHEsOZdw1tdA+qK7lv1Bd111V1dXRXDM+C6giuKvkVFCSIiURYkp8mBGWZ6cugcqt6HtpuuTnUHBreYOb9PMN1dXd1dderWuefey4miKIIQQoji8P/qHSCEEBIeBWhCCFEoCtCEEKJQFKAJIUShKEATQohCUYAmhBCFogBNCCEKRQGaEEIUigI0IYQoFAVoQghRKArQhBCiUBSgCSFEoShAE0KIQlGAJoQQhaIATQghCkUBmhBCFIoCNCGEKBQFaEIIUSgK0IQQolAUoAkhRKEoQBNCiEJRgCaEEIWiAE0IIQpFAZoQQhSKAjQhhCgUBWhCCFEoCtCEEKJQFKAJIUShKEATQohCUYAmhBCFogBNCCEKRQGaEEIUigI0IYQoFAVoQghRKArQhBCiUBSgCSFEoShAE0KIQlGAJoQQhaIATQghCkUBmhBCFIoCNCGEKBQFaEIIUSgK0IQQolAUoAkhRKEoQBNCiEKp/9U7QAhh8/URE+o7rPj5tHxo1afftjre1Ivn15UBADhwAABBFDF/dDqun5zLvJ0uqwuvbarEleOyMTo7nvl1vXY3nvzsKLqsTgBAapwOT15ZAr1G1YdPMTgMqgBtc3ogRnlcFEWoVTx0AQe/0y3A5RHAcVy/7YeK5yTvcSbcgginW+iXbfmIogitmodGdWofXR4BTnf/fg8+eg0PnnG7gijC7or+eUVRhE6jgpqX36bDLcAt8/tyAPQaFfry0eWOtWCi6H22URf5lDxysgcPfXgAb3xbjQfnFuOmqXlQhfmMbkGEw+UJ+5k4AMeaevDu1tqQx3iOw8KxWSH7bdCGD5yCKOK5teV4Zs1x3D6jAIvnFGNkZlyYzwY43B4Iovf9TT12vLm5GhaHGwCQHKvFfbOLkBKrgwiA57zft0cQYXN5oh4bWjXP9DufqzjRd2QMcA2dNlz64la4PCIi/ZxuQcQvZxbg0ctG+v92x7t7sKW8rd8OAkEUYdCqMDQ1FhcUJ+PGKbnITozp0zYON/Zg7aEm7K/vRnWrGR0WV8TPdDo8goj/WTgKP78gH4D3e7nu9e9xqKE7bEA4E4IoIjNBjzF5Q7BoXBZmj0qL+vyvj5hw34p9UU9ajyDiLzeOweVjMmXf//Zle7C1IvLvK4giRmTE4ZP7pkW9qNpdHmw+3or1h0041tSDEx02uIXIx1q41z88fzjun1sc8TlvfFuFe5fv8/9/+rBkPHrZyJDP+fHuBjz+6eGwn4njALPdjYZOW8hjiUYtMuL1EIJCwvCMWNxzcRH+7bwMyd87LU6MeWIjTnRYAQAJMRrcc3ERHpo3DGnxOv/zuqwuXPv6TtS3W8FzHNyCiLo2C9yC9300Kh75yQaoeA6CKGJYeiy+/PUMfHWwGfd/sE/SUAgkiCKSY7W4bXoBfnXR0Ijf27ls0LSgjzT24Ehjj+zz4vQa/78dbgG7qjtQ1WLu9/05cKIb/9jbiJe/rsBz152PG6fI31pWt1rwxOoj+Hh3Q7+3moPFx5z6HiwON74+YoL5xxZPf6swmbGlvA1LN1bilml5eOH6MZITPND+E12oMMn/HgkB+x9Jj82FrRVtsr9verw+anBevqMOz60tw2GG4yuSjAQ9rp6Q3afXbK9oxxUvb8c1E7Lxh6tH+1uvHRbnaR2znRYnOi3OkL+XNfdi/WETvn5kJmYOT4n4+m6bC3/86jhW7WnAE5ILvIDDDT0w9djDvs7lEVAZsL++Y7vD4kR1qyXqPleYgO+rOpCRoMeV47JkP+O5ZtAE6LLmXqbnjcw4dYtm6rZHPKj6S0OnDTe9uQsdFifum10U8XnrDjXj7vf3oq7delb3B/C2aEoDcoo1rRbYXZ6z/r4AsGJnPcqbzVi3ZAYSjdqQx1mCc3yMBsPSY2Wf12Fx4mRXaEsy2JjchLB/P9llwz3v78Pn+0/KbkPO7xeVyt5JOSJclD/9oRGby1rx7DXn4c5ZhVBFuLvQa1TQqXnZNF+vPfRC7HQLWLalRhKgRSDsRbuqxYxfvLMbq/Y04K1bJ8CgVSEtXger0w2O4yAIIixON3wNdZ7jYNSpwHEcRFFEapz34mzUqZASe+pCLYii/67E6RFgc546JtceaqYAfS6rZGhRxOnVkpPE1ONAuzm0RXE2PLzyACYXJmFSYWLIY18dbMb1b3x/1lqwwTIS9EiP1/v/X24y+29Hfwr/rOnAbz4+hHdunxDyGEuAzkmMQUpc+BZ4oIZOm+QkjyRcXrWx04YFL23DgRPdsq+XM2NYCu64sED2eXNGpWFeaTo2HDGFPNZudmLZ1hrcOasw4usfWzACt00viPhbcpw3X/zi+nK8/m0VgpOfHUGt61idGg/OLcbLGyvDtry/2N+E72d0YNH4LKxbMgMujwieA5q7Hbj85W1o6XEAALITY/DFg9ORZNTA5RH9HaAzhqXg08XT4MvU6DUqJBm1UPMcVu87iQf/vt//Xg6Zfolz1aAJ0Cy3fMmxOuQlG/r0mv7icAv4wxfH8NkDF0j+Xtlixq3v7P7JgjMA5CXHwKg71TFUYWK7++hP722vxf1ziyWtV5vTg0qGAD0sPZapz4Al5QUAIzKkAdojiLjzvR/6JTireA7PXjuaKbd/Xk4C1j98Ib4+YsLz68rxdVCgjonQmeeTl2yQHN+RPHLpcLy3vc7fiecTnPfXqnk8cWUJfnXRULywvhzLttaGBGrxx/Z61pBTDR+Nipe08tU8h9ykGCQF3TFtOtaCO9/7wf//K8Zm4YO7JgNAyN0GP0ALhgdFgLa7PDjeJB9k8pJiJD3WrDnF+BgNNCoupMXBcYDLI6LH5mLazqZjLWjstEkOvkdXHUKb2cH0eqNODb2GD9mPvhABjM9PlJyMLN8DxwGJhtCURPBzWO9IPIKI1XsbJQG6tt2CTqv8d1mUJp/eANha47E6NXKTpEHtb9vrsPZQM9N7qHgOQwyasL+JCOC6STmYMSxyXjfQP/Y2osJkxpL5w3FJaTq+PNiEJ1YfxQ+1nUyvP9TQg13VHXB5wrc2BREYkRHLXH3SaXHiqS+O4eoJ2Xj+uvPx0LxheOrzY1i2tdb/Hlo1D48g4ro3vkdDhw0qnoPD7UF7QCA/2WXDvBe2QqviMaEgEX+4uhQJMRo43YIk3dJrP/XbuyN8hoFmUARonVqF/144Co9/chhN3ZFzysODWkrHm+QDU2aCHl89NANp8Tp4gm4deY6DzeXBh7tO4MnVR0N6x4OZHW4cbuzxB+hd1R34x175/KZGxeOxBSPxs0k5SDRoZN8nGlEEEgzSDrb75xSjqsWM3TWRA0FxWiy++c1Mfx4xGMd5K27Lmnvx0MoDOMjQ+txb1yX5f327DVan/J3EcIb8M8CW9kqN0yE9oMPS4nDjz+vKmbZ//eRcLJ5ThMIUI0Qg5HsRRSA9QR/+xWHUt1vx21WH8M6WGtw/pxj3zi7CgvMz8eL6cvzP6qNhc8eBXlxfjhfXR9/37/9rNnIYq4pEAH/dVou/bKjAFWMz8cTCErzxi/G4++IiPPzRAXxztAUeQYRHELGzsj3iuedwC/6LzM6qdoiiiFdvGRdSJqgOaCZHquwYaAZFgOY44LbpBZg5PBUPf3QAqyMEvZKsUx1jHkEMW4oULDfJgLF5Q6I+57+vGIUKkxnLd9TJbs9XvA8AK3edkA22HAcsvXnsWS0zuqA4GRsfmYlnvyzDC+vLw7bASrPjQ1qa4WQnxuCtWyfgoj99J9vxGNhiAoDqVrPs3QHHAUNTjbL7YXd5mDpcsxL1ks7K76s6cIzhwn3DlFx8+Kspss/rC19utsJkxgN/34/XNlXhPy8fiSXzh2PhuCys2t1wRtsvyYrHxIJE5o5oDt6qpy6rC1/sb8K6QybcMCUXT19dio2PzMTTa44hIUYDjyBKBqHwHIdEo8af1nF7RHRZXf5jfXNZKwCEpKl67S5/VUcjw7k5EAyKAO0zNNWIfyy+AK9vqsIzXx4P+ZEDe/5bex040SF/ELDk9ABgUkGibIDmOc7fOefyCPi+ul12u6VZ8fjlzMgdQ/0lPkaDZ68djXmj0/HIRwdCWrfD00M70iIpSjMiOVYre5IFd/SVNcu3ePUaFVMFR6fVhdq26CVcAFCUKt2WL3hEw3McHl8wUvZ5Z6qsuRe/eGc33tlSgxduGIPHZN5zalESRmcnhNzpAd5a98vOy4CK5047feDyCFi+ow5fHmjCowtG4D8vHwUAISm61Dgd1i2ZgYwEPTgOqGm14rKXtvnz1+H2DwA2Hm1B8aNrT2vfzlWDKkD73Du7yFvgvmyPvxWn16gkud82sxMtDCV2o8L08IdznKHMz6hTofDH1p/Z7kZjp/z7F6XF9vvgkWguHpmKlXdPxb/9ZZukEzW4Iy0aU7cDbb3yefXgoF/O8B1mxEsrUCI52WlDF0M+e1SWdB/2BV2YwslOjGG+cPeFyxM+cG0pb8PMP27G01ePxkPzhkV8/R0zCqNWefjwPMc8wCZc53WHxYn/+PgQVu89iU/umwZjUOelRsVheEacv78nuNMw2rsPjmF1pwy6AF3TZsGr31Th/e11cLhP3WInx2qRH3BSVbeylZaNYAzQLNUHafF6ZA3xBpdwOctw9tR2oqHTxpw3PBO9djfe21aLVzZWhrQ+c5PY37+xyxaxpjdQ4PwOHkFk6tQrSjMyzenAcsEEgNKsU52UbkFEQ6f87X9higFx+v4/tRacn4HtFTn44kBTSHmgzenBR/88ETVAq1VsYdfuEsKmscSg7sNYvRpPXlmC1zdVhR1nsKOyHfXtVpyfI60jNzvcePWbSn+nckuvHTaGOvu0eB3G5yeCg7djsT+qaJRu0ATolh4H/ndzFZZurApbFZEer5OU+bCUYHEcW8vR6RaYgktxmtHfEaJV8zBEmZfBp7HThkVLd+DxBSMxPCMOrI1pg1aFghT5XC3g3f8VO+vxwvpyHD0Z+r3E6dVMeV8f5vK2gItfQ6dN0vMfybD0OKY5M1h+D42Kl1x4mrvtaO6Wb/nnJRuY5xbpi6K0WHx0z1Tsq+/Cn74qw6d7GiSNCLkyu5W7TqDCFD2PL0LElrI2pguoRsXjgbnFuHV6PlbsrMdLGypCOl7DfQ9dVhd+u+qQ7PaDTS9Owf8tngbAOzjn2td29nkb55oBH6DdgojXN1Xh+bVlUTv9ggNtOUO+M8molfTwR9LYxRZcRmScCi6xOjVGZcYx3db/UNuJa/p4sMbq1BiXPwS/umgobp6aF/F5q/eexNNrjmFPlFKulKD6cTksJY+JRi3SAnLQde1WdDOkJIrT2C4ULPuQFq+TVFk0d9vRzlDyyJIDPxPj8oZg5d1TsL2iGL///GjYgSvhbDhiYn5uOJMKk8L+PSFGg/tmF+H6yTl49ZsqvBJh4MqZCuwwj5SnHmgGfIA+eKJbMuIoksChzaLoTXHIyU6M8Q9Ljaam1RJSkRBOcP3udZNy8Nm+Mx9GHI7Z4cbW8jZsLW/DhsMmvH3bhJApLN2CiEc+Pig7YKcozdinsieW8rbCFIPku61ptTCVD7LUQLsFkakKIC2oxK6+3cqU9irNDj80vL9NH5aM9Q9fiPe21+LRVYdly+zOxPzR6VgcZSoCwHuhfvLKEtwyLQ+/++woVuysh1sIbYnHx2jw60uGYYhBA47zdsi/tKECVoZRnT6DZI63gR+gWVqggLeO16fb5kJjl3wHXV6SgSnfWdViYercCE4TXDsxB29vqcHm4/KVA2fi/R110Kp5vH2bdGh1p8XJ1JnXlw7CHpuLqXwxa0iM5ILBEtQ1Kh7DM+QDdLfVJTsJDwAUphqDBuyw5TyLGQfK9Jfbphfg4pFp+E6mwuSBucVYONY7X4VvEFW4unK9RgVtwAU3waDBxILQKQgiKU6LxfI7J2PR+GykxulCLmrxejV+e9kIfydhu9mJtzbXyAbowLI7uXTOQDHgAzTLia3iOcktemuvg2kSHdYTkWUfYrSh5WFaNY+/3jERC17aHjb325/e2VKDK8Zm+k9gwJvmYRliHjzAJ5qWXgdT6zX4u2BLi2iYarFNPXY0dcvvQ2BdPOs+pMbpkNmHwSf9JT/ZIDsbXrnJjM1lrd5Jhzwi5pak4arxoa+pbDHjvW11EEQRHAcIArBsSw1Ks+OxeE7k6VCDXTMhGzanJ6QD0C2IqGm1IPPHDvG6dis8DC2YvXVdeODv+8FzHNMgsoFgwAfoqhb5llKSUVrBUdtmYZpEJ7gEK5JyhrkshsSEDy4FKUZsePhCLFl5AB+f4UAEOW9/V4PLx2T6W401bRamXF9BCnv+ubnbHjLHQzjBKSeWwSHFabGI6cc7mtEhaS/5Yyk/2RAyEvOnsK++Cy+sK8eKH+eqCGfdoWasCxii/tqmKnx63zTMH53u/1tVixmXvrgtbFprza+n92mfFq/Yh+sm52JSUOu7tdeBy17a5m8RuzwiU/9CTZsFSzdW9mkfznUDOkALoogahsEIKbE6Se0sS0sJAEZlsi3zw7K94vTIwSU7MQYf3TMVD17SjvWHTSg39UIUIVutwMF7+7itoo0pv/fPmg50WlxIjvVWs7BMFmXQqkIGc0TDWsExLKAGuqXXjlbGummWmnDWu5HAu6p2iwPNUaYJCHxNf62Ww8rUY8dNb+5CbJSqH47zpoAC5xG3ONy4+a1d+PLXMzBlaBKqWy1Y+MqOsL/7q7eMw4Lz5RdA8Hn2y+N4bVMVfjHdOyd0YFWIRxBRH2W0YmD562A3oAO0xeFhmgd6eIZ0sEc5QwmWUaf236JF09xt90+rGHUfGMrDLihOxgXFybLbCvbN0RZc/dpO2Umb2s1OWJ1uJMMboFknxi/sQ4kdyzbj9GrkBZS31bVbmQaVFKayteRZ9iElVieZga252wETw+/Yl3x8f2jpceCqpTtxvKkXF41MjfrcJfOGY8ORZsko0HazE1ct3YHnrz8ff14XvozyN5eOiDpXebB3t9bi8U8P+//P8xxKs+OREKP5MfctoKZVuqJKYaoRat474ZivLyb4fLikNB2PXDocAPBdWSueWXOceZ/OVQM6QDd22phmTwtuCbN0LOYkxjCNWKtutTD1rhcxloedjjklaVg0Lgvvyww1DzwfBJFtYEh+iiHimnXhsNxN5CQaJMO869qsTCvIDGMYbi6KQH2H/GCTtHhpBUdDh5Vp0QKWTsr+0tLjwKKlO7CzSn5KAFH0zmt9x4UFmPHst5JGQ1O3Hbe89c+wr7tr1lD86WfnMe/T+zvqcO/yvf7/uz0idGoenz9wAQTRu97gyS47pj/zrf+OJDsxBpt+MxPJsVr/cwCEdCaPzIzDvFJvOoYlBTkQDOgpoSpbzBGnVgwUeFJZnZ6oM975ZA3RM40Wq261MO3D2e75j7YYqY9GzfvvJHrtbqb0EGuaB/B2DtW1y28zK1EvuV1n6WRV8xxT67XH7mJK3eQmxUgqdI4wpkV+qha0b4ASS3D2sTjcGJYeiw/umsJUfXTDlFy8cvNY5sVyX1hfjtuW7Q47yEWvUcGgVUGvUSE1TiepjlHxHNLidZLnAAhJy7kCtvtTrfDzrzagW9As6Q2e4yQj6lp7HUyzeRUzDkZgmZBHo+KZt3c6Oi1OSedQJOfnJPiXGKptszLNY92Xlv/W8jamCY9GBgU5ls45QD4nD3i/i2j5T5/RQbXMrKkZliqSM7WrugO3L9sT0nEqMA7emFuShr/eMRG3Ltsd8c7k9hkFePPW8Uz17S6PgN+uOoS/bKgIeYzjvHdjL39diXazEyqeQ4/NJTm22s0OPPbJYRh1angEEenxOtw/tzhkNrvBUfksNaADdG2b/ImYYNBIqhAaO21MgYm15XiM4ZY+PkaNgrMwuQ7gzTHe+s5uptbwJaXp/trj6lYz03DfMbnRp1r1OXiiG/cu38t0N3HNxBzJ/1kGqLgFES+uL8d7/z4pakehb7VtOcHLXDEt+JBsQOJZrOBwCyL+tr0WS1YeDHuM9qU2+IYpubC5PLjj3T1hH59QkMgUnOvarbjn/b0RFzCI1alhc3rwx6+OR+yL6bK68ELAPNUFKUYsnlMcMndI4PqEg8WADdCiyLZUU6JBg+yAziCWlhIQfp26cFjy2QUpRskq2t+VtWLNgaYzmqWO5zi09Diw6VgLU3DWa1S4aeqplcVZ0goc553fYUdle9gg6puVrKrVjK+PmJg6+i4oTsaFQStH5zNevFbsrEd1qwXTipKhUfEhk/uoeA776+VnowOkIxJ7bC6m2u38ZANTKul0rdrdgF/+9YewjxWmGPHHa9lzxYC3ldxpceLhjw6GPPbAB/vR2uvAEwtLIt6Z9NrdWPjK9oiLLzx99WiUZMWjy+qKuJBtOL7DPngQYqx+cAxOCTRgA7Td5WGaT6MoLVYyYo1ltJhWzSOP4Va22+ZimlO6OGjK0A++r8fb39XIvq4/LZ5TJLkrYKkfF0XvvvYXnuPw5JUlIbe2s0ZEr04ItKOyHTsq2fOy4cTp1f5ZBQHv4sEtDGV+rJNPna5IozonFiTiw7unyPZjhJvNbsl8b1VEcJAWRBG/++woTnRY8erN48K2zl0eIWyrWMVzeOnGMf5BLbF6Nd6+fQLMdjdUPIc2sxOPf3rYP19HWrwOz1wz2j+5v6/a40RQZ25gwFbTiirntjazg6mzL3h5JJaWY9aQGGQwjBarNJklK6REEjxqro4hNdOfZo1IxRNXlkj+xpK/72+PLRiJS0rTQ/4+fVgKZo1IlR3K3F/S4vWSucEbmNNeZ7eDMFyAnVOShuV3TpaMXgy+c/CJVMe9ZP5wiAAeCdOSfndrLZq67Fh+52R/fbwPh9Clp4w6Nd6+bQJunHLqbkyn5iU11N02F576/Bh802/F6TW4eWpeSMdlcIotJe7U+wfP1T5Qp+YYsAG6rNnMVPAemKpweQQ0MLR4MxP0SDTK5xrrO6xMedzAAG11si3F1F9mjUjFqnunSqom7C621bP704OXDMNTV5WGfUzNc3jxhjG48Nlv+zShzunKHiKtImFd3T14aPjZdseFBWFbt5FSY8+vLYfDLSAzQQ+3ICLJqMVNU/Og5jk8PH84WnoceG5tWcjr1h5qxpznv8OHd0+J2veSn2zA3345SfaOx+JwSyY7cnsEmB3ukAAdPFVpklGL6lYLVuysw9KNVVGfO1AM2ABd1SK/fh0gLW9jreAoSGGb75el+oDnOMkkSe1mtn04UxoVj3suHopnrhkdkjdt6LQxrZ7dH1LjdPjdohLcc3H0gRDj84fgw7un4K739sLEsNLNmQgOtCwjD7Vq/qynOHyMOjWeuqo04uT8Y3OHgOe4kH4Bs8MtGdxx7cQc/Hxavv//f/rZedBrVPj950dDtnngRDcu+fNWLL9zMi4OGBDjWx5r/uh0vH3bBOYqlsA906r5sB2SwVO7Jsfq8M3RFjyxOnT/JhWyT+Z0LhmwAZqlekLFc5ID6mQX25Bi1g5ClpWr1SpOcpEobzaf1RrP3CQDZo9Kxb2zizA5wvy+FSYz03wZ+ckGtPQ6TmvQwJjcBFx6XgbumjWUebL/hWOzMOqxeDy95hjWHGhiGoR0OoJLHoPXXwwnLU664MPZYHcJGJUZj9d/Pi7qqMEJBYl46qpSPPnZ0ahVM3fNKgzpAPzdohIkxKjDdhw2dtow+7nvsOz2ibh9RgE8oncx2McWjMTvryoN6TuIxFdEM6EgEVeNz8LPJuYgISb0jrS114HcJAOuGJuJGybnYsrQJBxuCD2nrp+ci1un54f8fSDgxAE6seo3R1twrKknYmeCIIgw6tS4blKO/xaxvt2KL2SqJzyCdxYwlgEJXx5sQm2bNeL2BEHEEIMGN0zJ9bfIK1u8FQ8AQpadP12iKCIjQY+8JAPykg2yc1i/ubkad7+/N+pzOA5Y8+AMjMyMQ02rBQ63EHKycwB67G5/S0ij4pGTGIOcJAOGphr7NAIxWEOnDRUmM0zddrRbnP22LqPbI2DBmEwU/tgaFkXgkz0NaO11gI/wHh5BRE5iDBaOzWIe1HE6KkxmpMRqJauMR7O/vgs/1HXC4RIk+y4IImK0Ktw4JTfigJUv9jehrt0Scv643AL0GhVunuZd5KG2zdLn1I7Z4UZZUy9G5yREnLdEFL0TQOUkxiAtYETn4cYefHusxZ+PH5UZj5kjUgZsimPABmhy+pasPBB20EGgOL0ah5+ad1YWRyWEeA2OWhXSJyyVLIlGLVMlCyHk9FGAJhIeQWSqHy9M6dsyV4SQvqMzjEg0dduZ6seL0oxnNd9KCKEATYLUtFqYKjgKf6KSMkIGMwrQRKKWcZmrvkzSTwg5PRSgiQTLZFEqnqMWNCE/AQrQRIKlgsOgVTHPMEcIOX0UoIkEywhMo04tGTxACDk7BuxQb9J3XVb5eY+L0mJx58xCKrEj5CdAAZr4Vbda0B00raaK53BeTgIuKUnH5WMzMT5/iGSmN0LI2UNnGvE71tQDp1uAVs1jytAkzC1Jw2XnZ+K8KHMmEELOHpqLg/htOGLC7poOXDkuGyVZcQN2AhpCzhUUoAkhRKHovpUQQhSKAjQhhCgUBWhCCFEoCtCEEKJQFKAJIUShKEATQohCUYAmhBCFogBNCCEKRQGaEEIUigI0IYQoFAVoQghRKArQhBCiUBSgCSFEoShAE0KIQlGAJoQQhaIATQghCkUBmhBCFIoCNCGEKBQFaEIIUSgK0IQQolAUoAkhRKEoQBNCiEJRgCaEEIWiAE0IIQpFAZoQQhSKAjQhhCgUBWhCCFEoCtCEEKJQ/w9dDVq4Os0a4QAAAABJRU5ErkJggg=="

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "5d3ff4b520da57f195067c5315802e1b.png";

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8d10bab8c37a0cd7892a0bf1450d5bd9.png";

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a1003665294a1a91ce8715dce361cba1.png";

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0dd88c0de97058c7eedde78fd1056ab1.png";

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "00b5fa2354e73e4e860077d50a17b52f.png";

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "72050235b4b5f3c5fb3602658e0ee061.png";

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "1595f9012cfa318153b2a3658cc1045f.png";

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "c77dc9a641fcbfa6880425b3bdf87055.png";

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "dbda28cc81fe5c38e5b5c08415f45d68.png";

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9db8c93982acc8cb28786d2b4ea2dc88.png";

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "b77eb6db53bc9bfd376da8a978033e0c.png";

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a1003665294a1a91ce8715dce361cba1.png";

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0dd88c0de97058c7eedde78fd1056ab1.png";

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "c1d5d955b8987ece6b1bfa576c0781b8.png";

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "7a45b4407de524647a9243a52cc659df.png";

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "b898eac7f0b043703fa8cfe62f2b46e4.png";

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "aed6eab4f6934ef40ef290b5ccb1b967.png";

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9065517bf8e6929e9f0274501a33e0ff.png";

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "147b3a49957ea7935961bed38808b431.png";

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "43840374053daf0f9fdc20c91f039a21.png";

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Swiper 4.5.0
	 * Most modern mobile touch slider and framework with hardware accelerated transitions
	 * http://www.idangero.us/swiper/
	 *
	 * Copyright 2014-2019 Vladimir Kharlampidi
	 *
	 * Released under the MIT License
	 *
	 * Released on: February 22, 2019
	 */
	
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global = global || self, global.Swiper = factory());
	}(this, function () { 'use strict';
	
	  /**
	   * SSR Window 1.0.1
	   * Better handling for window object in SSR environment
	   * https://github.com/nolimits4web/ssr-window
	   *
	   * Copyright 2018, Vladimir Kharlampidi
	   *
	   * Licensed under MIT
	   *
	   * Released on: July 18, 2018
	   */
	  var doc = (typeof document === 'undefined') ? {
	    body: {},
	    addEventListener: function addEventListener() {},
	    removeEventListener: function removeEventListener() {},
	    activeElement: {
	      blur: function blur() {},
	      nodeName: '',
	    },
	    querySelector: function querySelector() {
	      return null;
	    },
	    querySelectorAll: function querySelectorAll() {
	      return [];
	    },
	    getElementById: function getElementById() {
	      return null;
	    },
	    createEvent: function createEvent() {
	      return {
	        initEvent: function initEvent() {},
	      };
	    },
	    createElement: function createElement() {
	      return {
	        children: [],
	        childNodes: [],
	        style: {},
	        setAttribute: function setAttribute() {},
	        getElementsByTagName: function getElementsByTagName() {
	          return [];
	        },
	      };
	    },
	    location: { hash: '' },
	  } : document; // eslint-disable-line
	
	  var win = (typeof window === 'undefined') ? {
	    document: doc,
	    navigator: {
	      userAgent: '',
	    },
	    location: {},
	    history: {},
	    CustomEvent: function CustomEvent() {
	      return this;
	    },
	    addEventListener: function addEventListener() {},
	    removeEventListener: function removeEventListener() {},
	    getComputedStyle: function getComputedStyle() {
	      return {
	        getPropertyValue: function getPropertyValue() {
	          return '';
	        },
	      };
	    },
	    Image: function Image() {},
	    Date: function Date() {},
	    screen: {},
	    setTimeout: function setTimeout() {},
	    clearTimeout: function clearTimeout() {},
	  } : window; // eslint-disable-line
	
	  /**
	   * Dom7 2.1.3
	   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
	   * http://framework7.io/docs/dom.html
	   *
	   * Copyright 2019, Vladimir Kharlampidi
	   * The iDangero.us
	   * http://www.idangero.us/
	   *
	   * Licensed under MIT
	   *
	   * Released on: February 11, 2019
	   */
	
	  var Dom7 = function Dom7(arr) {
	    var self = this;
	    // Create array-like object
	    for (var i = 0; i < arr.length; i += 1) {
	      self[i] = arr[i];
	    }
	    self.length = arr.length;
	    // Return collection with methods
	    return this;
	  };
	
	  function $(selector, context) {
	    var arr = [];
	    var i = 0;
	    if (selector && !context) {
	      if (selector instanceof Dom7) {
	        return selector;
	      }
	    }
	    if (selector) {
	        // String
	      if (typeof selector === 'string') {
	        var els;
	        var tempParent;
	        var html = selector.trim();
	        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
	          var toCreate = 'div';
	          if (html.indexOf('<li') === 0) { toCreate = 'ul'; }
	          if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }
	          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }
	          if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }
	          if (html.indexOf('<option') === 0) { toCreate = 'select'; }
	          tempParent = doc.createElement(toCreate);
	          tempParent.innerHTML = html;
	          for (i = 0; i < tempParent.childNodes.length; i += 1) {
	            arr.push(tempParent.childNodes[i]);
	          }
	        } else {
	          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
	            // Pure ID selector
	            els = [doc.getElementById(selector.trim().split('#')[1])];
	          } else {
	            // Other selectors
	            els = (context || doc).querySelectorAll(selector.trim());
	          }
	          for (i = 0; i < els.length; i += 1) {
	            if (els[i]) { arr.push(els[i]); }
	          }
	        }
	      } else if (selector.nodeType || selector === win || selector === doc) {
	        // Node/element
	        arr.push(selector);
	      } else if (selector.length > 0 && selector[0].nodeType) {
	        // Array of elements or instance of Dom
	        for (i = 0; i < selector.length; i += 1) {
	          arr.push(selector[i]);
	        }
	      }
	    }
	    return new Dom7(arr);
	  }
	
	  $.fn = Dom7.prototype;
	  $.Class = Dom7;
	  $.Dom7 = Dom7;
	
	  function unique(arr) {
	    var uniqueArray = [];
	    for (var i = 0; i < arr.length; i += 1) {
	      if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }
	    }
	    return uniqueArray;
	  }
	
	  // Classes and attributes
	  function addClass(className) {
	    if (typeof className === 'undefined') {
	      return this;
	    }
	    var classes = className.split(' ');
	    for (var i = 0; i < classes.length; i += 1) {
	      for (var j = 0; j < this.length; j += 1) {
	        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.add(classes[i]); }
	      }
	    }
	    return this;
	  }
	  function removeClass(className) {
	    var classes = className.split(' ');
	    for (var i = 0; i < classes.length; i += 1) {
	      for (var j = 0; j < this.length; j += 1) {
	        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.remove(classes[i]); }
	      }
	    }
	    return this;
	  }
	  function hasClass(className) {
	    if (!this[0]) { return false; }
	    return this[0].classList.contains(className);
	  }
	  function toggleClass(className) {
	    var classes = className.split(' ');
	    for (var i = 0; i < classes.length; i += 1) {
	      for (var j = 0; j < this.length; j += 1) {
	        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.toggle(classes[i]); }
	      }
	    }
	    return this;
	  }
	  function attr(attrs, value) {
	    var arguments$1 = arguments;
	
	    if (arguments.length === 1 && typeof attrs === 'string') {
	      // Get attr
	      if (this[0]) { return this[0].getAttribute(attrs); }
	      return undefined;
	    }
	
	    // Set attrs
	    for (var i = 0; i < this.length; i += 1) {
	      if (arguments$1.length === 2) {
	        // String
	        this[i].setAttribute(attrs, value);
	      } else {
	        // Object
	        // eslint-disable-next-line
	        for (var attrName in attrs) {
	          this[i][attrName] = attrs[attrName];
	          this[i].setAttribute(attrName, attrs[attrName]);
	        }
	      }
	    }
	    return this;
	  }
	  // eslint-disable-next-line
	  function removeAttr(attr) {
	    for (var i = 0; i < this.length; i += 1) {
	      this[i].removeAttribute(attr);
	    }
	    return this;
	  }
	  function data(key, value) {
	    var el;
	    if (typeof value === 'undefined') {
	      el = this[0];
	      // Get value
	      if (el) {
	        if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
	          return el.dom7ElementDataStorage[key];
	        }
	
	        var dataKey = el.getAttribute(("data-" + key));
	        if (dataKey) {
	          return dataKey;
	        }
	        return undefined;
	      }
	      return undefined;
	    }
	
	    // Set value
	    for (var i = 0; i < this.length; i += 1) {
	      el = this[i];
	      if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }
	      el.dom7ElementDataStorage[key] = value;
	    }
	    return this;
	  }
	  // Transforms
	  // eslint-disable-next-line
	  function transform(transform) {
	    for (var i = 0; i < this.length; i += 1) {
	      var elStyle = this[i].style;
	      elStyle.webkitTransform = transform;
	      elStyle.transform = transform;
	    }
	    return this;
	  }
	  function transition(duration) {
	    if (typeof duration !== 'string') {
	      duration = duration + "ms"; // eslint-disable-line
	    }
	    for (var i = 0; i < this.length; i += 1) {
	      var elStyle = this[i].style;
	      elStyle.webkitTransitionDuration = duration;
	      elStyle.transitionDuration = duration;
	    }
	    return this;
	  }
	  // Events
	  function on() {
	    var assign;
	
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var eventType = args[0];
	    var targetSelector = args[1];
	    var listener = args[2];
	    var capture = args[3];
	    if (typeof args[1] === 'function') {
	      (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
	      targetSelector = undefined;
	    }
	    if (!capture) { capture = false; }
	
	    function handleLiveEvent(e) {
	      var target = e.target;
	      if (!target) { return; }
	      var eventData = e.target.dom7EventData || [];
	      if (eventData.indexOf(e) < 0) {
	        eventData.unshift(e);
	      }
	      if ($(target).is(targetSelector)) { listener.apply(target, eventData); }
	      else {
	        var parents = $(target).parents(); // eslint-disable-line
	        for (var k = 0; k < parents.length; k += 1) {
	          if ($(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }
	        }
	      }
	    }
	    function handleEvent(e) {
	      var eventData = e && e.target ? e.target.dom7EventData || [] : [];
	      if (eventData.indexOf(e) < 0) {
	        eventData.unshift(e);
	      }
	      listener.apply(this, eventData);
	    }
	    var events = eventType.split(' ');
	    var j;
	    for (var i = 0; i < this.length; i += 1) {
	      var el = this[i];
	      if (!targetSelector) {
	        for (j = 0; j < events.length; j += 1) {
	          var event = events[j];
	          if (!el.dom7Listeners) { el.dom7Listeners = {}; }
	          if (!el.dom7Listeners[event]) { el.dom7Listeners[event] = []; }
	          el.dom7Listeners[event].push({
	            listener: listener,
	            proxyListener: handleEvent,
	          });
	          el.addEventListener(event, handleEvent, capture);
	        }
	      } else {
	        // Live events
	        for (j = 0; j < events.length; j += 1) {
	          var event$1 = events[j];
	          if (!el.dom7LiveListeners) { el.dom7LiveListeners = {}; }
	          if (!el.dom7LiveListeners[event$1]) { el.dom7LiveListeners[event$1] = []; }
	          el.dom7LiveListeners[event$1].push({
	            listener: listener,
	            proxyListener: handleLiveEvent,
	          });
	          el.addEventListener(event$1, handleLiveEvent, capture);
	        }
	      }
	    }
	    return this;
	  }
	  function off() {
	    var assign;
	
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	    var eventType = args[0];
	    var targetSelector = args[1];
	    var listener = args[2];
	    var capture = args[3];
	    if (typeof args[1] === 'function') {
	      (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
	      targetSelector = undefined;
	    }
	    if (!capture) { capture = false; }
	
	    var events = eventType.split(' ');
	    for (var i = 0; i < events.length; i += 1) {
	      var event = events[i];
	      for (var j = 0; j < this.length; j += 1) {
	        var el = this[j];
	        var handlers = (void 0);
	        if (!targetSelector && el.dom7Listeners) {
	          handlers = el.dom7Listeners[event];
	        } else if (targetSelector && el.dom7LiveListeners) {
	          handlers = el.dom7LiveListeners[event];
	        }
	        if (handlers && handlers.length) {
	          for (var k = handlers.length - 1; k >= 0; k -= 1) {
	            var handler = handlers[k];
	            if (listener && handler.listener === listener) {
	              el.removeEventListener(event, handler.proxyListener, capture);
	              handlers.splice(k, 1);
	            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
	              el.removeEventListener(event, handler.proxyListener, capture);
	              handlers.splice(k, 1);
	            } else if (!listener) {
	              el.removeEventListener(event, handler.proxyListener, capture);
	              handlers.splice(k, 1);
	            }
	          }
	        }
	      }
	    }
	    return this;
	  }
	  function trigger() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	
	    var events = args[0].split(' ');
	    var eventData = args[1];
	    for (var i = 0; i < events.length; i += 1) {
	      var event = events[i];
	      for (var j = 0; j < this.length; j += 1) {
	        var el = this[j];
	        var evt = (void 0);
	        try {
	          evt = new win.CustomEvent(event, {
	            detail: eventData,
	            bubbles: true,
	            cancelable: true,
	          });
	        } catch (e) {
	          evt = doc.createEvent('Event');
	          evt.initEvent(event, true, true);
	          evt.detail = eventData;
	        }
	        // eslint-disable-next-line
	        el.dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });
	        el.dispatchEvent(evt);
	        el.dom7EventData = [];
	        delete el.dom7EventData;
	      }
	    }
	    return this;
	  }
	  function transitionEnd(callback) {
	    var events = ['webkitTransitionEnd', 'transitionend'];
	    var dom = this;
	    var i;
	    function fireCallBack(e) {
	      /* jshint validthis:true */
	      if (e.target !== this) { return; }
	      callback.call(this, e);
	      for (i = 0; i < events.length; i += 1) {
	        dom.off(events[i], fireCallBack);
	      }
	    }
	    if (callback) {
	      for (i = 0; i < events.length; i += 1) {
	        dom.on(events[i], fireCallBack);
	      }
	    }
	    return this;
	  }
	  function outerWidth(includeMargins) {
	    if (this.length > 0) {
	      if (includeMargins) {
	        // eslint-disable-next-line
	        var styles = this.styles();
	        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
	      }
	      return this[0].offsetWidth;
	    }
	    return null;
	  }
	  function outerHeight(includeMargins) {
	    if (this.length > 0) {
	      if (includeMargins) {
	        // eslint-disable-next-line
	        var styles = this.styles();
	        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
	      }
	      return this[0].offsetHeight;
	    }
	    return null;
	  }
	  function offset() {
	    if (this.length > 0) {
	      var el = this[0];
	      var box = el.getBoundingClientRect();
	      var body = doc.body;
	      var clientTop = el.clientTop || body.clientTop || 0;
	      var clientLeft = el.clientLeft || body.clientLeft || 0;
	      var scrollTop = el === win ? win.scrollY : el.scrollTop;
	      var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
	      return {
	        top: (box.top + scrollTop) - clientTop,
	        left: (box.left + scrollLeft) - clientLeft,
	      };
	    }
	
	    return null;
	  }
	  function styles() {
	    if (this[0]) { return win.getComputedStyle(this[0], null); }
	    return {};
	  }
	  function css(props, value) {
	    var i;
	    if (arguments.length === 1) {
	      if (typeof props === 'string') {
	        if (this[0]) { return win.getComputedStyle(this[0], null).getPropertyValue(props); }
	      } else {
	        for (i = 0; i < this.length; i += 1) {
	          // eslint-disable-next-line
	          for (var prop in props) {
	            this[i].style[prop] = props[prop];
	          }
	        }
	        return this;
	      }
	    }
	    if (arguments.length === 2 && typeof props === 'string') {
	      for (i = 0; i < this.length; i += 1) {
	        this[i].style[props] = value;
	      }
	      return this;
	    }
	    return this;
	  }
	  // Iterate over the collection passing elements to `callback`
	  function each(callback) {
	    // Don't bother continuing without a callback
	    if (!callback) { return this; }
	    // Iterate over the current collection
	    for (var i = 0; i < this.length; i += 1) {
	      // If the callback returns false
	      if (callback.call(this[i], i, this[i]) === false) {
	        // End the loop early
	        return this;
	      }
	    }
	    // Return `this` to allow chained DOM operations
	    return this;
	  }
	  // eslint-disable-next-line
	  function html(html) {
	    if (typeof html === 'undefined') {
	      return this[0] ? this[0].innerHTML : undefined;
	    }
	
	    for (var i = 0; i < this.length; i += 1) {
	      this[i].innerHTML = html;
	    }
	    return this;
	  }
	  // eslint-disable-next-line
	  function text(text) {
	    if (typeof text === 'undefined') {
	      if (this[0]) {
	        return this[0].textContent.trim();
	      }
	      return null;
	    }
	
	    for (var i = 0; i < this.length; i += 1) {
	      this[i].textContent = text;
	    }
	    return this;
	  }
	  function is(selector) {
	    var el = this[0];
	    var compareWith;
	    var i;
	    if (!el || typeof selector === 'undefined') { return false; }
	    if (typeof selector === 'string') {
	      if (el.matches) { return el.matches(selector); }
	      else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }
	      else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }
	
	      compareWith = $(selector);
	      for (i = 0; i < compareWith.length; i += 1) {
	        if (compareWith[i] === el) { return true; }
	      }
	      return false;
	    } else if (selector === doc) { return el === doc; }
	    else if (selector === win) { return el === win; }
	
	    if (selector.nodeType || selector instanceof Dom7) {
	      compareWith = selector.nodeType ? [selector] : selector;
	      for (i = 0; i < compareWith.length; i += 1) {
	        if (compareWith[i] === el) { return true; }
	      }
	      return false;
	    }
	    return false;
	  }
	  function index() {
	    var child = this[0];
	    var i;
	    if (child) {
	      i = 0;
	      // eslint-disable-next-line
	      while ((child = child.previousSibling) !== null) {
	        if (child.nodeType === 1) { i += 1; }
	      }
	      return i;
	    }
	    return undefined;
	  }
	  // eslint-disable-next-line
	  function eq(index) {
	    if (typeof index === 'undefined') { return this; }
	    var length = this.length;
	    var returnIndex;
	    if (index > length - 1) {
	      return new Dom7([]);
	    }
	    if (index < 0) {
	      returnIndex = length + index;
	      if (returnIndex < 0) { return new Dom7([]); }
	      return new Dom7([this[returnIndex]]);
	    }
	    return new Dom7([this[index]]);
	  }
	  function append() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	
	    var newChild;
	
	    for (var k = 0; k < args.length; k += 1) {
	      newChild = args[k];
	      for (var i = 0; i < this.length; i += 1) {
	        if (typeof newChild === 'string') {
	          var tempDiv = doc.createElement('div');
	          tempDiv.innerHTML = newChild;
	          while (tempDiv.firstChild) {
	            this[i].appendChild(tempDiv.firstChild);
	          }
	        } else if (newChild instanceof Dom7) {
	          for (var j = 0; j < newChild.length; j += 1) {
	            this[i].appendChild(newChild[j]);
	          }
	        } else {
	          this[i].appendChild(newChild);
	        }
	      }
	    }
	
	    return this;
	  }
	  function prepend(newChild) {
	    var i;
	    var j;
	    for (i = 0; i < this.length; i += 1) {
	      if (typeof newChild === 'string') {
	        var tempDiv = doc.createElement('div');
	        tempDiv.innerHTML = newChild;
	        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
	          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
	        }
	      } else if (newChild instanceof Dom7) {
	        for (j = 0; j < newChild.length; j += 1) {
	          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
	        }
	      } else {
	        this[i].insertBefore(newChild, this[i].childNodes[0]);
	      }
	    }
	    return this;
	  }
	  function next(selector) {
	    if (this.length > 0) {
	      if (selector) {
	        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
	          return new Dom7([this[0].nextElementSibling]);
	        }
	        return new Dom7([]);
	      }
	
	      if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }
	      return new Dom7([]);
	    }
	    return new Dom7([]);
	  }
	  function nextAll(selector) {
	    var nextEls = [];
	    var el = this[0];
	    if (!el) { return new Dom7([]); }
	    while (el.nextElementSibling) {
	      var next = el.nextElementSibling; // eslint-disable-line
	      if (selector) {
	        if ($(next).is(selector)) { nextEls.push(next); }
	      } else { nextEls.push(next); }
	      el = next;
	    }
	    return new Dom7(nextEls);
	  }
	  function prev(selector) {
	    if (this.length > 0) {
	      var el = this[0];
	      if (selector) {
	        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
	          return new Dom7([el.previousElementSibling]);
	        }
	        return new Dom7([]);
	      }
	
	      if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }
	      return new Dom7([]);
	    }
	    return new Dom7([]);
	  }
	  function prevAll(selector) {
	    var prevEls = [];
	    var el = this[0];
	    if (!el) { return new Dom7([]); }
	    while (el.previousElementSibling) {
	      var prev = el.previousElementSibling; // eslint-disable-line
	      if (selector) {
	        if ($(prev).is(selector)) { prevEls.push(prev); }
	      } else { prevEls.push(prev); }
	      el = prev;
	    }
	    return new Dom7(prevEls);
	  }
	  function parent(selector) {
	    var parents = []; // eslint-disable-line
	    for (var i = 0; i < this.length; i += 1) {
	      if (this[i].parentNode !== null) {
	        if (selector) {
	          if ($(this[i].parentNode).is(selector)) { parents.push(this[i].parentNode); }
	        } else {
	          parents.push(this[i].parentNode);
	        }
	      }
	    }
	    return $(unique(parents));
	  }
	  function parents(selector) {
	    var parents = []; // eslint-disable-line
	    for (var i = 0; i < this.length; i += 1) {
	      var parent = this[i].parentNode; // eslint-disable-line
	      while (parent) {
	        if (selector) {
	          if ($(parent).is(selector)) { parents.push(parent); }
	        } else {
	          parents.push(parent);
	        }
	        parent = parent.parentNode;
	      }
	    }
	    return $(unique(parents));
	  }
	  function closest(selector) {
	    var closest = this; // eslint-disable-line
	    if (typeof selector === 'undefined') {
	      return new Dom7([]);
	    }
	    if (!closest.is(selector)) {
	      closest = closest.parents(selector).eq(0);
	    }
	    return closest;
	  }
	  function find(selector) {
	    var foundElements = [];
	    for (var i = 0; i < this.length; i += 1) {
	      var found = this[i].querySelectorAll(selector);
	      for (var j = 0; j < found.length; j += 1) {
	        foundElements.push(found[j]);
	      }
	    }
	    return new Dom7(foundElements);
	  }
	  function children(selector) {
	    var children = []; // eslint-disable-line
	    for (var i = 0; i < this.length; i += 1) {
	      var childNodes = this[i].childNodes;
	
	      for (var j = 0; j < childNodes.length; j += 1) {
	        if (!selector) {
	          if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }
	        } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
	          children.push(childNodes[j]);
	        }
	      }
	    }
	    return new Dom7(unique(children));
	  }
	  function remove() {
	    for (var i = 0; i < this.length; i += 1) {
	      if (this[i].parentNode) { this[i].parentNode.removeChild(this[i]); }
	    }
	    return this;
	  }
	  function add() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];
	
	    var dom = this;
	    var i;
	    var j;
	    for (i = 0; i < args.length; i += 1) {
	      var toAdd = $(args[i]);
	      for (j = 0; j < toAdd.length; j += 1) {
	        dom[dom.length] = toAdd[j];
	        dom.length += 1;
	      }
	    }
	    return dom;
	  }
	
	  var Methods = {
	    addClass: addClass,
	    removeClass: removeClass,
	    hasClass: hasClass,
	    toggleClass: toggleClass,
	    attr: attr,
	    removeAttr: removeAttr,
	    data: data,
	    transform: transform,
	    transition: transition,
	    on: on,
	    off: off,
	    trigger: trigger,
	    transitionEnd: transitionEnd,
	    outerWidth: outerWidth,
	    outerHeight: outerHeight,
	    offset: offset,
	    css: css,
	    each: each,
	    html: html,
	    text: text,
	    is: is,
	    index: index,
	    eq: eq,
	    append: append,
	    prepend: prepend,
	    next: next,
	    nextAll: nextAll,
	    prev: prev,
	    prevAll: prevAll,
	    parent: parent,
	    parents: parents,
	    closest: closest,
	    find: find,
	    children: children,
	    remove: remove,
	    add: add,
	    styles: styles,
	  };
	
	  Object.keys(Methods).forEach(function (methodName) {
	    $.fn[methodName] = Methods[methodName];
	  });
	
	  var Utils = {
	    deleteProps: function deleteProps(obj) {
	      var object = obj;
	      Object.keys(object).forEach(function (key) {
	        try {
	          object[key] = null;
	        } catch (e) {
	          // no getter for object
	        }
	        try {
	          delete object[key];
	        } catch (e) {
	          // something got wrong
	        }
	      });
	    },
	    nextTick: function nextTick(callback, delay) {
	      if ( delay === void 0 ) delay = 0;
	
	      return setTimeout(callback, delay);
	    },
	    now: function now() {
	      return Date.now();
	    },
	    getTranslate: function getTranslate(el, axis) {
	      if ( axis === void 0 ) axis = 'x';
	
	      var matrix;
	      var curTransform;
	      var transformMatrix;
	
	      var curStyle = win.getComputedStyle(el, null);
	
	      if (win.WebKitCSSMatrix) {
	        curTransform = curStyle.transform || curStyle.webkitTransform;
	        if (curTransform.split(',').length > 6) {
	          curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');
	        }
	        // Some old versions of Webkit choke when 'none' is passed; pass
	        // empty string instead in this case
	        transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
	      } else {
	        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	        matrix = transformMatrix.toString().split(',');
	      }
	
	      if (axis === 'x') {
	        // Latest Chrome and webkits Fix
	        if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }
	        // Crazy IE10 Matrix
	        else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }
	        // Normal Browsers
	        else { curTransform = parseFloat(matrix[4]); }
	      }
	      if (axis === 'y') {
	        // Latest Chrome and webkits Fix
	        if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }
	        // Crazy IE10 Matrix
	        else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }
	        // Normal Browsers
	        else { curTransform = parseFloat(matrix[5]); }
	      }
	      return curTransform || 0;
	    },
	    parseUrlQuery: function parseUrlQuery(url) {
	      var query = {};
	      var urlToParse = url || win.location.href;
	      var i;
	      var params;
	      var param;
	      var length;
	      if (typeof urlToParse === 'string' && urlToParse.length) {
	        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
	        params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });
	        length = params.length;
	
	        for (i = 0; i < length; i += 1) {
	          param = params[i].replace(/#\S+/g, '').split('=');
	          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
	        }
	      }
	      return query;
	    },
	    isObject: function isObject(o) {
	      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
	    },
	    extend: function extend() {
	      var args = [], len$1 = arguments.length;
	      while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];
	
	      var to = Object(args[0]);
	      for (var i = 1; i < args.length; i += 1) {
	        var nextSource = args[i];
	        if (nextSource !== undefined && nextSource !== null) {
	          var keysArray = Object.keys(Object(nextSource));
	          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	            var nextKey = keysArray[nextIndex];
	            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	            if (desc !== undefined && desc.enumerable) {
	              if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	                Utils.extend(to[nextKey], nextSource[nextKey]);
	              } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	                to[nextKey] = {};
	                Utils.extend(to[nextKey], nextSource[nextKey]);
	              } else {
	                to[nextKey] = nextSource[nextKey];
	              }
	            }
	          }
	        }
	      }
	      return to;
	    },
	  };
	
	  var Support = (function Support() {
	    var testDiv = doc.createElement('div');
	    return {
	      touch: (win.Modernizr && win.Modernizr.touch === true) || (function checkTouch() {
	        return !!((win.navigator.maxTouchPoints > 0) || ('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));
	      }()),
	
	      pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent || ('maxTouchPoints' in win.navigator && win.navigator.maxTouchPoints > 0)),
	      prefixedPointerEvents: !!win.navigator.msPointerEnabled,
	
	      transition: (function checkTransition() {
	        var style = testDiv.style;
	        return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);
	      }()),
	      transforms3d: (win.Modernizr && win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
	        var style = testDiv.style;
	        return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);
	      }()),
	
	      flexbox: (function checkFlexbox() {
	        var style = testDiv.style;
	        var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
	        for (var i = 0; i < styles.length; i += 1) {
	          if (styles[i] in style) { return true; }
	        }
	        return false;
	      }()),
	
	      observer: (function checkObserver() {
	        return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
	      }()),
	
	      passiveListener: (function checkPassiveListener() {
	        var supportsPassive = false;
	        try {
	          var opts = Object.defineProperty({}, 'passive', {
	            // eslint-disable-next-line
	            get: function get() {
	              supportsPassive = true;
	            },
	          });
	          win.addEventListener('testPassiveListener', null, opts);
	        } catch (e) {
	          // No support
	        }
	        return supportsPassive;
	      }()),
	
	      gestures: (function checkGestures() {
	        return 'ongesturestart' in win;
	      }()),
	    };
	  }());
	
	  var Browser = (function Browser() {
	    function isSafari() {
	      var ua = win.navigator.userAgent.toLowerCase();
	      return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
	    }
	    return {
	      isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),
	      isEdge: !!win.navigator.userAgent.match(/Edge/g),
	      isSafari: isSafari(),
	      isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
	    };
	  }());
	
	  var SwiperClass = function SwiperClass(params) {
	    if ( params === void 0 ) params = {};
	
	    var self = this;
	    self.params = params;
	
	    // Events
	    self.eventsListeners = {};
	
	    if (self.params && self.params.on) {
	      Object.keys(self.params.on).forEach(function (eventName) {
	        self.on(eventName, self.params.on[eventName]);
	      });
	    }
	  };
	
	  var staticAccessors = { components: { configurable: true } };
	
	  SwiperClass.prototype.on = function on (events, handler, priority) {
	    var self = this;
	    if (typeof handler !== 'function') { return self; }
	    var method = priority ? 'unshift' : 'push';
	    events.split(' ').forEach(function (event) {
	      if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }
	      self.eventsListeners[event][method](handler);
	    });
	    return self;
	  };
	
	  SwiperClass.prototype.once = function once (events, handler, priority) {
	    var self = this;
	    if (typeof handler !== 'function') { return self; }
	    function onceHandler() {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];
	
	      handler.apply(self, args);
	      self.off(events, onceHandler);
	      if (onceHandler.f7proxy) {
	        delete onceHandler.f7proxy;
	      }
	    }
	    onceHandler.f7proxy = handler;
	    return self.on(events, onceHandler, priority);
	  };
	
	  SwiperClass.prototype.off = function off (events, handler) {
	    var self = this;
	    if (!self.eventsListeners) { return self; }
	    events.split(' ').forEach(function (event) {
	      if (typeof handler === 'undefined') {
	        self.eventsListeners[event] = [];
	      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
	        self.eventsListeners[event].forEach(function (eventHandler, index) {
	          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
	            self.eventsListeners[event].splice(index, 1);
	          }
	        });
	      }
	    });
	    return self;
	  };
	
	  SwiperClass.prototype.emit = function emit () {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];
	
	    var self = this;
	    if (!self.eventsListeners) { return self; }
	    var events;
	    var data;
	    var context;
	    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
	      events = args[0];
	      data = args.slice(1, args.length);
	      context = self;
	    } else {
	      events = args[0].events;
	      data = args[0].data;
	      context = args[0].context || self;
	    }
	    var eventsArray = Array.isArray(events) ? events : events.split(' ');
	    eventsArray.forEach(function (event) {
	      if (self.eventsListeners && self.eventsListeners[event]) {
	        var handlers = [];
	        self.eventsListeners[event].forEach(function (eventHandler) {
	          handlers.push(eventHandler);
	        });
	        handlers.forEach(function (eventHandler) {
	          eventHandler.apply(context, data);
	        });
	      }
	    });
	    return self;
	  };
	
	  SwiperClass.prototype.useModulesParams = function useModulesParams (instanceParams) {
	    var instance = this;
	    if (!instance.modules) { return; }
	    Object.keys(instance.modules).forEach(function (moduleName) {
	      var module = instance.modules[moduleName];
	      // Extend params
	      if (module.params) {
	        Utils.extend(instanceParams, module.params);
	      }
	    });
	  };
	
	  SwiperClass.prototype.useModules = function useModules (modulesParams) {
	      if ( modulesParams === void 0 ) modulesParams = {};
	
	    var instance = this;
	    if (!instance.modules) { return; }
	    Object.keys(instance.modules).forEach(function (moduleName) {
	      var module = instance.modules[moduleName];
	      var moduleParams = modulesParams[moduleName] || {};
	      // Extend instance methods and props
	      if (module.instance) {
	        Object.keys(module.instance).forEach(function (modulePropName) {
	          var moduleProp = module.instance[modulePropName];
	          if (typeof moduleProp === 'function') {
	            instance[modulePropName] = moduleProp.bind(instance);
	          } else {
	            instance[modulePropName] = moduleProp;
	          }
	        });
	      }
	      // Add event listeners
	      if (module.on && instance.on) {
	        Object.keys(module.on).forEach(function (moduleEventName) {
	          instance.on(moduleEventName, module.on[moduleEventName]);
	        });
	      }
	
	      // Module create callback
	      if (module.create) {
	        module.create.bind(instance)(moduleParams);
	      }
	    });
	  };
	
	  staticAccessors.components.set = function (components) {
	    var Class = this;
	    if (!Class.use) { return; }
	    Class.use(components);
	  };
	
	  SwiperClass.installModule = function installModule (module) {
	      var params = [], len = arguments.length - 1;
	      while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];
	
	    var Class = this;
	    if (!Class.prototype.modules) { Class.prototype.modules = {}; }
	    var name = module.name || (((Object.keys(Class.prototype.modules).length) + "_" + (Utils.now())));
	    Class.prototype.modules[name] = module;
	    // Prototype
	    if (module.proto) {
	      Object.keys(module.proto).forEach(function (key) {
	        Class.prototype[key] = module.proto[key];
	      });
	    }
	    // Class
	    if (module.static) {
	      Object.keys(module.static).forEach(function (key) {
	        Class[key] = module.static[key];
	      });
	    }
	    // Callback
	    if (module.install) {
	      module.install.apply(Class, params);
	    }
	    return Class;
	  };
	
	  SwiperClass.use = function use (module) {
	      var params = [], len = arguments.length - 1;
	      while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];
	
	    var Class = this;
	    if (Array.isArray(module)) {
	      module.forEach(function (m) { return Class.installModule(m); });
	      return Class;
	    }
	    return Class.installModule.apply(Class, [ module ].concat( params ));
	  };
	
	  Object.defineProperties( SwiperClass, staticAccessors );
	
	  function updateSize () {
	    var swiper = this;
	    var width;
	    var height;
	    var $el = swiper.$el;
	    if (typeof swiper.params.width !== 'undefined') {
	      width = swiper.params.width;
	    } else {
	      width = $el[0].clientWidth;
	    }
	    if (typeof swiper.params.height !== 'undefined') {
	      height = swiper.params.height;
	    } else {
	      height = $el[0].clientHeight;
	    }
	    if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
	      return;
	    }
	
	    // Subtract paddings
	    width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
	    height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);
	
	    Utils.extend(swiper, {
	      width: width,
	      height: height,
	      size: swiper.isHorizontal() ? width : height,
	    });
	  }
	
	  function updateSlides () {
	    var swiper = this;
	    var params = swiper.params;
	
	    var $wrapperEl = swiper.$wrapperEl;
	    var swiperSize = swiper.size;
	    var rtl = swiper.rtlTranslate;
	    var wrongRTL = swiper.wrongRTL;
	    var isVirtual = swiper.virtual && params.virtual.enabled;
	    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
	    var slides = $wrapperEl.children(("." + (swiper.params.slideClass)));
	    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
	    var snapGrid = [];
	    var slidesGrid = [];
	    var slidesSizesGrid = [];
	
	    var offsetBefore = params.slidesOffsetBefore;
	    if (typeof offsetBefore === 'function') {
	      offsetBefore = params.slidesOffsetBefore.call(swiper);
	    }
	
	    var offsetAfter = params.slidesOffsetAfter;
	    if (typeof offsetAfter === 'function') {
	      offsetAfter = params.slidesOffsetAfter.call(swiper);
	    }
	
	    var previousSnapGridLength = swiper.snapGrid.length;
	    var previousSlidesGridLength = swiper.snapGrid.length;
	
	    var spaceBetween = params.spaceBetween;
	    var slidePosition = -offsetBefore;
	    var prevSlideSize = 0;
	    var index = 0;
	    if (typeof swiperSize === 'undefined') {
	      return;
	    }
	    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	      spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
	    }
	
	    swiper.virtualSize = -spaceBetween;
	
	    // reset margins
	    if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }
	    else { slides.css({ marginRight: '', marginBottom: '' }); }
	
	    var slidesNumberEvenToRows;
	    if (params.slidesPerColumn > 1) {
	      if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
	        slidesNumberEvenToRows = slidesLength;
	      } else {
	        slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
	      }
	      if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
	        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
	      }
	    }
	
	    // Calc slides
	    var slideSize;
	    var slidesPerColumn = params.slidesPerColumn;
	    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
	    var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
	    for (var i = 0; i < slidesLength; i += 1) {
	      slideSize = 0;
	      var slide = slides.eq(i);
	      if (params.slidesPerColumn > 1) {
	        // Set slides order
	        var newSlideOrderIndex = (void 0);
	        var column = (void 0);
	        var row = (void 0);
	        if (params.slidesPerColumnFill === 'column') {
	          column = Math.floor(i / slidesPerColumn);
	          row = i - (column * slidesPerColumn);
	          if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
	            row += 1;
	            if (row >= slidesPerColumn) {
	              row = 0;
	              column += 1;
	            }
	          }
	          newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
	          slide
	            .css({
	              '-webkit-box-ordinal-group': newSlideOrderIndex,
	              '-moz-box-ordinal-group': newSlideOrderIndex,
	              '-ms-flex-order': newSlideOrderIndex,
	              '-webkit-order': newSlideOrderIndex,
	              order: newSlideOrderIndex,
	            });
	        } else {
	          row = Math.floor(i / slidesPerRow);
	          column = i - (row * slidesPerRow);
	        }
	        slide
	          .css(
	            ("margin-" + (swiper.isHorizontal() ? 'top' : 'left')),
	            (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + "px"))
	          )
	          .attr('data-swiper-column', column)
	          .attr('data-swiper-row', row);
	      }
	      if (slide.css('display') === 'none') { continue; } // eslint-disable-line
	
	      if (params.slidesPerView === 'auto') {
	        var slideStyles = win.getComputedStyle(slide[0], null);
	        var currentTransform = slide[0].style.transform;
	        var currentWebKitTransform = slide[0].style.webkitTransform;
	        if (currentTransform) {
	          slide[0].style.transform = 'none';
	        }
	        if (currentWebKitTransform) {
	          slide[0].style.webkitTransform = 'none';
	        }
	        if (params.roundLengths) {
	          slideSize = swiper.isHorizontal()
	            ? slide.outerWidth(true)
	            : slide.outerHeight(true);
	        } else {
	          // eslint-disable-next-line
	          if (swiper.isHorizontal()) {
	            var width = parseFloat(slideStyles.getPropertyValue('width'));
	            var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
	            var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
	            var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
	            var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
	            var boxSizing = slideStyles.getPropertyValue('box-sizing');
	            if (boxSizing && boxSizing === 'border-box') {
	              slideSize = width + marginLeft + marginRight;
	            } else {
	              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
	            }
	          } else {
	            var height = parseFloat(slideStyles.getPropertyValue('height'));
	            var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
	            var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
	            var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
	            var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
	            var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');
	            if (boxSizing$1 && boxSizing$1 === 'border-box') {
	              slideSize = height + marginTop + marginBottom;
	            } else {
	              slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
	            }
	          }
	        }
	        if (currentTransform) {
	          slide[0].style.transform = currentTransform;
	        }
	        if (currentWebKitTransform) {
	          slide[0].style.webkitTransform = currentWebKitTransform;
	        }
	        if (params.roundLengths) { slideSize = Math.floor(slideSize); }
	      } else {
	        slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
	        if (params.roundLengths) { slideSize = Math.floor(slideSize); }
	
	        if (slides[i]) {
	          if (swiper.isHorizontal()) {
	            slides[i].style.width = slideSize + "px";
	          } else {
	            slides[i].style.height = slideSize + "px";
	          }
	        }
	      }
	      if (slides[i]) {
	        slides[i].swiperSlideSize = slideSize;
	      }
	      slidesSizesGrid.push(slideSize);
	
	
	      if (params.centeredSlides) {
	        slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
	        if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
	        if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
	        if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }
	        if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
	        if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
	        slidesGrid.push(slidePosition);
	      } else {
	        if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }
	        if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
	        slidesGrid.push(slidePosition);
	        slidePosition = slidePosition + slideSize + spaceBetween;
	      }
	
	      swiper.virtualSize += slideSize + spaceBetween;
	
	      prevSlideSize = slideSize;
	
	      index += 1;
	    }
	    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
	    var newSlidesGrid;
	
	    if (
	      rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
	      $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") });
	    }
	    if (!Support.flexbox || params.setWrapperSize) {
	      if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	      else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	    }
	
	    if (params.slidesPerColumn > 1) {
	      swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
	      swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
	      if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	      else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	      if (params.centeredSlides) {
	        newSlidesGrid = [];
	        for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
	          var slidesGridItem = snapGrid[i$1];
	          if (params.roundLengths) { slidesGridItem = Math.floor(slidesGridItem); }
	          if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(slidesGridItem); }
	        }
	        snapGrid = newSlidesGrid;
	      }
	    }
	
	    // Remove last grid elements depending on width
	    if (!params.centeredSlides) {
	      newSlidesGrid = [];
	      for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
	        var slidesGridItem$1 = snapGrid[i$2];
	        if (params.roundLengths) { slidesGridItem$1 = Math.floor(slidesGridItem$1); }
	        if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
	          newSlidesGrid.push(slidesGridItem$1);
	        }
	      }
	      snapGrid = newSlidesGrid;
	      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
	        snapGrid.push(swiper.virtualSize - swiperSize);
	      }
	    }
	    if (snapGrid.length === 0) { snapGrid = [0]; }
	
	    if (params.spaceBetween !== 0) {
	      if (swiper.isHorizontal()) {
	        if (rtl) { slides.css({ marginLeft: (spaceBetween + "px") }); }
	        else { slides.css({ marginRight: (spaceBetween + "px") }); }
	      } else { slides.css({ marginBottom: (spaceBetween + "px") }); }
	    }
	
	    if (params.centerInsufficientSlides) {
	      var allSlidesSize = 0;
	      slidesSizesGrid.forEach(function (slideSizeValue) {
	        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
	      });
	      allSlidesSize -= params.spaceBetween;
	      if (allSlidesSize < swiperSize) {
	        var allSlidesOffset = (swiperSize - allSlidesSize) / 2;
	        snapGrid.forEach(function (snap, snapIndex) {
	          snapGrid[snapIndex] = snap - allSlidesOffset;
	        });
	        slidesGrid.forEach(function (snap, snapIndex) {
	          slidesGrid[snapIndex] = snap + allSlidesOffset;
	        });
	      }
	    }
	
	    Utils.extend(swiper, {
	      slides: slides,
	      snapGrid: snapGrid,
	      slidesGrid: slidesGrid,
	      slidesSizesGrid: slidesSizesGrid,
	    });
	
	    if (slidesLength !== previousSlidesLength) {
	      swiper.emit('slidesLengthChange');
	    }
	    if (snapGrid.length !== previousSnapGridLength) {
	      if (swiper.params.watchOverflow) { swiper.checkOverflow(); }
	      swiper.emit('snapGridLengthChange');
	    }
	    if (slidesGrid.length !== previousSlidesGridLength) {
	      swiper.emit('slidesGridLengthChange');
	    }
	
	    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
	      swiper.updateSlidesOffset();
	    }
	  }
	
	  function updateAutoHeight (speed) {
	    var swiper = this;
	    var activeSlides = [];
	    var newHeight = 0;
	    var i;
	    if (typeof speed === 'number') {
	      swiper.setTransition(speed);
	    } else if (speed === true) {
	      swiper.setTransition(swiper.params.speed);
	    }
	    // Find slides currently in view
	    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
	      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
	        var index = swiper.activeIndex + i;
	        if (index > swiper.slides.length) { break; }
	        activeSlides.push(swiper.slides.eq(index)[0]);
	      }
	    } else {
	      activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
	    }
	
	    // Find new height from highest slide in view
	    for (i = 0; i < activeSlides.length; i += 1) {
	      if (typeof activeSlides[i] !== 'undefined') {
	        var height = activeSlides[i].offsetHeight;
	        newHeight = height > newHeight ? height : newHeight;
	      }
	    }
	
	    // Update Height
	    if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + "px")); }
	  }
	
	  function updateSlidesOffset () {
	    var swiper = this;
	    var slides = swiper.slides;
	    for (var i = 0; i < slides.length; i += 1) {
	      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
	    }
	  }
	
	  function updateSlidesProgress (translate) {
	    if ( translate === void 0 ) translate = (this && this.translate) || 0;
	
	    var swiper = this;
	    var params = swiper.params;
	
	    var slides = swiper.slides;
	    var rtl = swiper.rtlTranslate;
	
	    if (slides.length === 0) { return; }
	    if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }
	
	    var offsetCenter = -translate;
	    if (rtl) { offsetCenter = translate; }
	
	    // Visible Slides
	    slides.removeClass(params.slideVisibleClass);
	
	    swiper.visibleSlidesIndexes = [];
	    swiper.visibleSlides = [];
	
	    for (var i = 0; i < slides.length; i += 1) {
	      var slide = slides[i];
	      var slideProgress = (
	        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
	      ) / (slide.swiperSlideSize + params.spaceBetween);
	      if (params.watchSlidesVisibility) {
	        var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
	        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
	        var isVisible = (slideBefore >= 0 && slideBefore < swiper.size)
	                  || (slideAfter > 0 && slideAfter <= swiper.size)
	                  || (slideBefore <= 0 && slideAfter >= swiper.size);
	        if (isVisible) {
	          swiper.visibleSlides.push(slide);
	          swiper.visibleSlidesIndexes.push(i);
	          slides.eq(i).addClass(params.slideVisibleClass);
	        }
	      }
	      slide.progress = rtl ? -slideProgress : slideProgress;
	    }
	    swiper.visibleSlides = $(swiper.visibleSlides);
	  }
	
	  function updateProgress (translate) {
	    if ( translate === void 0 ) translate = (this && this.translate) || 0;
	
	    var swiper = this;
	    var params = swiper.params;
	
	    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	    var progress = swiper.progress;
	    var isBeginning = swiper.isBeginning;
	    var isEnd = swiper.isEnd;
	    var wasBeginning = isBeginning;
	    var wasEnd = isEnd;
	    if (translatesDiff === 0) {
	      progress = 0;
	      isBeginning = true;
	      isEnd = true;
	    } else {
	      progress = (translate - swiper.minTranslate()) / (translatesDiff);
	      isBeginning = progress <= 0;
	      isEnd = progress >= 1;
	    }
	    Utils.extend(swiper, {
	      progress: progress,
	      isBeginning: isBeginning,
	      isEnd: isEnd,
	    });
	
	    if (params.watchSlidesProgress || params.watchSlidesVisibility) { swiper.updateSlidesProgress(translate); }
	
	    if (isBeginning && !wasBeginning) {
	      swiper.emit('reachBeginning toEdge');
	    }
	    if (isEnd && !wasEnd) {
	      swiper.emit('reachEnd toEdge');
	    }
	    if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
	      swiper.emit('fromEdge');
	    }
	
	    swiper.emit('progress', progress);
	  }
	
	  function updateSlidesClasses () {
	    var swiper = this;
	
	    var slides = swiper.slides;
	    var params = swiper.params;
	    var $wrapperEl = swiper.$wrapperEl;
	    var activeIndex = swiper.activeIndex;
	    var realIndex = swiper.realIndex;
	    var isVirtual = swiper.virtual && params.virtual.enabled;
	
	    slides.removeClass(((params.slideActiveClass) + " " + (params.slideNextClass) + " " + (params.slidePrevClass) + " " + (params.slideDuplicateActiveClass) + " " + (params.slideDuplicateNextClass) + " " + (params.slideDuplicatePrevClass)));
	
	    var activeSlide;
	    if (isVirtual) {
	      activeSlide = swiper.$wrapperEl.find(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + activeIndex + "\"]"));
	    } else {
	      activeSlide = slides.eq(activeIndex);
	    }
	
	    // Active classes
	    activeSlide.addClass(params.slideActiveClass);
	
	    if (params.loop) {
	      // Duplicate to all looped slides
	      if (activeSlide.hasClass(params.slideDuplicateClass)) {
	        $wrapperEl
	          .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + realIndex + "\"]"))
	          .addClass(params.slideDuplicateActiveClass);
	      } else {
	        $wrapperEl
	          .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]"))
	          .addClass(params.slideDuplicateActiveClass);
	      }
	    }
	    // Next Slide
	    var nextSlide = activeSlide.nextAll(("." + (params.slideClass))).eq(0).addClass(params.slideNextClass);
	    if (params.loop && nextSlide.length === 0) {
	      nextSlide = slides.eq(0);
	      nextSlide.addClass(params.slideNextClass);
	    }
	    // Prev Slide
	    var prevSlide = activeSlide.prevAll(("." + (params.slideClass))).eq(0).addClass(params.slidePrevClass);
	    if (params.loop && prevSlide.length === 0) {
	      prevSlide = slides.eq(-1);
	      prevSlide.addClass(params.slidePrevClass);
	    }
	    if (params.loop) {
	      // Duplicate to all looped slides
	      if (nextSlide.hasClass(params.slideDuplicateClass)) {
	        $wrapperEl
	          .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
	          .addClass(params.slideDuplicateNextClass);
	      } else {
	        $wrapperEl
	          .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
	          .addClass(params.slideDuplicateNextClass);
	      }
	      if (prevSlide.hasClass(params.slideDuplicateClass)) {
	        $wrapperEl
	          .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
	          .addClass(params.slideDuplicatePrevClass);
	      } else {
	        $wrapperEl
	          .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
	          .addClass(params.slideDuplicatePrevClass);
	      }
	    }
	  }
	
	  function updateActiveIndex (newActiveIndex) {
	    var swiper = this;
	    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	    var slidesGrid = swiper.slidesGrid;
	    var snapGrid = swiper.snapGrid;
	    var params = swiper.params;
	    var previousIndex = swiper.activeIndex;
	    var previousRealIndex = swiper.realIndex;
	    var previousSnapIndex = swiper.snapIndex;
	    var activeIndex = newActiveIndex;
	    var snapIndex;
	    if (typeof activeIndex === 'undefined') {
	      for (var i = 0; i < slidesGrid.length; i += 1) {
	        if (typeof slidesGrid[i + 1] !== 'undefined') {
	          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
	            activeIndex = i;
	          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
	            activeIndex = i + 1;
	          }
	        } else if (translate >= slidesGrid[i]) {
	          activeIndex = i;
	        }
	      }
	      // Normalize slideIndex
	      if (params.normalizeSlideIndex) {
	        if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }
	      }
	    }
	    if (snapGrid.indexOf(translate) >= 0) {
	      snapIndex = snapGrid.indexOf(translate);
	    } else {
	      snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
	    }
	    if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }
	    if (activeIndex === previousIndex) {
	      if (snapIndex !== previousSnapIndex) {
	        swiper.snapIndex = snapIndex;
	        swiper.emit('snapIndexChange');
	      }
	      return;
	    }
	
	    // Get real index
	    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
	
	    Utils.extend(swiper, {
	      snapIndex: snapIndex,
	      realIndex: realIndex,
	      previousIndex: previousIndex,
	      activeIndex: activeIndex,
	    });
	    swiper.emit('activeIndexChange');
	    swiper.emit('snapIndexChange');
	    if (previousRealIndex !== realIndex) {
	      swiper.emit('realIndexChange');
	    }
	    swiper.emit('slideChange');
	  }
	
	  function updateClickedSlide (e) {
	    var swiper = this;
	    var params = swiper.params;
	    var slide = $(e.target).closest(("." + (params.slideClass)))[0];
	    var slideFound = false;
	    if (slide) {
	      for (var i = 0; i < swiper.slides.length; i += 1) {
	        if (swiper.slides[i] === slide) { slideFound = true; }
	      }
	    }
	
	    if (slide && slideFound) {
	      swiper.clickedSlide = slide;
	      if (swiper.virtual && swiper.params.virtual.enabled) {
	        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
	      } else {
	        swiper.clickedIndex = $(slide).index();
	      }
	    } else {
	      swiper.clickedSlide = undefined;
	      swiper.clickedIndex = undefined;
	      return;
	    }
	    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
	      swiper.slideToClickedSlide();
	    }
	  }
	
	  var update = {
	    updateSize: updateSize,
	    updateSlides: updateSlides,
	    updateAutoHeight: updateAutoHeight,
	    updateSlidesOffset: updateSlidesOffset,
	    updateSlidesProgress: updateSlidesProgress,
	    updateProgress: updateProgress,
	    updateSlidesClasses: updateSlidesClasses,
	    updateActiveIndex: updateActiveIndex,
	    updateClickedSlide: updateClickedSlide,
	  };
	
	  function getTranslate (axis) {
	    if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';
	
	    var swiper = this;
	
	    var params = swiper.params;
	    var rtl = swiper.rtlTranslate;
	    var translate = swiper.translate;
	    var $wrapperEl = swiper.$wrapperEl;
	
	    if (params.virtualTranslate) {
	      return rtl ? -translate : translate;
	    }
	
	    var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
	    if (rtl) { currentTranslate = -currentTranslate; }
	
	    return currentTranslate || 0;
	  }
	
	  function setTranslate (translate, byController) {
	    var swiper = this;
	    var rtl = swiper.rtlTranslate;
	    var params = swiper.params;
	    var $wrapperEl = swiper.$wrapperEl;
	    var progress = swiper.progress;
	    var x = 0;
	    var y = 0;
	    var z = 0;
	
	    if (swiper.isHorizontal()) {
	      x = rtl ? -translate : translate;
	    } else {
	      y = translate;
	    }
	
	    if (params.roundLengths) {
	      x = Math.floor(x);
	      y = Math.floor(y);
	    }
	
	    if (!params.virtualTranslate) {
	      if (Support.transforms3d) { $wrapperEl.transform(("translate3d(" + x + "px, " + y + "px, " + z + "px)")); }
	      else { $wrapperEl.transform(("translate(" + x + "px, " + y + "px)")); }
	    }
	    swiper.previousTranslate = swiper.translate;
	    swiper.translate = swiper.isHorizontal() ? x : y;
	
	    // Check if we need to update progress
	    var newProgress;
	    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	    if (translatesDiff === 0) {
	      newProgress = 0;
	    } else {
	      newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
	    }
	    if (newProgress !== progress) {
	      swiper.updateProgress(translate);
	    }
	
	    swiper.emit('setTranslate', swiper.translate, byController);
	  }
	
	  function minTranslate () {
	    return (-this.snapGrid[0]);
	  }
	
	  function maxTranslate () {
	    return (-this.snapGrid[this.snapGrid.length - 1]);
	  }
	
	  var translate = {
	    getTranslate: getTranslate,
	    setTranslate: setTranslate,
	    minTranslate: minTranslate,
	    maxTranslate: maxTranslate,
	  };
	
	  function setTransition (duration, byController) {
	    var swiper = this;
	
	    swiper.$wrapperEl.transition(duration);
	
	    swiper.emit('setTransition', duration, byController);
	  }
	
	  function transitionStart (runCallbacks, direction) {
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    var activeIndex = swiper.activeIndex;
	    var params = swiper.params;
	    var previousIndex = swiper.previousIndex;
	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	
	    var dir = direction;
	    if (!dir) {
	      if (activeIndex > previousIndex) { dir = 'next'; }
	      else if (activeIndex < previousIndex) { dir = 'prev'; }
	      else { dir = 'reset'; }
	    }
	
	    swiper.emit('transitionStart');
	
	    if (runCallbacks && activeIndex !== previousIndex) {
	      if (dir === 'reset') {
	        swiper.emit('slideResetTransitionStart');
	        return;
	      }
	      swiper.emit('slideChangeTransitionStart');
	      if (dir === 'next') {
	        swiper.emit('slideNextTransitionStart');
	      } else {
	        swiper.emit('slidePrevTransitionStart');
	      }
	    }
	  }
	
	  function transitionEnd$1 (runCallbacks, direction) {
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    var activeIndex = swiper.activeIndex;
	    var previousIndex = swiper.previousIndex;
	    swiper.animating = false;
	    swiper.setTransition(0);
	
	    var dir = direction;
	    if (!dir) {
	      if (activeIndex > previousIndex) { dir = 'next'; }
	      else if (activeIndex < previousIndex) { dir = 'prev'; }
	      else { dir = 'reset'; }
	    }
	
	    swiper.emit('transitionEnd');
	
	    if (runCallbacks && activeIndex !== previousIndex) {
	      if (dir === 'reset') {
	        swiper.emit('slideResetTransitionEnd');
	        return;
	      }
	      swiper.emit('slideChangeTransitionEnd');
	      if (dir === 'next') {
	        swiper.emit('slideNextTransitionEnd');
	      } else {
	        swiper.emit('slidePrevTransitionEnd');
	      }
	    }
	  }
	
	  var transition$1 = {
	    setTransition: setTransition,
	    transitionStart: transitionStart,
	    transitionEnd: transitionEnd$1,
	  };
	
	  function slideTo (index, speed, runCallbacks, internal) {
	    if ( index === void 0 ) index = 0;
	    if ( speed === void 0 ) speed = this.params.speed;
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    var slideIndex = index;
	    if (slideIndex < 0) { slideIndex = 0; }
	
	    var params = swiper.params;
	    var snapGrid = swiper.snapGrid;
	    var slidesGrid = swiper.slidesGrid;
	    var previousIndex = swiper.previousIndex;
	    var activeIndex = swiper.activeIndex;
	    var rtl = swiper.rtlTranslate;
	    if (swiper.animating && params.preventInteractionOnTransition) {
	      return false;
	    }
	
	    var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
	    if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }
	
	    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
	      swiper.emit('beforeSlideChangeStart');
	    }
	
	    var translate = -snapGrid[snapIndex];
	
	    // Update progress
	    swiper.updateProgress(translate);
	
	    // Normalize slideIndex
	    if (params.normalizeSlideIndex) {
	      for (var i = 0; i < slidesGrid.length; i += 1) {
	        if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
	          slideIndex = i;
	        }
	      }
	    }
	    // Directions locks
	    if (swiper.initialized && slideIndex !== activeIndex) {
	      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
	        return false;
	      }
	      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
	        if ((activeIndex || 0) !== slideIndex) { return false; }
	      }
	    }
	
	    var direction;
	    if (slideIndex > activeIndex) { direction = 'next'; }
	    else if (slideIndex < activeIndex) { direction = 'prev'; }
	    else { direction = 'reset'; }
	
	
	    // Update Index
	    if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
	      swiper.updateActiveIndex(slideIndex);
	      // Update Height
	      if (params.autoHeight) {
	        swiper.updateAutoHeight();
	      }
	      swiper.updateSlidesClasses();
	      if (params.effect !== 'slide') {
	        swiper.setTranslate(translate);
	      }
	      if (direction !== 'reset') {
	        swiper.transitionStart(runCallbacks, direction);
	        swiper.transitionEnd(runCallbacks, direction);
	      }
	      return false;
	    }
	
	    if (speed === 0 || !Support.transition) {
	      swiper.setTransition(0);
	      swiper.setTranslate(translate);
	      swiper.updateActiveIndex(slideIndex);
	      swiper.updateSlidesClasses();
	      swiper.emit('beforeTransitionStart', speed, internal);
	      swiper.transitionStart(runCallbacks, direction);
	      swiper.transitionEnd(runCallbacks, direction);
	    } else {
	      swiper.setTransition(speed);
	      swiper.setTranslate(translate);
	      swiper.updateActiveIndex(slideIndex);
	      swiper.updateSlidesClasses();
	      swiper.emit('beforeTransitionStart', speed, internal);
	      swiper.transitionStart(runCallbacks, direction);
	      if (!swiper.animating) {
	        swiper.animating = true;
	        if (!swiper.onSlideToWrapperTransitionEnd) {
	          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
	            if (!swiper || swiper.destroyed) { return; }
	            if (e.target !== this) { return; }
	            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	            swiper.onSlideToWrapperTransitionEnd = null;
	            delete swiper.onSlideToWrapperTransitionEnd;
	            swiper.transitionEnd(runCallbacks, direction);
	          };
	        }
	        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
	        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
	      }
	    }
	
	    return true;
	  }
	
	  function slideToLoop (index, speed, runCallbacks, internal) {
	    if ( index === void 0 ) index = 0;
	    if ( speed === void 0 ) speed = this.params.speed;
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    var newIndex = index;
	    if (swiper.params.loop) {
	      newIndex += swiper.loopedSlides;
	    }
	
	    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
	  }
	
	  /* eslint no-unused-vars: "off" */
	  function slideNext (speed, runCallbacks, internal) {
	    if ( speed === void 0 ) speed = this.params.speed;
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    var params = swiper.params;
	    var animating = swiper.animating;
	    if (params.loop) {
	      if (animating) { return false; }
	      swiper.loopFix();
	      // eslint-disable-next-line
	      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	      return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	    }
	    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	  }
	
	  /* eslint no-unused-vars: "off" */
	  function slidePrev (speed, runCallbacks, internal) {
	    if ( speed === void 0 ) speed = this.params.speed;
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    var params = swiper.params;
	    var animating = swiper.animating;
	    var snapGrid = swiper.snapGrid;
	    var slidesGrid = swiper.slidesGrid;
	    var rtlTranslate = swiper.rtlTranslate;
	
	    if (params.loop) {
	      if (animating) { return false; }
	      swiper.loopFix();
	      // eslint-disable-next-line
	      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	    }
	    var translate = rtlTranslate ? swiper.translate : -swiper.translate;
	    function normalize(val) {
	      if (val < 0) { return -Math.floor(Math.abs(val)); }
	      return Math.floor(val);
	    }
	    var normalizedTranslate = normalize(translate);
	    var normalizedSnapGrid = snapGrid.map(function (val) { return normalize(val); });
	    var normalizedSlidesGrid = slidesGrid.map(function (val) { return normalize(val); });
	
	    var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
	    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
	    var prevIndex;
	    if (typeof prevSnap !== 'undefined') {
	      prevIndex = slidesGrid.indexOf(prevSnap);
	      if (prevIndex < 0) { prevIndex = swiper.activeIndex - 1; }
	    }
	    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
	  }
	
	  /* eslint no-unused-vars: "off" */
	  function slideReset (speed, runCallbacks, internal) {
	    if ( speed === void 0 ) speed = this.params.speed;
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	  }
	
	  /* eslint no-unused-vars: "off" */
	  function slideToClosest (speed, runCallbacks, internal) {
	    if ( speed === void 0 ) speed = this.params.speed;
	    if ( runCallbacks === void 0 ) runCallbacks = true;
	
	    var swiper = this;
	    var index = swiper.activeIndex;
	    var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);
	
	    if (snapIndex < swiper.snapGrid.length - 1) {
	      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
	
	      var currentSnap = swiper.snapGrid[snapIndex];
	      var nextSnap = swiper.snapGrid[snapIndex + 1];
	
	      if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {
	        index = swiper.params.slidesPerGroup;
	      }
	    }
	
	    return swiper.slideTo(index, speed, runCallbacks, internal);
	  }
	
	  function slideToClickedSlide () {
	    var swiper = this;
	    var params = swiper.params;
	    var $wrapperEl = swiper.$wrapperEl;
	
	    var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
	    var slideToIndex = swiper.clickedIndex;
	    var realIndex;
	    if (params.loop) {
	      if (swiper.animating) { return; }
	      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
	      if (params.centeredSlides) {
	        if (
	          (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
	          || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
	        ) {
	          swiper.loopFix();
	          slideToIndex = $wrapperEl
	            .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
	            .eq(0)
	            .index();
	
	          Utils.nextTick(function () {
	            swiper.slideTo(slideToIndex);
	          });
	        } else {
	          swiper.slideTo(slideToIndex);
	        }
	      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
	        swiper.loopFix();
	        slideToIndex = $wrapperEl
	          .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
	          .eq(0)
	          .index();
	
	        Utils.nextTick(function () {
	          swiper.slideTo(slideToIndex);
	        });
	      } else {
	        swiper.slideTo(slideToIndex);
	      }
	    } else {
	      swiper.slideTo(slideToIndex);
	    }
	  }
	
	  var slide = {
	    slideTo: slideTo,
	    slideToLoop: slideToLoop,
	    slideNext: slideNext,
	    slidePrev: slidePrev,
	    slideReset: slideReset,
	    slideToClosest: slideToClosest,
	    slideToClickedSlide: slideToClickedSlide,
	  };
	
	  function loopCreate () {
	    var swiper = this;
	    var params = swiper.params;
	    var $wrapperEl = swiper.$wrapperEl;
	    // Remove duplicated slides
	    $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();
	
	    var slides = $wrapperEl.children(("." + (params.slideClass)));
	
	    if (params.loopFillGroupWithBlank) {
	      var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
	      if (blankSlidesNum !== params.slidesPerGroup) {
	        for (var i = 0; i < blankSlidesNum; i += 1) {
	          var blankNode = $(doc.createElement('div')).addClass(((params.slideClass) + " " + (params.slideBlankClass)));
	          $wrapperEl.append(blankNode);
	        }
	        slides = $wrapperEl.children(("." + (params.slideClass)));
	      }
	    }
	
	    if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }
	
	    swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
	    swiper.loopedSlides += params.loopAdditionalSlides;
	    if (swiper.loopedSlides > slides.length) {
	      swiper.loopedSlides = slides.length;
	    }
	
	    var prependSlides = [];
	    var appendSlides = [];
	    slides.each(function (index, el) {
	      var slide = $(el);
	      if (index < swiper.loopedSlides) { appendSlides.push(el); }
	      if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }
	      slide.attr('data-swiper-slide-index', index);
	    });
	    for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
	      $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
	    }
	    for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
	      $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
	    }
	  }
	
	  function loopFix () {
	    var swiper = this;
	    var params = swiper.params;
	    var activeIndex = swiper.activeIndex;
	    var slides = swiper.slides;
	    var loopedSlides = swiper.loopedSlides;
	    var allowSlidePrev = swiper.allowSlidePrev;
	    var allowSlideNext = swiper.allowSlideNext;
	    var snapGrid = swiper.snapGrid;
	    var rtl = swiper.rtlTranslate;
	    var newIndex;
	    swiper.allowSlidePrev = true;
	    swiper.allowSlideNext = true;
	
	    var snapTranslate = -snapGrid[activeIndex];
	    var diff = snapTranslate - swiper.getTranslate();
	
	
	    // Fix For Negative Oversliding
	    if (activeIndex < loopedSlides) {
	      newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
	      newIndex += loopedSlides;
	      var slideChanged = swiper.slideTo(newIndex, 0, false, true);
	      if (slideChanged && diff !== 0) {
	        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	      }
	    } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {
	      // Fix For Positive Oversliding
	      newIndex = -slides.length + activeIndex + loopedSlides;
	      newIndex += loopedSlides;
	      var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);
	      if (slideChanged$1 && diff !== 0) {
	        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
	      }
	    }
	    swiper.allowSlidePrev = allowSlidePrev;
	    swiper.allowSlideNext = allowSlideNext;
	  }
	
	  function loopDestroy () {
	    var swiper = this;
	    var $wrapperEl = swiper.$wrapperEl;
	    var params = swiper.params;
	    var slides = swiper.slides;
	    $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + ",." + (params.slideClass) + "." + (params.slideBlankClass))).remove();
	    slides.removeAttr('data-swiper-slide-index');
	  }
	
	  var loop = {
	    loopCreate: loopCreate,
	    loopFix: loopFix,
	    loopDestroy: loopDestroy,
	  };
	
	  function setGrabCursor (moving) {
	    var swiper = this;
	    if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }
	    var el = swiper.el;
	    el.style.cursor = 'move';
	    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
	    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
	    el.style.cursor = moving ? 'grabbing' : 'grab';
	  }
	
	  function unsetGrabCursor () {
	    var swiper = this;
	    if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }
	    swiper.el.style.cursor = '';
	  }
	
	  var grabCursor = {
	    setGrabCursor: setGrabCursor,
	    unsetGrabCursor: unsetGrabCursor,
	  };
	
	  function appendSlide (slides) {
	    var swiper = this;
	    var $wrapperEl = swiper.$wrapperEl;
	    var params = swiper.params;
	    if (params.loop) {
	      swiper.loopDestroy();
	    }
	    if (typeof slides === 'object' && 'length' in slides) {
	      for (var i = 0; i < slides.length; i += 1) {
	        if (slides[i]) { $wrapperEl.append(slides[i]); }
	      }
	    } else {
	      $wrapperEl.append(slides);
	    }
	    if (params.loop) {
	      swiper.loopCreate();
	    }
	    if (!(params.observer && Support.observer)) {
	      swiper.update();
	    }
	  }
	
	  function prependSlide (slides) {
	    var swiper = this;
	    var params = swiper.params;
	    var $wrapperEl = swiper.$wrapperEl;
	    var activeIndex = swiper.activeIndex;
	
	    if (params.loop) {
	      swiper.loopDestroy();
	    }
	    var newActiveIndex = activeIndex + 1;
	    if (typeof slides === 'object' && 'length' in slides) {
	      for (var i = 0; i < slides.length; i += 1) {
	        if (slides[i]) { $wrapperEl.prepend(slides[i]); }
	      }
	      newActiveIndex = activeIndex + slides.length;
	    } else {
	      $wrapperEl.prepend(slides);
	    }
	    if (params.loop) {
	      swiper.loopCreate();
	    }
	    if (!(params.observer && Support.observer)) {
	      swiper.update();
	    }
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	
	  function addSlide (index, slides) {
	    var swiper = this;
	    var $wrapperEl = swiper.$wrapperEl;
	    var params = swiper.params;
	    var activeIndex = swiper.activeIndex;
	    var activeIndexBuffer = activeIndex;
	    if (params.loop) {
	      activeIndexBuffer -= swiper.loopedSlides;
	      swiper.loopDestroy();
	      swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
	    }
	    var baseLength = swiper.slides.length;
	    if (index <= 0) {
	      swiper.prependSlide(slides);
	      return;
	    }
	    if (index >= baseLength) {
	      swiper.appendSlide(slides);
	      return;
	    }
	    var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
	
	    var slidesBuffer = [];
	    for (var i = baseLength - 1; i >= index; i -= 1) {
	      var currentSlide = swiper.slides.eq(i);
	      currentSlide.remove();
	      slidesBuffer.unshift(currentSlide);
	    }
	
	    if (typeof slides === 'object' && 'length' in slides) {
	      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
	        if (slides[i$1]) { $wrapperEl.append(slides[i$1]); }
	      }
	      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
	    } else {
	      $wrapperEl.append(slides);
	    }
	
	    for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
	      $wrapperEl.append(slidesBuffer[i$2]);
	    }
	
	    if (params.loop) {
	      swiper.loopCreate();
	    }
	    if (!(params.observer && Support.observer)) {
	      swiper.update();
	    }
	    if (params.loop) {
	      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	    } else {
	      swiper.slideTo(newActiveIndex, 0, false);
	    }
	  }
	
	  function removeSlide (slidesIndexes) {
	    var swiper = this;
	    var params = swiper.params;
	    var $wrapperEl = swiper.$wrapperEl;
	    var activeIndex = swiper.activeIndex;
	
	    var activeIndexBuffer = activeIndex;
	    if (params.loop) {
	      activeIndexBuffer -= swiper.loopedSlides;
	      swiper.loopDestroy();
	      swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
	    }
	    var newActiveIndex = activeIndexBuffer;
	    var indexToRemove;
	
	    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
	      for (var i = 0; i < slidesIndexes.length; i += 1) {
	        indexToRemove = slidesIndexes[i];
	        if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
	        if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
	      }
	      newActiveIndex = Math.max(newActiveIndex, 0);
	    } else {
	      indexToRemove = slidesIndexes;
	      if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
	      if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
	      newActiveIndex = Math.max(newActiveIndex, 0);
	    }
	
	    if (params.loop) {
	      swiper.loopCreate();
	    }
	
	    if (!(params.observer && Support.observer)) {
	      swiper.update();
	    }
	    if (params.loop) {
	      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	    } else {
	      swiper.slideTo(newActiveIndex, 0, false);
	    }
	  }
	
	  function removeAllSlides () {
	    var swiper = this;
	
	    var slidesIndexes = [];
	    for (var i = 0; i < swiper.slides.length; i += 1) {
	      slidesIndexes.push(i);
	    }
	    swiper.removeSlide(slidesIndexes);
	  }
	
	  var manipulation = {
	    appendSlide: appendSlide,
	    prependSlide: prependSlide,
	    addSlide: addSlide,
	    removeSlide: removeSlide,
	    removeAllSlides: removeAllSlides,
	  };
	
	  var Device = (function Device() {
	    var ua = win.navigator.userAgent;
	
	    var device = {
	      ios: false,
	      android: false,
	      androidChrome: false,
	      desktop: false,
	      windows: false,
	      iphone: false,
	      ipod: false,
	      ipad: false,
	      cordova: win.cordova || win.phonegap,
	      phonegap: win.cordova || win.phonegap,
	    };
	
	    var windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	    var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	    var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
	
	
	    // Windows
	    if (windows) {
	      device.os = 'windows';
	      device.osVersion = windows[2];
	      device.windows = true;
	    }
	    // Android
	    if (android && !windows) {
	      device.os = 'android';
	      device.osVersion = android[2];
	      device.android = true;
	      device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
	    }
	    if (ipad || iphone || ipod) {
	      device.os = 'ios';
	      device.ios = true;
	    }
	    // iOS
	    if (iphone && !ipod) {
	      device.osVersion = iphone[2].replace(/_/g, '.');
	      device.iphone = true;
	    }
	    if (ipad) {
	      device.osVersion = ipad[2].replace(/_/g, '.');
	      device.ipad = true;
	    }
	    if (ipod) {
	      device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	      device.iphone = true;
	    }
	    // iOS 8+ changed UA
	    if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
	      if (device.osVersion.split('.')[0] === '10') {
	        device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
	      }
	    }
	
	    // Desktop
	    device.desktop = !(device.os || device.android || device.webView);
	
	    // Webview
	    device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);
	
	    // Minimal UI
	    if (device.os && device.os === 'ios') {
	      var osVersionArr = device.osVersion.split('.');
	      var metaViewport = doc.querySelector('meta[name="viewport"]');
	      device.minimalUi = !device.webView
	        && (ipod || iphone)
	        && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)
	        && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
	    }
	
	    // Pixel Ratio
	    device.pixelRatio = win.devicePixelRatio || 1;
	
	    // Export object
	    return device;
	  }());
	
	  function onTouchStart (event) {
	    var swiper = this;
	    var data = swiper.touchEventsData;
	    var params = swiper.params;
	    var touches = swiper.touches;
	    if (swiper.animating && params.preventInteractionOnTransition) {
	      return;
	    }
	    var e = event;
	    if (e.originalEvent) { e = e.originalEvent; }
	    data.isTouchEvent = e.type === 'touchstart';
	    if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }
	    if (!data.isTouchEvent && 'button' in e && e.button > 0) { return; }
	    if (data.isTouched && data.isMoved) { return; }
	    if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : ("." + (params.noSwipingClass)))[0]) {
	      swiper.allowClick = true;
	      return;
	    }
	    if (params.swipeHandler) {
	      if (!$(e).closest(params.swipeHandler)[0]) { return; }
	    }
	
	    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    var startX = touches.currentX;
	    var startY = touches.currentY;
	
	    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
	
	    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
	    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
	    if (
	      edgeSwipeDetection
	      && ((startX <= edgeSwipeThreshold)
	      || (startX >= win.screen.width - edgeSwipeThreshold))
	    ) {
	      return;
	    }
	
	    Utils.extend(data, {
	      isTouched: true,
	      isMoved: false,
	      allowTouchCallbacks: true,
	      isScrolling: undefined,
	      startMoving: undefined,
	    });
	
	    touches.startX = startX;
	    touches.startY = startY;
	    data.touchStartTime = Utils.now();
	    swiper.allowClick = true;
	    swiper.updateSize();
	    swiper.swipeDirection = undefined;
	    if (params.threshold > 0) { data.allowThresholdMove = false; }
	    if (e.type !== 'touchstart') {
	      var preventDefault = true;
	      if ($(e.target).is(data.formElements)) { preventDefault = false; }
	      if (
	        doc.activeElement
	        && $(doc.activeElement).is(data.formElements)
	        && doc.activeElement !== e.target
	      ) {
	        doc.activeElement.blur();
	      }
	
	      var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
	      if (params.touchStartForcePreventDefault || shouldPreventDefault) {
	        e.preventDefault();
	      }
	    }
	    swiper.emit('touchStart', e);
	  }
	
	  function onTouchMove (event) {
	    var swiper = this;
	    var data = swiper.touchEventsData;
	    var params = swiper.params;
	    var touches = swiper.touches;
	    var rtl = swiper.rtlTranslate;
	    var e = event;
	    if (e.originalEvent) { e = e.originalEvent; }
	    if (!data.isTouched) {
	      if (data.startMoving && data.isScrolling) {
	        swiper.emit('touchMoveOpposite', e);
	      }
	      return;
	    }
	    if (data.isTouchEvent && e.type === 'mousemove') { return; }
	    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (e.preventedByNestedSwiper) {
	      touches.startX = pageX;
	      touches.startY = pageY;
	      return;
	    }
	    if (!swiper.allowTouchMove) {
	      // isMoved = true;
	      swiper.allowClick = false;
	      if (data.isTouched) {
	        Utils.extend(touches, {
	          startX: pageX,
	          startY: pageY,
	          currentX: pageX,
	          currentY: pageY,
	        });
	        data.touchStartTime = Utils.now();
	      }
	      return;
	    }
	    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
	      if (swiper.isVertical()) {
	        // Vertical
	        if (
	          (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
	          || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
	        ) {
	          data.isTouched = false;
	          data.isMoved = false;
	          return;
	        }
	      } else if (
	        (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
	        || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
	      ) {
	        return;
	      }
	    }
	    if (data.isTouchEvent && doc.activeElement) {
	      if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
	        data.isMoved = true;
	        swiper.allowClick = false;
	        return;
	      }
	    }
	    if (data.allowTouchCallbacks) {
	      swiper.emit('touchMove', e);
	    }
	    if (e.targetTouches && e.targetTouches.length > 1) { return; }
	
	    touches.currentX = pageX;
	    touches.currentY = pageY;
	
	    var diffX = touches.currentX - touches.startX;
	    var diffY = touches.currentY - touches.startY;
	    if (swiper.params.threshold && Math.sqrt((Math.pow( diffX, 2 )) + (Math.pow( diffY, 2 ))) < swiper.params.threshold) { return; }
	
	    if (typeof data.isScrolling === 'undefined') {
	      var touchAngle;
	      if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
	        data.isScrolling = false;
	      } else {
	        // eslint-disable-next-line
	        if ((diffX * diffX) + (diffY * diffY) >= 25) {
	          touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
	          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
	        }
	      }
	    }
	    if (data.isScrolling) {
	      swiper.emit('touchMoveOpposite', e);
	    }
	    if (typeof data.startMoving === 'undefined') {
	      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
	        data.startMoving = true;
	      }
	    }
	    if (data.isScrolling) {
	      data.isTouched = false;
	      return;
	    }
	    if (!data.startMoving) {
	      return;
	    }
	    swiper.allowClick = false;
	    e.preventDefault();
	    if (params.touchMoveStopPropagation && !params.nested) {
	      e.stopPropagation();
	    }
	
	    if (!data.isMoved) {
	      if (params.loop) {
	        swiper.loopFix();
	      }
	      data.startTranslate = swiper.getTranslate();
	      swiper.setTransition(0);
	      if (swiper.animating) {
	        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
	      }
	      data.allowMomentumBounce = false;
	      // Grab Cursor
	      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	        swiper.setGrabCursor(true);
	      }
	      swiper.emit('sliderFirstMove', e);
	    }
	    swiper.emit('sliderMove', e);
	    data.isMoved = true;
	
	    var diff = swiper.isHorizontal() ? diffX : diffY;
	    touches.diff = diff;
	
	    diff *= params.touchRatio;
	    if (rtl) { diff = -diff; }
	
	    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
	    data.currentTranslate = diff + data.startTranslate;
	
	    var disableParentSwiper = true;
	    var resistanceRatio = params.resistanceRatio;
	    if (params.touchReleaseOnEdges) {
	      resistanceRatio = 0;
	    }
	    if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
	      disableParentSwiper = false;
	      if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }
	    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
	      disableParentSwiper = false;
	      if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }
	    }
	
	    if (disableParentSwiper) {
	      e.preventedByNestedSwiper = true;
	    }
	
	    // Directions locks
	    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
	      data.currentTranslate = data.startTranslate;
	    }
	    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
	      data.currentTranslate = data.startTranslate;
	    }
	
	
	    // Threshold
	    if (params.threshold > 0) {
	      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
	        if (!data.allowThresholdMove) {
	          data.allowThresholdMove = true;
	          touches.startX = touches.currentX;
	          touches.startY = touches.currentY;
	          data.currentTranslate = data.startTranslate;
	          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
	          return;
	        }
	      } else {
	        data.currentTranslate = data.startTranslate;
	        return;
	      }
	    }
	
	    if (!params.followFinger) { return; }
	
	    // Update active index in free mode
	    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    if (params.freeMode) {
	      // Velocity
	      if (data.velocities.length === 0) {
	        data.velocities.push({
	          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
	          time: data.touchStartTime,
	        });
	      }
	      data.velocities.push({
	        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
	        time: Utils.now(),
	      });
	    }
	    // Update progress
	    swiper.updateProgress(data.currentTranslate);
	    // Update translate
	    swiper.setTranslate(data.currentTranslate);
	  }
	
	  function onTouchEnd (event) {
	    var swiper = this;
	    var data = swiper.touchEventsData;
	
	    var params = swiper.params;
	    var touches = swiper.touches;
	    var rtl = swiper.rtlTranslate;
	    var $wrapperEl = swiper.$wrapperEl;
	    var slidesGrid = swiper.slidesGrid;
	    var snapGrid = swiper.snapGrid;
	    var e = event;
	    if (e.originalEvent) { e = e.originalEvent; }
	    if (data.allowTouchCallbacks) {
	      swiper.emit('touchEnd', e);
	    }
	    data.allowTouchCallbacks = false;
	    if (!data.isTouched) {
	      if (data.isMoved && params.grabCursor) {
	        swiper.setGrabCursor(false);
	      }
	      data.isMoved = false;
	      data.startMoving = false;
	      return;
	    }
	    // Return Grab Cursor
	    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	      swiper.setGrabCursor(false);
	    }
	
	    // Time diff
	    var touchEndTime = Utils.now();
	    var timeDiff = touchEndTime - data.touchStartTime;
	
	    // Tap, doubleTap, Click
	    if (swiper.allowClick) {
	      swiper.updateClickedSlide(e);
	      swiper.emit('tap', e);
	      if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {
	        if (data.clickTimeout) { clearTimeout(data.clickTimeout); }
	        data.clickTimeout = Utils.nextTick(function () {
	          if (!swiper || swiper.destroyed) { return; }
	          swiper.emit('click', e);
	        }, 300);
	      }
	      if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
	        if (data.clickTimeout) { clearTimeout(data.clickTimeout); }
	        swiper.emit('doubleTap', e);
	      }
	    }
	
	    data.lastClickTime = Utils.now();
	    Utils.nextTick(function () {
	      if (!swiper.destroyed) { swiper.allowClick = true; }
	    });
	
	    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
	      data.isTouched = false;
	      data.isMoved = false;
	      data.startMoving = false;
	      return;
	    }
	    data.isTouched = false;
	    data.isMoved = false;
	    data.startMoving = false;
	
	    var currentPos;
	    if (params.followFinger) {
	      currentPos = rtl ? swiper.translate : -swiper.translate;
	    } else {
	      currentPos = -data.currentTranslate;
	    }
	
	    if (params.freeMode) {
	      if (currentPos < -swiper.minTranslate()) {
	        swiper.slideTo(swiper.activeIndex);
	        return;
	      }
	      if (currentPos > -swiper.maxTranslate()) {
	        if (swiper.slides.length < snapGrid.length) {
	          swiper.slideTo(snapGrid.length - 1);
	        } else {
	          swiper.slideTo(swiper.slides.length - 1);
	        }
	        return;
	      }
	
	      if (params.freeModeMomentum) {
	        if (data.velocities.length > 1) {
	          var lastMoveEvent = data.velocities.pop();
	          var velocityEvent = data.velocities.pop();
	
	          var distance = lastMoveEvent.position - velocityEvent.position;
	          var time = lastMoveEvent.time - velocityEvent.time;
	          swiper.velocity = distance / time;
	          swiper.velocity /= 2;
	          if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
	            swiper.velocity = 0;
	          }
	          // this implies that the user stopped moving a finger then released.
	          // There would be no events with distance zero, so the last event is stale.
	          if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
	            swiper.velocity = 0;
	          }
	        } else {
	          swiper.velocity = 0;
	        }
	        swiper.velocity *= params.freeModeMomentumVelocityRatio;
	
	        data.velocities.length = 0;
	        var momentumDuration = 1000 * params.freeModeMomentumRatio;
	        var momentumDistance = swiper.velocity * momentumDuration;
	
	        var newPosition = swiper.translate + momentumDistance;
	        if (rtl) { newPosition = -newPosition; }
	
	        var doBounce = false;
	        var afterBouncePosition;
	        var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
	        var needsLoopFix;
	        if (newPosition < swiper.maxTranslate()) {
	          if (params.freeModeMomentumBounce) {
	            if (newPosition + swiper.maxTranslate() < -bounceAmount) {
	              newPosition = swiper.maxTranslate() - bounceAmount;
	            }
	            afterBouncePosition = swiper.maxTranslate();
	            doBounce = true;
	            data.allowMomentumBounce = true;
	          } else {
	            newPosition = swiper.maxTranslate();
	          }
	          if (params.loop && params.centeredSlides) { needsLoopFix = true; }
	        } else if (newPosition > swiper.minTranslate()) {
	          if (params.freeModeMomentumBounce) {
	            if (newPosition - swiper.minTranslate() > bounceAmount) {
	              newPosition = swiper.minTranslate() + bounceAmount;
	            }
	            afterBouncePosition = swiper.minTranslate();
	            doBounce = true;
	            data.allowMomentumBounce = true;
	          } else {
	            newPosition = swiper.minTranslate();
	          }
	          if (params.loop && params.centeredSlides) { needsLoopFix = true; }
	        } else if (params.freeModeSticky) {
	          var nextSlide;
	          for (var j = 0; j < snapGrid.length; j += 1) {
	            if (snapGrid[j] > -newPosition) {
	              nextSlide = j;
	              break;
	            }
	          }
	
	          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
	            newPosition = snapGrid[nextSlide];
	          } else {
	            newPosition = snapGrid[nextSlide - 1];
	          }
	          newPosition = -newPosition;
	        }
	        if (needsLoopFix) {
	          swiper.once('transitionEnd', function () {
	            swiper.loopFix();
	          });
	        }
	        // Fix duration
	        if (swiper.velocity !== 0) {
	          if (rtl) {
	            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
	          } else {
	            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
	          }
	        } else if (params.freeModeSticky) {
	          swiper.slideToClosest();
	          return;
	        }
	
	        if (params.freeModeMomentumBounce && doBounce) {
	          swiper.updateProgress(afterBouncePosition);
	          swiper.setTransition(momentumDuration);
	          swiper.setTranslate(newPosition);
	          swiper.transitionStart(true, swiper.swipeDirection);
	          swiper.animating = true;
	          $wrapperEl.transitionEnd(function () {
	            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }
	            swiper.emit('momentumBounce');
	
	            swiper.setTransition(params.speed);
	            swiper.setTranslate(afterBouncePosition);
	            $wrapperEl.transitionEnd(function () {
	              if (!swiper || swiper.destroyed) { return; }
	              swiper.transitionEnd();
	            });
	          });
	        } else if (swiper.velocity) {
	          swiper.updateProgress(newPosition);
	          swiper.setTransition(momentumDuration);
	          swiper.setTranslate(newPosition);
	          swiper.transitionStart(true, swiper.swipeDirection);
	          if (!swiper.animating) {
	            swiper.animating = true;
	            $wrapperEl.transitionEnd(function () {
	              if (!swiper || swiper.destroyed) { return; }
	              swiper.transitionEnd();
	            });
	          }
	        } else {
	          swiper.updateProgress(newPosition);
	        }
	
	        swiper.updateActiveIndex();
	        swiper.updateSlidesClasses();
	      } else if (params.freeModeSticky) {
	        swiper.slideToClosest();
	        return;
	      }
	
	      if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
	        swiper.updateProgress();
	        swiper.updateActiveIndex();
	        swiper.updateSlidesClasses();
	      }
	      return;
	    }
	
	    // Find current slide
	    var stopIndex = 0;
	    var groupSize = swiper.slidesSizesGrid[0];
	    for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
	      if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
	        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
	          stopIndex = i;
	          groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
	        }
	      } else if (currentPos >= slidesGrid[i]) {
	        stopIndex = i;
	        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
	      }
	    }
	
	    // Find current slide size
	    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
	
	    if (timeDiff > params.longSwipesMs) {
	      // Long touches
	      if (!params.longSwipes) {
	        swiper.slideTo(swiper.activeIndex);
	        return;
	      }
	      if (swiper.swipeDirection === 'next') {
	        if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + params.slidesPerGroup); }
	        else { swiper.slideTo(stopIndex); }
	      }
	      if (swiper.swipeDirection === 'prev') {
	        if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + params.slidesPerGroup); }
	        else { swiper.slideTo(stopIndex); }
	      }
	    } else {
	      // Short swipes
	      if (!params.shortSwipes) {
	        swiper.slideTo(swiper.activeIndex);
	        return;
	      }
	      if (swiper.swipeDirection === 'next') {
	        swiper.slideTo(stopIndex + params.slidesPerGroup);
	      }
	      if (swiper.swipeDirection === 'prev') {
	        swiper.slideTo(stopIndex);
	      }
	    }
	  }
	
	  function onResize () {
	    var swiper = this;
	
	    var params = swiper.params;
	    var el = swiper.el;
	
	    if (el && el.offsetWidth === 0) { return; }
	
	    // Breakpoints
	    if (params.breakpoints) {
	      swiper.setBreakpoint();
	    }
	
	    // Save locks
	    var allowSlideNext = swiper.allowSlideNext;
	    var allowSlidePrev = swiper.allowSlidePrev;
	    var snapGrid = swiper.snapGrid;
	
	    // Disable locks on resize
	    swiper.allowSlideNext = true;
	    swiper.allowSlidePrev = true;
	
	    swiper.updateSize();
	    swiper.updateSlides();
	
	    if (params.freeMode) {
	      var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
	      swiper.setTranslate(newTranslate);
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	
	      if (params.autoHeight) {
	        swiper.updateAutoHeight();
	      }
	    } else {
	      swiper.updateSlidesClasses();
	      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	      } else {
	        swiper.slideTo(swiper.activeIndex, 0, false, true);
	      }
	    }
	    // Return locks after resize
	    swiper.allowSlidePrev = allowSlidePrev;
	    swiper.allowSlideNext = allowSlideNext;
	
	    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
	      swiper.checkOverflow();
	    }
	  }
	
	  function onClick (e) {
	    var swiper = this;
	    if (!swiper.allowClick) {
	      if (swiper.params.preventClicks) { e.preventDefault(); }
	      if (swiper.params.preventClicksPropagation && swiper.animating) {
	        e.stopPropagation();
	        e.stopImmediatePropagation();
	      }
	    }
	  }
	
	  function attachEvents() {
	    var swiper = this;
	    var params = swiper.params;
	    var touchEvents = swiper.touchEvents;
	    var el = swiper.el;
	    var wrapperEl = swiper.wrapperEl;
	
	    {
	      swiper.onTouchStart = onTouchStart.bind(swiper);
	      swiper.onTouchMove = onTouchMove.bind(swiper);
	      swiper.onTouchEnd = onTouchEnd.bind(swiper);
	    }
	
	    swiper.onClick = onClick.bind(swiper);
	
	    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	    var capture = !!params.nested;
	
	    // Touch Events
	    {
	      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	        target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
	        doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
	        doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
	      } else {
	        if (Support.touch) {
	          var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	          target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	          target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);
	          target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	        }
	        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
	          target.addEventListener('mousedown', swiper.onTouchStart, false);
	          doc.addEventListener('mousemove', swiper.onTouchMove, capture);
	          doc.addEventListener('mouseup', swiper.onTouchEnd, false);
	        }
	      }
	      // Prevent Links Clicks
	      if (params.preventClicks || params.preventClicksPropagation) {
	        target.addEventListener('click', swiper.onClick, true);
	      }
	    }
	
	    // Resize handler
	    swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
	  }
	
	  function detachEvents() {
	    var swiper = this;
	
	    var params = swiper.params;
	    var touchEvents = swiper.touchEvents;
	    var el = swiper.el;
	    var wrapperEl = swiper.wrapperEl;
	
	    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	    var capture = !!params.nested;
	
	    // Touch Events
	    {
	      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	        target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
	        doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	        doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
	      } else {
	        if (Support.touch) {
	          var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	          target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	          target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	          target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	        }
	        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
	          target.removeEventListener('mousedown', swiper.onTouchStart, false);
	          doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
	          doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
	        }
	      }
	      // Prevent Links Clicks
	      if (params.preventClicks || params.preventClicksPropagation) {
	        target.removeEventListener('click', swiper.onClick, true);
	      }
	    }
	
	    // Resize handler
	    swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
	  }
	
	  var events = {
	    attachEvents: attachEvents,
	    detachEvents: detachEvents,
	  };
	
	  function setBreakpoint () {
	    var swiper = this;
	    var activeIndex = swiper.activeIndex;
	    var initialized = swiper.initialized;
	    var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;
	    var params = swiper.params;
	    var breakpoints = params.breakpoints;
	    if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }
	
	    // Set breakpoint for window width and update parameters
	    var breakpoint = swiper.getBreakpoint(breakpoints);
	
	    if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
	      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
	      if (breakpointOnlyParams) {
	        ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach(function (param) {
	          var paramValue = breakpointOnlyParams[param];
	          if (typeof paramValue === 'undefined') { return; }
	          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
	            breakpointOnlyParams[param] = 'auto';
	          } else if (param === 'slidesPerView') {
	            breakpointOnlyParams[param] = parseFloat(paramValue);
	          } else {
	            breakpointOnlyParams[param] = parseInt(paramValue, 10);
	          }
	        });
	      }
	
	      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
	      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
	      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
	
	      if (directionChanged && initialized) {
	        swiper.changeDirection();
	      }
	
	      Utils.extend(swiper.params, breakpointParams);
	
	      Utils.extend(swiper, {
	        allowTouchMove: swiper.params.allowTouchMove,
	        allowSlideNext: swiper.params.allowSlideNext,
	        allowSlidePrev: swiper.params.allowSlidePrev,
	      });
	
	      swiper.currentBreakpoint = breakpoint;
	
	      if (needsReLoop && initialized) {
	        swiper.loopDestroy();
	        swiper.loopCreate();
	        swiper.updateSlides();
	        swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
	      }
	
	      swiper.emit('breakpoint', breakpointParams);
	    }
	  }
	
	  function getBreakpoint (breakpoints) {
	    var swiper = this;
	    // Get breakpoint for window width
	    if (!breakpoints) { return undefined; }
	    var breakpoint = false;
	    var points = [];
	    Object.keys(breakpoints).forEach(function (point) {
	      points.push(point);
	    });
	    points.sort(function (a, b) { return parseInt(a, 10) - parseInt(b, 10); });
	    for (var i = 0; i < points.length; i += 1) {
	      var point = points[i];
	      if (swiper.params.breakpointsInverse) {
	        if (point <= win.innerWidth) {
	          breakpoint = point;
	        }
	      } else if (point >= win.innerWidth && !breakpoint) {
	        breakpoint = point;
	      }
	    }
	    return breakpoint || 'max';
	  }
	
	  var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };
	
	  function addClasses () {
	    var swiper = this;
	    var classNames = swiper.classNames;
	    var params = swiper.params;
	    var rtl = swiper.rtl;
	    var $el = swiper.$el;
	    var suffixes = [];
	
	    suffixes.push('initialized');
	    suffixes.push(params.direction);
	
	    if (params.freeMode) {
	      suffixes.push('free-mode');
	    }
	    if (!Support.flexbox) {
	      suffixes.push('no-flexbox');
	    }
	    if (params.autoHeight) {
	      suffixes.push('autoheight');
	    }
	    if (rtl) {
	      suffixes.push('rtl');
	    }
	    if (params.slidesPerColumn > 1) {
	      suffixes.push('multirow');
	    }
	    if (Device.android) {
	      suffixes.push('android');
	    }
	    if (Device.ios) {
	      suffixes.push('ios');
	    }
	    // WP8 Touch Events Fix
	    if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	      suffixes.push(("wp8-" + (params.direction)));
	    }
	
	    suffixes.forEach(function (suffix) {
	      classNames.push(params.containerModifierClass + suffix);
	    });
	
	    $el.addClass(classNames.join(' '));
	  }
	
	  function removeClasses () {
	    var swiper = this;
	    var $el = swiper.$el;
	    var classNames = swiper.classNames;
	
	    $el.removeClass(classNames.join(' '));
	  }
	
	  var classes = { addClasses: addClasses, removeClasses: removeClasses };
	
	  function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
	    var image;
	    function onReady() {
	      if (callback) { callback(); }
	    }
	    if (!imageEl.complete || !checkForComplete) {
	      if (src) {
	        image = new win.Image();
	        image.onload = onReady;
	        image.onerror = onReady;
	        if (sizes) {
	          image.sizes = sizes;
	        }
	        if (srcset) {
	          image.srcset = srcset;
	        }
	        if (src) {
	          image.src = src;
	        }
	      } else {
	        onReady();
	      }
	    } else {
	      // image already loaded...
	      onReady();
	    }
	  }
	
	  function preloadImages () {
	    var swiper = this;
	    swiper.imagesToLoad = swiper.$el.find('img');
	    function onReady() {
	      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }
	      if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }
	      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
	        if (swiper.params.updateOnImagesReady) { swiper.update(); }
	        swiper.emit('imagesReady');
	      }
	    }
	    for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
	      var imageEl = swiper.imagesToLoad[i];
	      swiper.loadImage(
	        imageEl,
	        imageEl.currentSrc || imageEl.getAttribute('src'),
	        imageEl.srcset || imageEl.getAttribute('srcset'),
	        imageEl.sizes || imageEl.getAttribute('sizes'),
	        true,
	        onReady
	      );
	    }
	  }
	
	  var images = {
	    loadImage: loadImage,
	    preloadImages: preloadImages,
	  };
	
	  function checkOverflow() {
	    var swiper = this;
	    var wasLocked = swiper.isLocked;
	
	    swiper.isLocked = swiper.snapGrid.length === 1;
	    swiper.allowSlideNext = !swiper.isLocked;
	    swiper.allowSlidePrev = !swiper.isLocked;
	
	    // events
	    if (wasLocked !== swiper.isLocked) { swiper.emit(swiper.isLocked ? 'lock' : 'unlock'); }
	
	    if (wasLocked && wasLocked !== swiper.isLocked) {
	      swiper.isEnd = false;
	      swiper.navigation.update();
	    }
	  }
	
	  var checkOverflow$1 = { checkOverflow: checkOverflow };
	
	  var defaults = {
	    init: true,
	    direction: 'horizontal',
	    touchEventsTarget: 'container',
	    initialSlide: 0,
	    speed: 300,
	    //
	    preventInteractionOnTransition: false,
	
	    // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
	    edgeSwipeDetection: false,
	    edgeSwipeThreshold: 20,
	
	    // Free mode
	    freeMode: false,
	    freeModeMomentum: true,
	    freeModeMomentumRatio: 1,
	    freeModeMomentumBounce: true,
	    freeModeMomentumBounceRatio: 1,
	    freeModeMomentumVelocityRatio: 1,
	    freeModeSticky: false,
	    freeModeMinimumVelocity: 0.02,
	
	    // Autoheight
	    autoHeight: false,
	
	    // Set wrapper width
	    setWrapperSize: false,
	
	    // Virtual Translate
	    virtualTranslate: false,
	
	    // Effects
	    effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
	
	    // Breakpoints
	    breakpoints: undefined,
	    breakpointsInverse: false,
	
	    // Slides grid
	    spaceBetween: 0,
	    slidesPerView: 1,
	    slidesPerColumn: 1,
	    slidesPerColumnFill: 'column',
	    slidesPerGroup: 1,
	    centeredSlides: false,
	    slidesOffsetBefore: 0, // in px
	    slidesOffsetAfter: 0, // in px
	    normalizeSlideIndex: true,
	    centerInsufficientSlides: false,
	
	    // Disable swiper and hide navigation when container not overflow
	    watchOverflow: false,
	
	    // Round length
	    roundLengths: false,
	
	    // Touches
	    touchRatio: 1,
	    touchAngle: 45,
	    simulateTouch: true,
	    shortSwipes: true,
	    longSwipes: true,
	    longSwipesRatio: 0.5,
	    longSwipesMs: 300,
	    followFinger: true,
	    allowTouchMove: true,
	    threshold: 0,
	    touchMoveStopPropagation: true,
	    touchStartPreventDefault: true,
	    touchStartForcePreventDefault: false,
	    touchReleaseOnEdges: false,
	
	    // Unique Navigation Elements
	    uniqueNavElements: true,
	
	    // Resistance
	    resistance: true,
	    resistanceRatio: 0.85,
	
	    // Progress
	    watchSlidesProgress: false,
	    watchSlidesVisibility: false,
	
	    // Cursor
	    grabCursor: false,
	
	    // Clicks
	    preventClicks: true,
	    preventClicksPropagation: true,
	    slideToClickedSlide: false,
	
	    // Images
	    preloadImages: true,
	    updateOnImagesReady: true,
	
	    // loop
	    loop: false,
	    loopAdditionalSlides: 0,
	    loopedSlides: null,
	    loopFillGroupWithBlank: false,
	
	    // Swiping/no swiping
	    allowSlidePrev: true,
	    allowSlideNext: true,
	    swipeHandler: null, // '.swipe-handler',
	    noSwiping: true,
	    noSwipingClass: 'swiper-no-swiping',
	    noSwipingSelector: null,
	
	    // Passive Listeners
	    passiveListeners: true,
	
	    // NS
	    containerModifierClass: 'swiper-container-', // NEW
	    slideClass: 'swiper-slide',
	    slideBlankClass: 'swiper-slide-invisible-blank',
	    slideActiveClass: 'swiper-slide-active',
	    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
	    slideVisibleClass: 'swiper-slide-visible',
	    slideDuplicateClass: 'swiper-slide-duplicate',
	    slideNextClass: 'swiper-slide-next',
	    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
	    slidePrevClass: 'swiper-slide-prev',
	    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
	    wrapperClass: 'swiper-wrapper',
	
	    // Callbacks
	    runCallbacksOnInit: true,
	  };
	
	  /* eslint no-param-reassign: "off" */
	
	  var prototypes = {
	    update: update,
	    translate: translate,
	    transition: transition$1,
	    slide: slide,
	    loop: loop,
	    grabCursor: grabCursor,
	    manipulation: manipulation,
	    events: events,
	    breakpoints: breakpoints,
	    checkOverflow: checkOverflow$1,
	    classes: classes,
	    images: images,
	  };
	
	  var extendedDefaults = {};
	
	  var Swiper = /*@__PURE__*/(function (SwiperClass) {
	    function Swiper() {
	      var assign;
	
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];
	      var el;
	      var params;
	      if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
	        params = args[0];
	      } else {
	        (assign = args, el = assign[0], params = assign[1]);
	      }
	      if (!params) { params = {}; }
	
	      params = Utils.extend({}, params);
	      if (el && !params.el) { params.el = el; }
	
	      SwiperClass.call(this, params);
	
	      Object.keys(prototypes).forEach(function (prototypeGroup) {
	        Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
	          if (!Swiper.prototype[protoMethod]) {
	            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
	          }
	        });
	      });
	
	      // Swiper Instance
	      var swiper = this;
	      if (typeof swiper.modules === 'undefined') {
	        swiper.modules = {};
	      }
	      Object.keys(swiper.modules).forEach(function (moduleName) {
	        var module = swiper.modules[moduleName];
	        if (module.params) {
	          var moduleParamName = Object.keys(module.params)[0];
	          var moduleParams = module.params[moduleParamName];
	          if (typeof moduleParams !== 'object' || moduleParams === null) { return; }
	          if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }
	          if (params[moduleParamName] === true) {
	            params[moduleParamName] = { enabled: true };
	          }
	          if (
	            typeof params[moduleParamName] === 'object'
	            && !('enabled' in params[moduleParamName])
	          ) {
	            params[moduleParamName].enabled = true;
	          }
	          if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }
	        }
	      });
	
	      // Extend defaults with modules params
	      var swiperParams = Utils.extend({}, defaults);
	      swiper.useModulesParams(swiperParams);
	
	      // Extend defaults with passed params
	      swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
	      swiper.originalParams = Utils.extend({}, swiper.params);
	      swiper.passedParams = Utils.extend({}, params);
	
	      // Save Dom lib
	      swiper.$ = $;
	
	      // Find el
	      var $el = $(swiper.params.el);
	      el = $el[0];
	
	      if (!el) {
	        return undefined;
	      }
	
	      if ($el.length > 1) {
	        var swipers = [];
	        $el.each(function (index, containerEl) {
	          var newParams = Utils.extend({}, params, { el: containerEl });
	          swipers.push(new Swiper(newParams));
	        });
	        return swipers;
	      }
	
	      el.swiper = swiper;
	      $el.data('swiper', swiper);
	
	      // Find Wrapper
	      var $wrapperEl = $el.children(("." + (swiper.params.wrapperClass)));
	
	      // Extend Swiper
	      Utils.extend(swiper, {
	        $el: $el,
	        el: el,
	        $wrapperEl: $wrapperEl,
	        wrapperEl: $wrapperEl[0],
	
	        // Classes
	        classNames: [],
	
	        // Slides
	        slides: $(),
	        slidesGrid: [],
	        snapGrid: [],
	        slidesSizesGrid: [],
	
	        // isDirection
	        isHorizontal: function isHorizontal() {
	          return swiper.params.direction === 'horizontal';
	        },
	        isVertical: function isVertical() {
	          return swiper.params.direction === 'vertical';
	        },
	        // RTL
	        rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
	        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
	        wrongRTL: $wrapperEl.css('display') === '-webkit-box',
	
	        // Indexes
	        activeIndex: 0,
	        realIndex: 0,
	
	        //
	        isBeginning: true,
	        isEnd: false,
	
	        // Props
	        translate: 0,
	        previousTranslate: 0,
	        progress: 0,
	        velocity: 0,
	        animating: false,
	
	        // Locks
	        allowSlideNext: swiper.params.allowSlideNext,
	        allowSlidePrev: swiper.params.allowSlidePrev,
	
	        // Touch Events
	        touchEvents: (function touchEvents() {
	          var touch = ['touchstart', 'touchmove', 'touchend'];
	          var desktop = ['mousedown', 'mousemove', 'mouseup'];
	          if (Support.pointerEvents) {
	            desktop = ['pointerdown', 'pointermove', 'pointerup'];
	          } else if (Support.prefixedPointerEvents) {
	            desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
	          }
	          swiper.touchEventsTouch = {
	            start: touch[0],
	            move: touch[1],
	            end: touch[2],
	          };
	          swiper.touchEventsDesktop = {
	            start: desktop[0],
	            move: desktop[1],
	            end: desktop[2],
	          };
	          return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
	        }()),
	        touchEventsData: {
	          isTouched: undefined,
	          isMoved: undefined,
	          allowTouchCallbacks: undefined,
	          touchStartTime: undefined,
	          isScrolling: undefined,
	          currentTranslate: undefined,
	          startTranslate: undefined,
	          allowThresholdMove: undefined,
	          // Form elements to match
	          formElements: 'input, select, option, textarea, button, video',
	          // Last click time
	          lastClickTime: Utils.now(),
	          clickTimeout: undefined,
	          // Velocities
	          velocities: [],
	          allowMomentumBounce: undefined,
	          isTouchEvent: undefined,
	          startMoving: undefined,
	        },
	
	        // Clicks
	        allowClick: true,
	
	        // Touches
	        allowTouchMove: swiper.params.allowTouchMove,
	
	        touches: {
	          startX: 0,
	          startY: 0,
	          currentX: 0,
	          currentY: 0,
	          diff: 0,
	        },
	
	        // Images
	        imagesToLoad: [],
	        imagesLoaded: 0,
	
	      });
	
	      // Install Modules
	      swiper.useModules();
	
	      // Init
	      if (swiper.params.init) {
	        swiper.init();
	      }
	
	      // Return app instance
	      return swiper;
	    }
	
	    if ( SwiperClass ) Swiper.__proto__ = SwiperClass;
	    Swiper.prototype = Object.create( SwiperClass && SwiperClass.prototype );
	    Swiper.prototype.constructor = Swiper;
	
	    var staticAccessors = { extendedDefaults: { configurable: true },defaults: { configurable: true },Class: { configurable: true },$: { configurable: true } };
	
	    Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {
	      var swiper = this;
	      var params = swiper.params;
	      var slides = swiper.slides;
	      var slidesGrid = swiper.slidesGrid;
	      var swiperSize = swiper.size;
	      var activeIndex = swiper.activeIndex;
	      var spv = 1;
	      if (params.centeredSlides) {
	        var slideSize = slides[activeIndex].swiperSlideSize;
	        var breakLoop;
	        for (var i = activeIndex + 1; i < slides.length; i += 1) {
	          if (slides[i] && !breakLoop) {
	            slideSize += slides[i].swiperSlideSize;
	            spv += 1;
	            if (slideSize > swiperSize) { breakLoop = true; }
	          }
	        }
	        for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
	          if (slides[i$1] && !breakLoop) {
	            slideSize += slides[i$1].swiperSlideSize;
	            spv += 1;
	            if (slideSize > swiperSize) { breakLoop = true; }
	          }
	        }
	      } else {
	        for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
	          if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
	            spv += 1;
	          }
	        }
	      }
	      return spv;
	    };
	
	    Swiper.prototype.update = function update () {
	      var swiper = this;
	      if (!swiper || swiper.destroyed) { return; }
	      var snapGrid = swiper.snapGrid;
	      var params = swiper.params;
	      // Breakpoints
	      if (params.breakpoints) {
	        swiper.setBreakpoint();
	      }
	      swiper.updateSize();
	      swiper.updateSlides();
	      swiper.updateProgress();
	      swiper.updateSlidesClasses();
	
	      function setTranslate() {
	        var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
	        var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
	        swiper.setTranslate(newTranslate);
	        swiper.updateActiveIndex();
	        swiper.updateSlidesClasses();
	      }
	      var translated;
	      if (swiper.params.freeMode) {
	        setTranslate();
	        if (swiper.params.autoHeight) {
	          swiper.updateAutoHeight();
	        }
	      } else {
	        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	        } else {
	          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
	        }
	        if (!translated) {
	          setTranslate();
	        }
	      }
	      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
	        swiper.checkOverflow();
	      }
	      swiper.emit('update');
	    };
	
	    Swiper.prototype.changeDirection = function changeDirection (newDirection, needUpdate) {
	      if ( needUpdate === void 0 ) needUpdate = true;
	
	      var swiper = this;
	      var currentDirection = swiper.params.direction;
	      if (!newDirection) {
	        // eslint-disable-next-line
	        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
	      }
	      if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
	        return swiper;
	      }
	
	      if (currentDirection === 'vertical') {
	        swiper.$el
	          .removeClass(((swiper.params.containerModifierClass) + "vertical wp8-vertical"))
	          .addClass(("" + (swiper.params.containerModifierClass) + newDirection));
	
	        if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	          swiper.$el.addClass(((swiper.params.containerModifierClass) + "wp8-" + newDirection));
	        }
	      }
	      if (currentDirection === 'horizontal') {
	        swiper.$el
	          .removeClass(((swiper.params.containerModifierClass) + "horizontal wp8-horizontal"))
	          .addClass(("" + (swiper.params.containerModifierClass) + newDirection));
	
	        if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
	          swiper.$el.addClass(((swiper.params.containerModifierClass) + "wp8-" + newDirection));
	        }
	      }
	
	      swiper.params.direction = newDirection;
	
	      swiper.slides.each(function (slideIndex, slideEl) {
	        if (newDirection === 'vertical') {
	          slideEl.style.width = '';
	        } else {
	          slideEl.style.height = '';
	        }
	      });
	
	      swiper.emit('changeDirection');
	      if (needUpdate) { swiper.update(); }
	
	      return swiper;
	    };
	
	    Swiper.prototype.init = function init () {
	      var swiper = this;
	      if (swiper.initialized) { return; }
	
	      swiper.emit('beforeInit');
	
	      // Set breakpoint
	      if (swiper.params.breakpoints) {
	        swiper.setBreakpoint();
	      }
	
	      // Add Classes
	      swiper.addClasses();
	
	      // Create loop
	      if (swiper.params.loop) {
	        swiper.loopCreate();
	      }
	
	      // Update size
	      swiper.updateSize();
	
	      // Update slides
	      swiper.updateSlides();
	
	      if (swiper.params.watchOverflow) {
	        swiper.checkOverflow();
	      }
	
	      // Set Grab Cursor
	      if (swiper.params.grabCursor) {
	        swiper.setGrabCursor();
	      }
	
	      if (swiper.params.preloadImages) {
	        swiper.preloadImages();
	      }
	
	      // Slide To Initial Slide
	      if (swiper.params.loop) {
	        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
	      } else {
	        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
	      }
	
	      // Attach events
	      swiper.attachEvents();
	
	      // Init Flag
	      swiper.initialized = true;
	
	      // Emit
	      swiper.emit('init');
	    };
	
	    Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {
	      if ( deleteInstance === void 0 ) deleteInstance = true;
	      if ( cleanStyles === void 0 ) cleanStyles = true;
	
	      var swiper = this;
	      var params = swiper.params;
	      var $el = swiper.$el;
	      var $wrapperEl = swiper.$wrapperEl;
	      var slides = swiper.slides;
	
	      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
	        return null;
	      }
	
	      swiper.emit('beforeDestroy');
	
	      // Init Flag
	      swiper.initialized = false;
	
	      // Detach events
	      swiper.detachEvents();
	
	      // Destroy loop
	      if (params.loop) {
	        swiper.loopDestroy();
	      }
	
	      // Cleanup styles
	      if (cleanStyles) {
	        swiper.removeClasses();
	        $el.removeAttr('style');
	        $wrapperEl.removeAttr('style');
	        if (slides && slides.length) {
	          slides
	            .removeClass([
	              params.slideVisibleClass,
	              params.slideActiveClass,
	              params.slideNextClass,
	              params.slidePrevClass ].join(' '))
	            .removeAttr('style')
	            .removeAttr('data-swiper-slide-index')
	            .removeAttr('data-swiper-column')
	            .removeAttr('data-swiper-row');
	        }
	      }
	
	      swiper.emit('destroy');
	
	      // Detach emitter events
	      Object.keys(swiper.eventsListeners).forEach(function (eventName) {
	        swiper.off(eventName);
	      });
	
	      if (deleteInstance !== false) {
	        swiper.$el[0].swiper = null;
	        swiper.$el.data('swiper', null);
	        Utils.deleteProps(swiper);
	      }
	      swiper.destroyed = true;
	
	      return null;
	    };
	
	    Swiper.extendDefaults = function extendDefaults (newDefaults) {
	      Utils.extend(extendedDefaults, newDefaults);
	    };
	
	    staticAccessors.extendedDefaults.get = function () {
	      return extendedDefaults;
	    };
	
	    staticAccessors.defaults.get = function () {
	      return defaults;
	    };
	
	    staticAccessors.Class.get = function () {
	      return SwiperClass;
	    };
	
	    staticAccessors.$.get = function () {
	      return $;
	    };
	
	    Object.defineProperties( Swiper, staticAccessors );
	
	    return Swiper;
	  }(SwiperClass));
	
	  var Device$1 = {
	    name: 'device',
	    proto: {
	      device: Device,
	    },
	    static: {
	      device: Device,
	    },
	  };
	
	  var Support$1 = {
	    name: 'support',
	    proto: {
	      support: Support,
	    },
	    static: {
	      support: Support,
	    },
	  };
	
	  var Browser$1 = {
	    name: 'browser',
	    proto: {
	      browser: Browser,
	    },
	    static: {
	      browser: Browser,
	    },
	  };
	
	  var Resize = {
	    name: 'resize',
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        resize: {
	          resizeHandler: function resizeHandler() {
	            if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
	            swiper.emit('beforeResize');
	            swiper.emit('resize');
	          },
	          orientationChangeHandler: function orientationChangeHandler() {
	            if (!swiper || swiper.destroyed || !swiper.initialized) { return; }
	            swiper.emit('orientationchange');
	          },
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        // Emit resize
	        win.addEventListener('resize', swiper.resize.resizeHandler);
	
	        // Emit orientationchange
	        win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        win.removeEventListener('resize', swiper.resize.resizeHandler);
	        win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	      },
	    },
	  };
	
	  var Observer = {
	    func: win.MutationObserver || win.WebkitMutationObserver,
	    attach: function attach(target, options) {
	      if ( options === void 0 ) options = {};
	
	      var swiper = this;
	
	      var ObserverFunc = Observer.func;
	      var observer = new ObserverFunc(function (mutations) {
	        // The observerUpdate event should only be triggered
	        // once despite the number of mutations.  Additional
	        // triggers are redundant and are very costly
	        if (mutations.length === 1) {
	          swiper.emit('observerUpdate', mutations[0]);
	          return;
	        }
	        var observerUpdate = function observerUpdate() {
	          swiper.emit('observerUpdate', mutations[0]);
	        };
	
	        if (win.requestAnimationFrame) {
	          win.requestAnimationFrame(observerUpdate);
	        } else {
	          win.setTimeout(observerUpdate, 0);
	        }
	      });
	
	      observer.observe(target, {
	        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	        childList: typeof options.childList === 'undefined' ? true : options.childList,
	        characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
	      });
	
	      swiper.observer.observers.push(observer);
	    },
	    init: function init() {
	      var swiper = this;
	      if (!Support.observer || !swiper.params.observer) { return; }
	      if (swiper.params.observeParents) {
	        var containerParents = swiper.$el.parents();
	        for (var i = 0; i < containerParents.length; i += 1) {
	          swiper.observer.attach(containerParents[i]);
	        }
	      }
	      // Observe container
	      swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });
	
	      // Observe wrapper
	      swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.observer.observers.forEach(function (observer) {
	        observer.disconnect();
	      });
	      swiper.observer.observers = [];
	    },
	  };
	
	  var Observer$1 = {
	    name: 'observer',
	    params: {
	      observer: false,
	      observeParents: false,
	      observeSlideChildren: false,
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        observer: {
	          init: Observer.init.bind(swiper),
	          attach: Observer.attach.bind(swiper),
	          destroy: Observer.destroy.bind(swiper),
	          observers: [],
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        swiper.observer.init();
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        swiper.observer.destroy();
	      },
	    },
	  };
	
	  var Virtual = {
	    update: function update(force) {
	      var swiper = this;
	      var ref = swiper.params;
	      var slidesPerView = ref.slidesPerView;
	      var slidesPerGroup = ref.slidesPerGroup;
	      var centeredSlides = ref.centeredSlides;
	      var ref$1 = swiper.params.virtual;
	      var addSlidesBefore = ref$1.addSlidesBefore;
	      var addSlidesAfter = ref$1.addSlidesAfter;
	      var ref$2 = swiper.virtual;
	      var previousFrom = ref$2.from;
	      var previousTo = ref$2.to;
	      var slides = ref$2.slides;
	      var previousSlidesGrid = ref$2.slidesGrid;
	      var renderSlide = ref$2.renderSlide;
	      var previousOffset = ref$2.offset;
	      swiper.updateActiveIndex();
	      var activeIndex = swiper.activeIndex || 0;
	
	      var offsetProp;
	      if (swiper.rtlTranslate) { offsetProp = 'right'; }
	      else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }
	
	      var slidesAfter;
	      var slidesBefore;
	      if (centeredSlides) {
	        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
	        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
	      } else {
	        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
	        slidesBefore = slidesPerGroup + addSlidesAfter;
	      }
	      var from = Math.max((activeIndex || 0) - slidesBefore, 0);
	      var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
	      var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
	
	      Utils.extend(swiper.virtual, {
	        from: from,
	        to: to,
	        offset: offset,
	        slidesGrid: swiper.slidesGrid,
	      });
	
	      function onRendered() {
	        swiper.updateSlides();
	        swiper.updateProgress();
	        swiper.updateSlidesClasses();
	        if (swiper.lazy && swiper.params.lazy.enabled) {
	          swiper.lazy.load();
	        }
	      }
	
	      if (previousFrom === from && previousTo === to && !force) {
	        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
	          swiper.slides.css(offsetProp, (offset + "px"));
	        }
	        swiper.updateProgress();
	        return;
	      }
	      if (swiper.params.virtual.renderExternal) {
	        swiper.params.virtual.renderExternal.call(swiper, {
	          offset: offset,
	          from: from,
	          to: to,
	          slides: (function getSlides() {
	            var slidesToRender = [];
	            for (var i = from; i <= to; i += 1) {
	              slidesToRender.push(slides[i]);
	            }
	            return slidesToRender;
	          }()),
	        });
	        onRendered();
	        return;
	      }
	      var prependIndexes = [];
	      var appendIndexes = [];
	      if (force) {
	        swiper.$wrapperEl.find(("." + (swiper.params.slideClass))).remove();
	      } else {
	        for (var i = previousFrom; i <= previousTo; i += 1) {
	          if (i < from || i > to) {
	            swiper.$wrapperEl.find(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + i + "\"]")).remove();
	          }
	        }
	      }
	      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
	        if (i$1 >= from && i$1 <= to) {
	          if (typeof previousTo === 'undefined' || force) {
	            appendIndexes.push(i$1);
	          } else {
	            if (i$1 > previousTo) { appendIndexes.push(i$1); }
	            if (i$1 < previousFrom) { prependIndexes.push(i$1); }
	          }
	        }
	      }
	      appendIndexes.forEach(function (index) {
	        swiper.$wrapperEl.append(renderSlide(slides[index], index));
	      });
	      prependIndexes.sort(function (a, b) { return b - a; }).forEach(function (index) {
	        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
	      });
	      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + "px"));
	      onRendered();
	    },
	    renderSlide: function renderSlide(slide, index) {
	      var swiper = this;
	      var params = swiper.params.virtual;
	      if (params.cache && swiper.virtual.cache[index]) {
	        return swiper.virtual.cache[index];
	      }
	      var $slideEl = params.renderSlide
	        ? $(params.renderSlide.call(swiper, slide, index))
	        : $(("<div class=\"" + (swiper.params.slideClass) + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>"));
	      if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }
	      if (params.cache) { swiper.virtual.cache[index] = $slideEl; }
	      return $slideEl;
	    },
	    appendSlide: function appendSlide(slides) {
	      var swiper = this;
	      if (typeof slides === 'object' && 'length' in slides) {
	        for (var i = 0; i < slides.length; i += 1) {
	          if (slides[i]) { swiper.virtual.slides.push(slides[i]); }
	        }
	      } else {
	        swiper.virtual.slides.push(slides);
	      }
	      swiper.virtual.update(true);
	    },
	    prependSlide: function prependSlide(slides) {
	      var swiper = this;
	      var activeIndex = swiper.activeIndex;
	      var newActiveIndex = activeIndex + 1;
	      var numberOfNewSlides = 1;
	
	      if (Array.isArray(slides)) {
	        for (var i = 0; i < slides.length; i += 1) {
	          if (slides[i]) { swiper.virtual.slides.unshift(slides[i]); }
	        }
	        newActiveIndex = activeIndex + slides.length;
	        numberOfNewSlides = slides.length;
	      } else {
	        swiper.virtual.slides.unshift(slides);
	      }
	      if (swiper.params.virtual.cache) {
	        var cache = swiper.virtual.cache;
	        var newCache = {};
	        Object.keys(cache).forEach(function (cachedIndex) {
	          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];
	        });
	        swiper.virtual.cache = newCache;
	      }
	      swiper.virtual.update(true);
	      swiper.slideTo(newActiveIndex, 0);
	    },
	    removeSlide: function removeSlide(slidesIndexes) {
	      var swiper = this;
	      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) { return; }
	      var activeIndex = swiper.activeIndex;
	      if (Array.isArray(slidesIndexes)) {
	        for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
	          swiper.virtual.slides.splice(slidesIndexes[i], 1);
	          if (swiper.params.virtual.cache) {
	            delete swiper.virtual.cache[slidesIndexes[i]];
	          }
	          if (slidesIndexes[i] < activeIndex) { activeIndex -= 1; }
	          activeIndex = Math.max(activeIndex, 0);
	        }
	      } else {
	        swiper.virtual.slides.splice(slidesIndexes, 1);
	        if (swiper.params.virtual.cache) {
	          delete swiper.virtual.cache[slidesIndexes];
	        }
	        if (slidesIndexes < activeIndex) { activeIndex -= 1; }
	        activeIndex = Math.max(activeIndex, 0);
	      }
	      swiper.virtual.update(true);
	      swiper.slideTo(activeIndex, 0);
	    },
	    removeAllSlides: function removeAllSlides() {
	      var swiper = this;
	      swiper.virtual.slides = [];
	      if (swiper.params.virtual.cache) {
	        swiper.virtual.cache = {};
	      }
	      swiper.virtual.update(true);
	      swiper.slideTo(0, 0);
	    },
	  };
	
	  var Virtual$1 = {
	    name: 'virtual',
	    params: {
	      virtual: {
	        enabled: false,
	        slides: [],
	        cache: true,
	        renderSlide: null,
	        renderExternal: null,
	        addSlidesBefore: 0,
	        addSlidesAfter: 0,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        virtual: {
	          update: Virtual.update.bind(swiper),
	          appendSlide: Virtual.appendSlide.bind(swiper),
	          prependSlide: Virtual.prependSlide.bind(swiper),
	          removeSlide: Virtual.removeSlide.bind(swiper),
	          removeAllSlides: Virtual.removeAllSlides.bind(swiper),
	          renderSlide: Virtual.renderSlide.bind(swiper),
	          slides: swiper.params.virtual.slides,
	          cache: {},
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        if (!swiper.params.virtual.enabled) { return; }
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "virtual"));
	        var overwriteParams = {
	          watchSlidesProgress: true,
	        };
	        Utils.extend(swiper.params, overwriteParams);
	        Utils.extend(swiper.originalParams, overwriteParams);
	
	        if (!swiper.params.initialSlide) {
	          swiper.virtual.update();
	        }
	      },
	      setTranslate: function setTranslate() {
	        var swiper = this;
	        if (!swiper.params.virtual.enabled) { return; }
	        swiper.virtual.update();
	      },
	    },
	  };
	
	  var Keyboard = {
	    handle: function handle(event) {
	      var swiper = this;
	      var rtl = swiper.rtlTranslate;
	      var e = event;
	      if (e.originalEvent) { e = e.originalEvent; } // jquery fix
	      var kc = e.keyCode || e.charCode;
	      // Directions locks
	      if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {
	        return false;
	      }
	      if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {
	        return false;
	      }
	      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
	        return undefined;
	      }
	      if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
	        return undefined;
	      }
	      if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
	        var inView = false;
	        // Check that swiper should be inside of visible area of window
	        if (swiper.$el.parents(("." + (swiper.params.slideClass))).length > 0 && swiper.$el.parents(("." + (swiper.params.slideActiveClass))).length === 0) {
	          return undefined;
	        }
	        var windowWidth = win.innerWidth;
	        var windowHeight = win.innerHeight;
	        var swiperOffset = swiper.$el.offset();
	        if (rtl) { swiperOffset.left -= swiper.$el[0].scrollLeft; }
	        var swiperCoord = [
	          [swiperOffset.left, swiperOffset.top],
	          [swiperOffset.left + swiper.width, swiperOffset.top],
	          [swiperOffset.left, swiperOffset.top + swiper.height],
	          [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height] ];
	        for (var i = 0; i < swiperCoord.length; i += 1) {
	          var point = swiperCoord[i];
	          if (
	            point[0] >= 0 && point[0] <= windowWidth
	            && point[1] >= 0 && point[1] <= windowHeight
	          ) {
	            inView = true;
	          }
	        }
	        if (!inView) { return undefined; }
	      }
	      if (swiper.isHorizontal()) {
	        if (kc === 37 || kc === 39) {
	          if (e.preventDefault) { e.preventDefault(); }
	          else { e.returnValue = false; }
	        }
	        if ((kc === 39 && !rtl) || (kc === 37 && rtl)) { swiper.slideNext(); }
	        if ((kc === 37 && !rtl) || (kc === 39 && rtl)) { swiper.slidePrev(); }
	      } else {
	        if (kc === 38 || kc === 40) {
	          if (e.preventDefault) { e.preventDefault(); }
	          else { e.returnValue = false; }
	        }
	        if (kc === 40) { swiper.slideNext(); }
	        if (kc === 38) { swiper.slidePrev(); }
	      }
	      swiper.emit('keyPress', kc);
	      return undefined;
	    },
	    enable: function enable() {
	      var swiper = this;
	      if (swiper.keyboard.enabled) { return; }
	      $(doc).on('keydown', swiper.keyboard.handle);
	      swiper.keyboard.enabled = true;
	    },
	    disable: function disable() {
	      var swiper = this;
	      if (!swiper.keyboard.enabled) { return; }
	      $(doc).off('keydown', swiper.keyboard.handle);
	      swiper.keyboard.enabled = false;
	    },
	  };
	
	  var Keyboard$1 = {
	    name: 'keyboard',
	    params: {
	      keyboard: {
	        enabled: false,
	        onlyInViewport: true,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        keyboard: {
	          enabled: false,
	          enable: Keyboard.enable.bind(swiper),
	          disable: Keyboard.disable.bind(swiper),
	          handle: Keyboard.handle.bind(swiper),
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        if (swiper.params.keyboard.enabled) {
	          swiper.keyboard.enable();
	        }
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        if (swiper.keyboard.enabled) {
	          swiper.keyboard.disable();
	        }
	      },
	    },
	  };
	
	  function isEventSupported() {
	    var eventName = 'onwheel';
	    var isSupported = eventName in doc;
	
	    if (!isSupported) {
	      var element = doc.createElement('div');
	      element.setAttribute(eventName, 'return;');
	      isSupported = typeof element[eventName] === 'function';
	    }
	
	    if (!isSupported
	      && doc.implementation
	      && doc.implementation.hasFeature
	      // always returns true in newer browsers as per the standard.
	      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	      && doc.implementation.hasFeature('', '') !== true
	    ) {
	      // This is the only way to test support for the `wheel` event in IE9+.
	      isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
	    }
	
	    return isSupported;
	  }
	  var Mousewheel = {
	    lastScrollTime: Utils.now(),
	    event: (function getEvent() {
	      if (win.navigator.userAgent.indexOf('firefox') > -1) { return 'DOMMouseScroll'; }
	      return isEventSupported() ? 'wheel' : 'mousewheel';
	    }()),
	    normalize: function normalize(e) {
	      // Reasonable defaults
	      var PIXEL_STEP = 10;
	      var LINE_HEIGHT = 40;
	      var PAGE_HEIGHT = 800;
	
	      var sX = 0;
	      var sY = 0; // spinX, spinY
	      var pX = 0;
	      var pY = 0; // pixelX, pixelY
	
	      // Legacy
	      if ('detail' in e) {
	        sY = e.detail;
	      }
	      if ('wheelDelta' in e) {
	        sY = -e.wheelDelta / 120;
	      }
	      if ('wheelDeltaY' in e) {
	        sY = -e.wheelDeltaY / 120;
	      }
	      if ('wheelDeltaX' in e) {
	        sX = -e.wheelDeltaX / 120;
	      }
	
	      // side scrolling on FF with DOMMouseScroll
	      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
	        sX = sY;
	        sY = 0;
	      }
	
	      pX = sX * PIXEL_STEP;
	      pY = sY * PIXEL_STEP;
	
	      if ('deltaY' in e) {
	        pY = e.deltaY;
	      }
	      if ('deltaX' in e) {
	        pX = e.deltaX;
	      }
	
	      if ((pX || pY) && e.deltaMode) {
	        if (e.deltaMode === 1) { // delta in LINE units
	          pX *= LINE_HEIGHT;
	          pY *= LINE_HEIGHT;
	        } else { // delta in PAGE units
	          pX *= PAGE_HEIGHT;
	          pY *= PAGE_HEIGHT;
	        }
	      }
	
	      // Fall-back if spin cannot be determined
	      if (pX && !sX) {
	        sX = (pX < 1) ? -1 : 1;
	      }
	      if (pY && !sY) {
	        sY = (pY < 1) ? -1 : 1;
	      }
	
	      return {
	        spinX: sX,
	        spinY: sY,
	        pixelX: pX,
	        pixelY: pY,
	      };
	    },
	    handleMouseEnter: function handleMouseEnter() {
	      var swiper = this;
	      swiper.mouseEntered = true;
	    },
	    handleMouseLeave: function handleMouseLeave() {
	      var swiper = this;
	      swiper.mouseEntered = false;
	    },
	    handle: function handle(event) {
	      var e = event;
	      var swiper = this;
	      var params = swiper.params.mousewheel;
	
	      if (!swiper.mouseEntered && !params.releaseOnEdges) { return true; }
	
	      if (e.originalEvent) { e = e.originalEvent; } // jquery fix
	      var delta = 0;
	      var rtlFactor = swiper.rtlTranslate ? -1 : 1;
	
	      var data = Mousewheel.normalize(e);
	
	      if (params.forceToAxis) {
	        if (swiper.isHorizontal()) {
	          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) { delta = data.pixelX * rtlFactor; }
	          else { return true; }
	        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) { delta = data.pixelY; }
	        else { return true; }
	      } else {
	        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
	      }
	
	      if (delta === 0) { return true; }
	
	      if (params.invert) { delta = -delta; }
	
	      if (!swiper.params.freeMode) {
	        if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
	          if (delta < 0) {
	            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
	              swiper.slideNext();
	              swiper.emit('scroll', e);
	            } else if (params.releaseOnEdges) { return true; }
	          } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
	            swiper.slidePrev();
	            swiper.emit('scroll', e);
	          } else if (params.releaseOnEdges) { return true; }
	        }
	        swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
	      } else {
	        // Freemode or scrollContainer:
	        if (swiper.params.loop) {
	          swiper.loopFix();
	        }
	        var position = swiper.getTranslate() + (delta * params.sensitivity);
	        var wasBeginning = swiper.isBeginning;
	        var wasEnd = swiper.isEnd;
	
	        if (position >= swiper.minTranslate()) { position = swiper.minTranslate(); }
	        if (position <= swiper.maxTranslate()) { position = swiper.maxTranslate(); }
	
	        swiper.setTransition(0);
	        swiper.setTranslate(position);
	        swiper.updateProgress();
	        swiper.updateActiveIndex();
	        swiper.updateSlidesClasses();
	
	        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
	          swiper.updateSlidesClasses();
	        }
	
	        if (swiper.params.freeModeSticky) {
	          clearTimeout(swiper.mousewheel.timeout);
	          swiper.mousewheel.timeout = Utils.nextTick(function () {
	            swiper.slideToClosest();
	          }, 300);
	        }
	        // Emit event
	        swiper.emit('scroll', e);
	
	        // Stop autoplay
	        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) { swiper.autoplay.stop(); }
	        // Return page scroll on edge positions
	        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) { return true; }
	      }
	
	      if (e.preventDefault) { e.preventDefault(); }
	      else { e.returnValue = false; }
	      return false;
	    },
	    enable: function enable() {
	      var swiper = this;
	      if (!Mousewheel.event) { return false; }
	      if (swiper.mousewheel.enabled) { return false; }
	      var target = swiper.$el;
	      if (swiper.params.mousewheel.eventsTarged !== 'container') {
	        target = $(swiper.params.mousewheel.eventsTarged);
	      }
	      target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
	      target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
	      target.on(Mousewheel.event, swiper.mousewheel.handle);
	      swiper.mousewheel.enabled = true;
	      return true;
	    },
	    disable: function disable() {
	      var swiper = this;
	      if (!Mousewheel.event) { return false; }
	      if (!swiper.mousewheel.enabled) { return false; }
	      var target = swiper.$el;
	      if (swiper.params.mousewheel.eventsTarged !== 'container') {
	        target = $(swiper.params.mousewheel.eventsTarged);
	      }
	      target.off(Mousewheel.event, swiper.mousewheel.handle);
	      swiper.mousewheel.enabled = false;
	      return true;
	    },
	  };
	
	  var Mousewheel$1 = {
	    name: 'mousewheel',
	    params: {
	      mousewheel: {
	        enabled: false,
	        releaseOnEdges: false,
	        invert: false,
	        forceToAxis: false,
	        sensitivity: 1,
	        eventsTarged: 'container',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        mousewheel: {
	          enabled: false,
	          enable: Mousewheel.enable.bind(swiper),
	          disable: Mousewheel.disable.bind(swiper),
	          handle: Mousewheel.handle.bind(swiper),
	          handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
	          handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
	          lastScrollTime: Utils.now(),
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        if (swiper.params.mousewheel.enabled) { swiper.mousewheel.enable(); }
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        if (swiper.mousewheel.enabled) { swiper.mousewheel.disable(); }
	      },
	    },
	  };
	
	  var Navigation = {
	    update: function update() {
	      // Update Navigation Buttons
	      var swiper = this;
	      var params = swiper.params.navigation;
	
	      if (swiper.params.loop) { return; }
	      var ref = swiper.navigation;
	      var $nextEl = ref.$nextEl;
	      var $prevEl = ref.$prevEl;
	
	      if ($prevEl && $prevEl.length > 0) {
	        if (swiper.isBeginning) {
	          $prevEl.addClass(params.disabledClass);
	        } else {
	          $prevEl.removeClass(params.disabledClass);
	        }
	        $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	      }
	      if ($nextEl && $nextEl.length > 0) {
	        if (swiper.isEnd) {
	          $nextEl.addClass(params.disabledClass);
	        } else {
	          $nextEl.removeClass(params.disabledClass);
	        }
	        $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	      }
	    },
	    onPrevClick: function onPrevClick(e) {
	      var swiper = this;
	      e.preventDefault();
	      if (swiper.isBeginning && !swiper.params.loop) { return; }
	      swiper.slidePrev();
	    },
	    onNextClick: function onNextClick(e) {
	      var swiper = this;
	      e.preventDefault();
	      if (swiper.isEnd && !swiper.params.loop) { return; }
	      swiper.slideNext();
	    },
	    init: function init() {
	      var swiper = this;
	      var params = swiper.params.navigation;
	      if (!(params.nextEl || params.prevEl)) { return; }
	
	      var $nextEl;
	      var $prevEl;
	      if (params.nextEl) {
	        $nextEl = $(params.nextEl);
	        if (
	          swiper.params.uniqueNavElements
	          && typeof params.nextEl === 'string'
	          && $nextEl.length > 1
	          && swiper.$el.find(params.nextEl).length === 1
	        ) {
	          $nextEl = swiper.$el.find(params.nextEl);
	        }
	      }
	      if (params.prevEl) {
	        $prevEl = $(params.prevEl);
	        if (
	          swiper.params.uniqueNavElements
	          && typeof params.prevEl === 'string'
	          && $prevEl.length > 1
	          && swiper.$el.find(params.prevEl).length === 1
	        ) {
	          $prevEl = swiper.$el.find(params.prevEl);
	        }
	      }
	
	      if ($nextEl && $nextEl.length > 0) {
	        $nextEl.on('click', swiper.navigation.onNextClick);
	      }
	      if ($prevEl && $prevEl.length > 0) {
	        $prevEl.on('click', swiper.navigation.onPrevClick);
	      }
	
	      Utils.extend(swiper.navigation, {
	        $nextEl: $nextEl,
	        nextEl: $nextEl && $nextEl[0],
	        $prevEl: $prevEl,
	        prevEl: $prevEl && $prevEl[0],
	      });
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      var ref = swiper.navigation;
	      var $nextEl = ref.$nextEl;
	      var $prevEl = ref.$prevEl;
	      if ($nextEl && $nextEl.length) {
	        $nextEl.off('click', swiper.navigation.onNextClick);
	        $nextEl.removeClass(swiper.params.navigation.disabledClass);
	      }
	      if ($prevEl && $prevEl.length) {
	        $prevEl.off('click', swiper.navigation.onPrevClick);
	        $prevEl.removeClass(swiper.params.navigation.disabledClass);
	      }
	    },
	  };
	
	  var Navigation$1 = {
	    name: 'navigation',
	    params: {
	      navigation: {
	        nextEl: null,
	        prevEl: null,
	
	        hideOnClick: false,
	        disabledClass: 'swiper-button-disabled',
	        hiddenClass: 'swiper-button-hidden',
	        lockClass: 'swiper-button-lock',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        navigation: {
	          init: Navigation.init.bind(swiper),
	          update: Navigation.update.bind(swiper),
	          destroy: Navigation.destroy.bind(swiper),
	          onNextClick: Navigation.onNextClick.bind(swiper),
	          onPrevClick: Navigation.onPrevClick.bind(swiper),
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        swiper.navigation.init();
	        swiper.navigation.update();
	      },
	      toEdge: function toEdge() {
	        var swiper = this;
	        swiper.navigation.update();
	      },
	      fromEdge: function fromEdge() {
	        var swiper = this;
	        swiper.navigation.update();
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        swiper.navigation.destroy();
	      },
	      click: function click(e) {
	        var swiper = this;
	        var ref = swiper.navigation;
	        var $nextEl = ref.$nextEl;
	        var $prevEl = ref.$prevEl;
	        if (
	          swiper.params.navigation.hideOnClick
	          && !$(e.target).is($prevEl)
	          && !$(e.target).is($nextEl)
	        ) {
	          var isHidden;
	          if ($nextEl) {
	            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
	          } else if ($prevEl) {
	            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
	          }
	          if (isHidden === true) {
	            swiper.emit('navigationShow', swiper);
	          } else {
	            swiper.emit('navigationHide', swiper);
	          }
	          if ($nextEl) {
	            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
	          }
	          if ($prevEl) {
	            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
	          }
	        }
	      },
	    },
	  };
	
	  var Pagination = {
	    update: function update() {
	      // Render || Update Pagination bullets/items
	      var swiper = this;
	      var rtl = swiper.rtl;
	      var params = swiper.params.pagination;
	      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	      var $el = swiper.pagination.$el;
	      // Current/Total
	      var current;
	      var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	      if (swiper.params.loop) {
	        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
	        if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
	          current -= (slidesLength - (swiper.loopedSlides * 2));
	        }
	        if (current > total - 1) { current -= total; }
	        if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }
	      } else if (typeof swiper.snapIndex !== 'undefined') {
	        current = swiper.snapIndex;
	      } else {
	        current = swiper.activeIndex || 0;
	      }
	      // Types
	      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
	        var bullets = swiper.pagination.bullets;
	        var firstIndex;
	        var lastIndex;
	        var midIndex;
	        if (params.dynamicBullets) {
	          swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
	          $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)) + "px"));
	          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
	            swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
	            if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
	              swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
	            } else if (swiper.pagination.dynamicBulletIndex < 0) {
	              swiper.pagination.dynamicBulletIndex = 0;
	            }
	          }
	          firstIndex = current - swiper.pagination.dynamicBulletIndex;
	          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
	          midIndex = (lastIndex + firstIndex) / 2;
	        }
	        bullets.removeClass(((params.bulletActiveClass) + " " + (params.bulletActiveClass) + "-next " + (params.bulletActiveClass) + "-next-next " + (params.bulletActiveClass) + "-prev " + (params.bulletActiveClass) + "-prev-prev " + (params.bulletActiveClass) + "-main"));
	        if ($el.length > 1) {
	          bullets.each(function (index, bullet) {
	            var $bullet = $(bullet);
	            var bulletIndex = $bullet.index();
	            if (bulletIndex === current) {
	              $bullet.addClass(params.bulletActiveClass);
	            }
	            if (params.dynamicBullets) {
	              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
	                $bullet.addClass(((params.bulletActiveClass) + "-main"));
	              }
	              if (bulletIndex === firstIndex) {
	                $bullet
	                  .prev()
	                  .addClass(((params.bulletActiveClass) + "-prev"))
	                  .prev()
	                  .addClass(((params.bulletActiveClass) + "-prev-prev"));
	              }
	              if (bulletIndex === lastIndex) {
	                $bullet
	                  .next()
	                  .addClass(((params.bulletActiveClass) + "-next"))
	                  .next()
	                  .addClass(((params.bulletActiveClass) + "-next-next"));
	              }
	            }
	          });
	        } else {
	          var $bullet = bullets.eq(current);
	          $bullet.addClass(params.bulletActiveClass);
	          if (params.dynamicBullets) {
	            var $firstDisplayedBullet = bullets.eq(firstIndex);
	            var $lastDisplayedBullet = bullets.eq(lastIndex);
	            for (var i = firstIndex; i <= lastIndex; i += 1) {
	              bullets.eq(i).addClass(((params.bulletActiveClass) + "-main"));
	            }
	            $firstDisplayedBullet
	              .prev()
	              .addClass(((params.bulletActiveClass) + "-prev"))
	              .prev()
	              .addClass(((params.bulletActiveClass) + "-prev-prev"));
	            $lastDisplayedBullet
	              .next()
	              .addClass(((params.bulletActiveClass) + "-next"))
	              .next()
	              .addClass(((params.bulletActiveClass) + "-next-next"));
	          }
	        }
	        if (params.dynamicBullets) {
	          var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
	          var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
	          var offsetProp = rtl ? 'right' : 'left';
	          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + "px"));
	        }
	      }
	      if (params.type === 'fraction') {
	        $el.find(("." + (params.currentClass))).text(params.formatFractionCurrent(current + 1));
	        $el.find(("." + (params.totalClass))).text(params.formatFractionTotal(total));
	      }
	      if (params.type === 'progressbar') {
	        var progressbarDirection;
	        if (params.progressbarOpposite) {
	          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
	        } else {
	          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
	        }
	        var scale = (current + 1) / total;
	        var scaleX = 1;
	        var scaleY = 1;
	        if (progressbarDirection === 'horizontal') {
	          scaleX = scale;
	        } else {
	          scaleY = scale;
	        }
	        $el.find(("." + (params.progressbarFillClass))).transform(("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")")).transition(swiper.params.speed);
	      }
	      if (params.type === 'custom' && params.renderCustom) {
	        $el.html(params.renderCustom(swiper, current + 1, total));
	        swiper.emit('paginationRender', swiper, $el[0]);
	      } else {
	        swiper.emit('paginationUpdate', swiper, $el[0]);
	      }
	      $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
	    },
	    render: function render() {
	      // Render Container
	      var swiper = this;
	      var params = swiper.params.pagination;
	      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	
	      var $el = swiper.pagination.$el;
	      var paginationHTML = '';
	      if (params.type === 'bullets') {
	        var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	        for (var i = 0; i < numberOfBullets; i += 1) {
	          if (params.renderBullet) {
	            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
	          } else {
	            paginationHTML += "<" + (params.bulletElement) + " class=\"" + (params.bulletClass) + "\"></" + (params.bulletElement) + ">";
	          }
	        }
	        $el.html(paginationHTML);
	        swiper.pagination.bullets = $el.find(("." + (params.bulletClass)));
	      }
	      if (params.type === 'fraction') {
	        if (params.renderFraction) {
	          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
	        } else {
	          paginationHTML = "<span class=\"" + (params.currentClass) + "\"></span>"
	          + ' / '
	          + "<span class=\"" + (params.totalClass) + "\"></span>";
	        }
	        $el.html(paginationHTML);
	      }
	      if (params.type === 'progressbar') {
	        if (params.renderProgressbar) {
	          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
	        } else {
	          paginationHTML = "<span class=\"" + (params.progressbarFillClass) + "\"></span>";
	        }
	        $el.html(paginationHTML);
	      }
	      if (params.type !== 'custom') {
	        swiper.emit('paginationRender', swiper.pagination.$el[0]);
	      }
	    },
	    init: function init() {
	      var swiper = this;
	      var params = swiper.params.pagination;
	      if (!params.el) { return; }
	
	      var $el = $(params.el);
	      if ($el.length === 0) { return; }
	
	      if (
	        swiper.params.uniqueNavElements
	        && typeof params.el === 'string'
	        && $el.length > 1
	        && swiper.$el.find(params.el).length === 1
	      ) {
	        $el = swiper.$el.find(params.el);
	      }
	
	      if (params.type === 'bullets' && params.clickable) {
	        $el.addClass(params.clickableClass);
	      }
	
	      $el.addClass(params.modifierClass + params.type);
	
	      if (params.type === 'bullets' && params.dynamicBullets) {
	        $el.addClass(("" + (params.modifierClass) + (params.type) + "-dynamic"));
	        swiper.pagination.dynamicBulletIndex = 0;
	        if (params.dynamicMainBullets < 1) {
	          params.dynamicMainBullets = 1;
	        }
	      }
	      if (params.type === 'progressbar' && params.progressbarOpposite) {
	        $el.addClass(params.progressbarOppositeClass);
	      }
	
	      if (params.clickable) {
	        $el.on('click', ("." + (params.bulletClass)), function onClick(e) {
	          e.preventDefault();
	          var index = $(this).index() * swiper.params.slidesPerGroup;
	          if (swiper.params.loop) { index += swiper.loopedSlides; }
	          swiper.slideTo(index);
	        });
	      }
	
	      Utils.extend(swiper.pagination, {
	        $el: $el,
	        el: $el[0],
	      });
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      var params = swiper.params.pagination;
	      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	      var $el = swiper.pagination.$el;
	
	      $el.removeClass(params.hiddenClass);
	      $el.removeClass(params.modifierClass + params.type);
	      if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }
	      if (params.clickable) {
	        $el.off('click', ("." + (params.bulletClass)));
	      }
	    },
	  };
	
	  var Pagination$1 = {
	    name: 'pagination',
	    params: {
	      pagination: {
	        el: null,
	        bulletElement: 'span',
	        clickable: false,
	        hideOnClick: false,
	        renderBullet: null,
	        renderProgressbar: null,
	        renderFraction: null,
	        renderCustom: null,
	        progressbarOpposite: false,
	        type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
	        dynamicBullets: false,
	        dynamicMainBullets: 1,
	        formatFractionCurrent: function (number) { return number; },
	        formatFractionTotal: function (number) { return number; },
	        bulletClass: 'swiper-pagination-bullet',
	        bulletActiveClass: 'swiper-pagination-bullet-active',
	        modifierClass: 'swiper-pagination-', // NEW
	        currentClass: 'swiper-pagination-current',
	        totalClass: 'swiper-pagination-total',
	        hiddenClass: 'swiper-pagination-hidden',
	        progressbarFillClass: 'swiper-pagination-progressbar-fill',
	        progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
	        clickableClass: 'swiper-pagination-clickable', // NEW
	        lockClass: 'swiper-pagination-lock',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        pagination: {
	          init: Pagination.init.bind(swiper),
	          render: Pagination.render.bind(swiper),
	          update: Pagination.update.bind(swiper),
	          destroy: Pagination.destroy.bind(swiper),
	          dynamicBulletIndex: 0,
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        swiper.pagination.init();
	        swiper.pagination.render();
	        swiper.pagination.update();
	      },
	      activeIndexChange: function activeIndexChange() {
	        var swiper = this;
	        if (swiper.params.loop) {
	          swiper.pagination.update();
	        } else if (typeof swiper.snapIndex === 'undefined') {
	          swiper.pagination.update();
	        }
	      },
	      snapIndexChange: function snapIndexChange() {
	        var swiper = this;
	        if (!swiper.params.loop) {
	          swiper.pagination.update();
	        }
	      },
	      slidesLengthChange: function slidesLengthChange() {
	        var swiper = this;
	        if (swiper.params.loop) {
	          swiper.pagination.render();
	          swiper.pagination.update();
	        }
	      },
	      snapGridLengthChange: function snapGridLengthChange() {
	        var swiper = this;
	        if (!swiper.params.loop) {
	          swiper.pagination.render();
	          swiper.pagination.update();
	        }
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        swiper.pagination.destroy();
	      },
	      click: function click(e) {
	        var swiper = this;
	        if (
	          swiper.params.pagination.el
	          && swiper.params.pagination.hideOnClick
	          && swiper.pagination.$el.length > 0
	          && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
	        ) {
	          var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
	          if (isHidden === true) {
	            swiper.emit('paginationShow', swiper);
	          } else {
	            swiper.emit('paginationHide', swiper);
	          }
	          swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
	        }
	      },
	    },
	  };
	
	  var Scrollbar = {
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
	      var scrollbar = swiper.scrollbar;
	      var rtl = swiper.rtlTranslate;
	      var progress = swiper.progress;
	      var dragSize = scrollbar.dragSize;
	      var trackSize = scrollbar.trackSize;
	      var $dragEl = scrollbar.$dragEl;
	      var $el = scrollbar.$el;
	      var params = swiper.params.scrollbar;
	
	      var newSize = dragSize;
	      var newPos = (trackSize - dragSize) * progress;
	      if (rtl) {
	        newPos = -newPos;
	        if (newPos > 0) {
	          newSize = dragSize - newPos;
	          newPos = 0;
	        } else if (-newPos + dragSize > trackSize) {
	          newSize = trackSize + newPos;
	        }
	      } else if (newPos < 0) {
	        newSize = dragSize + newPos;
	        newPos = 0;
	      } else if (newPos + dragSize > trackSize) {
	        newSize = trackSize - newPos;
	      }
	      if (swiper.isHorizontal()) {
	        if (Support.transforms3d) {
	          $dragEl.transform(("translate3d(" + newPos + "px, 0, 0)"));
	        } else {
	          $dragEl.transform(("translateX(" + newPos + "px)"));
	        }
	        $dragEl[0].style.width = newSize + "px";
	      } else {
	        if (Support.transforms3d) {
	          $dragEl.transform(("translate3d(0px, " + newPos + "px, 0)"));
	        } else {
	          $dragEl.transform(("translateY(" + newPos + "px)"));
	        }
	        $dragEl[0].style.height = newSize + "px";
	      }
	      if (params.hide) {
	        clearTimeout(swiper.scrollbar.timeout);
	        $el[0].style.opacity = 1;
	        swiper.scrollbar.timeout = setTimeout(function () {
	          $el[0].style.opacity = 0;
	          $el.transition(400);
	        }, 1000);
	      }
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
	      swiper.scrollbar.$dragEl.transition(duration);
	    },
	    updateSize: function updateSize() {
	      var swiper = this;
	      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
	
	      var scrollbar = swiper.scrollbar;
	      var $dragEl = scrollbar.$dragEl;
	      var $el = scrollbar.$el;
	
	      $dragEl[0].style.width = '';
	      $dragEl[0].style.height = '';
	      var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
	
	      var divider = swiper.size / swiper.virtualSize;
	      var moveDivider = divider * (trackSize / swiper.size);
	      var dragSize;
	      if (swiper.params.scrollbar.dragSize === 'auto') {
	        dragSize = trackSize * divider;
	      } else {
	        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
	      }
	
	      if (swiper.isHorizontal()) {
	        $dragEl[0].style.width = dragSize + "px";
	      } else {
	        $dragEl[0].style.height = dragSize + "px";
	      }
	
	      if (divider >= 1) {
	        $el[0].style.display = 'none';
	      } else {
	        $el[0].style.display = '';
	      }
	      if (swiper.params.scrollbar.hide) {
	        $el[0].style.opacity = 0;
	      }
	      Utils.extend(scrollbar, {
	        trackSize: trackSize,
	        divider: divider,
	        moveDivider: moveDivider,
	        dragSize: dragSize,
	      });
	      scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
	    },
	    setDragPosition: function setDragPosition(e) {
	      var swiper = this;
	      var scrollbar = swiper.scrollbar;
	      var rtl = swiper.rtlTranslate;
	      var $el = scrollbar.$el;
	      var dragSize = scrollbar.dragSize;
	      var trackSize = scrollbar.trackSize;
	
	      var pointerPosition;
	      if (swiper.isHorizontal()) {
	        pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
	      } else {
	        pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
	      }
	      var positionRatio;
	      positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);
	      positionRatio = Math.max(Math.min(positionRatio, 1), 0);
	      if (rtl) {
	        positionRatio = 1 - positionRatio;
	      }
	
	      var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);
	
	      swiper.updateProgress(position);
	      swiper.setTranslate(position);
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    },
	    onDragStart: function onDragStart(e) {
	      var swiper = this;
	      var params = swiper.params.scrollbar;
	      var scrollbar = swiper.scrollbar;
	      var $wrapperEl = swiper.$wrapperEl;
	      var $el = scrollbar.$el;
	      var $dragEl = scrollbar.$dragEl;
	      swiper.scrollbar.isTouched = true;
	      e.preventDefault();
	      e.stopPropagation();
	
	      $wrapperEl.transition(100);
	      $dragEl.transition(100);
	      scrollbar.setDragPosition(e);
	
	      clearTimeout(swiper.scrollbar.dragTimeout);
	
	      $el.transition(0);
	      if (params.hide) {
	        $el.css('opacity', 1);
	      }
	      swiper.emit('scrollbarDragStart', e);
	    },
	    onDragMove: function onDragMove(e) {
	      var swiper = this;
	      var scrollbar = swiper.scrollbar;
	      var $wrapperEl = swiper.$wrapperEl;
	      var $el = scrollbar.$el;
	      var $dragEl = scrollbar.$dragEl;
	
	      if (!swiper.scrollbar.isTouched) { return; }
	      if (e.preventDefault) { e.preventDefault(); }
	      else { e.returnValue = false; }
	      scrollbar.setDragPosition(e);
	      $wrapperEl.transition(0);
	      $el.transition(0);
	      $dragEl.transition(0);
	      swiper.emit('scrollbarDragMove', e);
	    },
	    onDragEnd: function onDragEnd(e) {
	      var swiper = this;
	
	      var params = swiper.params.scrollbar;
	      var scrollbar = swiper.scrollbar;
	      var $el = scrollbar.$el;
	
	      if (!swiper.scrollbar.isTouched) { return; }
	      swiper.scrollbar.isTouched = false;
	      if (params.hide) {
	        clearTimeout(swiper.scrollbar.dragTimeout);
	        swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
	          $el.css('opacity', 0);
	          $el.transition(400);
	        }, 1000);
	      }
	      swiper.emit('scrollbarDragEnd', e);
	      if (params.snapOnRelease) {
	        swiper.slideToClosest();
	      }
	    },
	    enableDraggable: function enableDraggable() {
	      var swiper = this;
	      if (!swiper.params.scrollbar.el) { return; }
	      var scrollbar = swiper.scrollbar;
	      var touchEventsTouch = swiper.touchEventsTouch;
	      var touchEventsDesktop = swiper.touchEventsDesktop;
	      var params = swiper.params;
	      var $el = scrollbar.$el;
	      var target = $el[0];
	      var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
	      var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	      if (!Support.touch) {
	        target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
	        doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
	        doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
	      } else {
	        target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
	        target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
	        target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
	      }
	    },
	    disableDraggable: function disableDraggable() {
	      var swiper = this;
	      if (!swiper.params.scrollbar.el) { return; }
	      var scrollbar = swiper.scrollbar;
	      var touchEventsTouch = swiper.touchEventsTouch;
	      var touchEventsDesktop = swiper.touchEventsDesktop;
	      var params = swiper.params;
	      var $el = scrollbar.$el;
	      var target = $el[0];
	      var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
	      var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	      if (!Support.touch) {
	        target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
	        doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
	        doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
	      } else {
	        target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
	        target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
	        target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
	      }
	    },
	    init: function init() {
	      var swiper = this;
	      if (!swiper.params.scrollbar.el) { return; }
	      var scrollbar = swiper.scrollbar;
	      var $swiperEl = swiper.$el;
	      var params = swiper.params.scrollbar;
	
	      var $el = $(params.el);
	      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
	        $el = $swiperEl.find(params.el);
	      }
	
	      var $dragEl = $el.find(("." + (swiper.params.scrollbar.dragClass)));
	      if ($dragEl.length === 0) {
	        $dragEl = $(("<div class=\"" + (swiper.params.scrollbar.dragClass) + "\"></div>"));
	        $el.append($dragEl);
	      }
	
	      Utils.extend(scrollbar, {
	        $el: $el,
	        el: $el[0],
	        $dragEl: $dragEl,
	        dragEl: $dragEl[0],
	      });
	
	      if (params.draggable) {
	        scrollbar.enableDraggable();
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.scrollbar.disableDraggable();
	    },
	  };
	
	  var Scrollbar$1 = {
	    name: 'scrollbar',
	    params: {
	      scrollbar: {
	        el: null,
	        dragSize: 'auto',
	        hide: false,
	        draggable: false,
	        snapOnRelease: true,
	        lockClass: 'swiper-scrollbar-lock',
	        dragClass: 'swiper-scrollbar-drag',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        scrollbar: {
	          init: Scrollbar.init.bind(swiper),
	          destroy: Scrollbar.destroy.bind(swiper),
	          updateSize: Scrollbar.updateSize.bind(swiper),
	          setTranslate: Scrollbar.setTranslate.bind(swiper),
	          setTransition: Scrollbar.setTransition.bind(swiper),
	          enableDraggable: Scrollbar.enableDraggable.bind(swiper),
	          disableDraggable: Scrollbar.disableDraggable.bind(swiper),
	          setDragPosition: Scrollbar.setDragPosition.bind(swiper),
	          onDragStart: Scrollbar.onDragStart.bind(swiper),
	          onDragMove: Scrollbar.onDragMove.bind(swiper),
	          onDragEnd: Scrollbar.onDragEnd.bind(swiper),
	          isTouched: false,
	          timeout: null,
	          dragTimeout: null,
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        swiper.scrollbar.init();
	        swiper.scrollbar.updateSize();
	        swiper.scrollbar.setTranslate();
	      },
	      update: function update() {
	        var swiper = this;
	        swiper.scrollbar.updateSize();
	      },
	      resize: function resize() {
	        var swiper = this;
	        swiper.scrollbar.updateSize();
	      },
	      observerUpdate: function observerUpdate() {
	        var swiper = this;
	        swiper.scrollbar.updateSize();
	      },
	      setTranslate: function setTranslate() {
	        var swiper = this;
	        swiper.scrollbar.setTranslate();
	      },
	      setTransition: function setTransition(duration) {
	        var swiper = this;
	        swiper.scrollbar.setTransition(duration);
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        swiper.scrollbar.destroy();
	      },
	    },
	  };
	
	  var Parallax = {
	    setTransform: function setTransform(el, progress) {
	      var swiper = this;
	      var rtl = swiper.rtl;
	
	      var $el = $(el);
	      var rtlFactor = rtl ? -1 : 1;
	
	      var p = $el.attr('data-swiper-parallax') || '0';
	      var x = $el.attr('data-swiper-parallax-x');
	      var y = $el.attr('data-swiper-parallax-y');
	      var scale = $el.attr('data-swiper-parallax-scale');
	      var opacity = $el.attr('data-swiper-parallax-opacity');
	
	      if (x || y) {
	        x = x || '0';
	        y = y || '0';
	      } else if (swiper.isHorizontal()) {
	        x = p;
	        y = '0';
	      } else {
	        y = p;
	        x = '0';
	      }
	
	      if ((x).indexOf('%') >= 0) {
	        x = (parseInt(x, 10) * progress * rtlFactor) + "%";
	      } else {
	        x = (x * progress * rtlFactor) + "px";
	      }
	      if ((y).indexOf('%') >= 0) {
	        y = (parseInt(y, 10) * progress) + "%";
	      } else {
	        y = (y * progress) + "px";
	      }
	
	      if (typeof opacity !== 'undefined' && opacity !== null) {
	        var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
	        $el[0].style.opacity = currentOpacity;
	      }
	      if (typeof scale === 'undefined' || scale === null) {
	        $el.transform(("translate3d(" + x + ", " + y + ", 0px)"));
	      } else {
	        var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
	        $el.transform(("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")"));
	      }
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      var $el = swiper.$el;
	      var slides = swiper.slides;
	      var progress = swiper.progress;
	      var snapGrid = swiper.snapGrid;
	      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	        .each(function (index, el) {
	          swiper.parallax.setTransform(el, progress);
	        });
	      slides.each(function (slideIndex, slideEl) {
	        var slideProgress = slideEl.progress;
	        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
	          slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
	        }
	        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
	        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	          .each(function (index, el) {
	            swiper.parallax.setTransform(el, slideProgress);
	          });
	      });
	    },
	    setTransition: function setTransition(duration) {
	      if ( duration === void 0 ) duration = this.params.speed;
	
	      var swiper = this;
	      var $el = swiper.$el;
	      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	        .each(function (index, parallaxEl) {
	          var $parallaxEl = $(parallaxEl);
	          var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
	          if (duration === 0) { parallaxDuration = 0; }
	          $parallaxEl.transition(parallaxDuration);
	        });
	    },
	  };
	
	  var Parallax$1 = {
	    name: 'parallax',
	    params: {
	      parallax: {
	        enabled: false,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        parallax: {
	          setTransform: Parallax.setTransform.bind(swiper),
	          setTranslate: Parallax.setTranslate.bind(swiper),
	          setTransition: Parallax.setTransition.bind(swiper),
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        if (!swiper.params.parallax.enabled) { return; }
	        swiper.params.watchSlidesProgress = true;
	        swiper.originalParams.watchSlidesProgress = true;
	      },
	      init: function init() {
	        var swiper = this;
	        if (!swiper.params.parallax.enabled) { return; }
	        swiper.parallax.setTranslate();
	      },
	      setTranslate: function setTranslate() {
	        var swiper = this;
	        if (!swiper.params.parallax.enabled) { return; }
	        swiper.parallax.setTranslate();
	      },
	      setTransition: function setTransition(duration) {
	        var swiper = this;
	        if (!swiper.params.parallax.enabled) { return; }
	        swiper.parallax.setTransition(duration);
	      },
	    },
	  };
	
	  var Zoom = {
	    // Calc Scale From Multi-touches
	    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
	      if (e.targetTouches.length < 2) { return 1; }
	      var x1 = e.targetTouches[0].pageX;
	      var y1 = e.targetTouches[0].pageY;
	      var x2 = e.targetTouches[1].pageX;
	      var y2 = e.targetTouches[1].pageY;
	      var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));
	      return distance;
	    },
	    // Events
	    onGestureStart: function onGestureStart(e) {
	      var swiper = this;
	      var params = swiper.params.zoom;
	      var zoom = swiper.zoom;
	      var gesture = zoom.gesture;
	      zoom.fakeGestureTouched = false;
	      zoom.fakeGestureMoved = false;
	      if (!Support.gestures) {
	        if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
	          return;
	        }
	        zoom.fakeGestureTouched = true;
	        gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
	      }
	      if (!gesture.$slideEl || !gesture.$slideEl.length) {
	        gesture.$slideEl = $(e.target).closest('.swiper-slide');
	        if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }
	        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	        gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	        if (gesture.$imageWrapEl.length === 0) {
	          gesture.$imageEl = undefined;
	          return;
	        }
	      }
	      gesture.$imageEl.transition(0);
	      swiper.zoom.isScaling = true;
	    },
	    onGestureChange: function onGestureChange(e) {
	      var swiper = this;
	      var params = swiper.params.zoom;
	      var zoom = swiper.zoom;
	      var gesture = zoom.gesture;
	      if (!Support.gestures) {
	        if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
	          return;
	        }
	        zoom.fakeGestureMoved = true;
	        gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
	      }
	      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	      if (Support.gestures) {
	        zoom.scale = e.scale * zoom.currentScale;
	      } else {
	        zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
	      }
	      if (zoom.scale > gesture.maxRatio) {
	        zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));
	      }
	      if (zoom.scale < params.minRatio) {
	        zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));
	      }
	      gesture.$imageEl.transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	    },
	    onGestureEnd: function onGestureEnd(e) {
	      var swiper = this;
	      var params = swiper.params.zoom;
	      var zoom = swiper.zoom;
	      var gesture = zoom.gesture;
	      if (!Support.gestures) {
	        if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
	          return;
	        }
	        if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
	          return;
	        }
	        zoom.fakeGestureTouched = false;
	        zoom.fakeGestureMoved = false;
	      }
	      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
	      gesture.$imageEl.transition(swiper.params.speed).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	      zoom.currentScale = zoom.scale;
	      zoom.isScaling = false;
	      if (zoom.scale === 1) { gesture.$slideEl = undefined; }
	    },
	    onTouchStart: function onTouchStart(e) {
	      var swiper = this;
	      var zoom = swiper.zoom;
	      var gesture = zoom.gesture;
	      var image = zoom.image;
	      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	      if (image.isTouched) { return; }
	      if (Device.android) { e.preventDefault(); }
	      image.isTouched = true;
	      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    },
	    onTouchMove: function onTouchMove(e) {
	      var swiper = this;
	      var zoom = swiper.zoom;
	      var gesture = zoom.gesture;
	      var image = zoom.image;
	      var velocity = zoom.velocity;
	      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	      swiper.allowClick = false;
	      if (!image.isTouched || !gesture.$slideEl) { return; }
	
	      if (!image.isMoved) {
	        image.width = gesture.$imageEl[0].offsetWidth;
	        image.height = gesture.$imageEl[0].offsetHeight;
	        image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
	        image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
	        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
	        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
	        gesture.$imageWrapEl.transition(0);
	        if (swiper.rtl) {
	          image.startX = -image.startX;
	          image.startY = -image.startY;
	        }
	      }
	      // Define if we need image drag
	      var scaledWidth = image.width * zoom.scale;
	      var scaledHeight = image.height * zoom.scale;
	
	      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }
	
	      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
	      image.maxX = -image.minX;
	      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
	      image.maxY = -image.minY;
	
	      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	
	      if (!image.isMoved && !zoom.isScaling) {
	        if (
	          swiper.isHorizontal()
	          && (
	            (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
	            || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
	          )
	        ) {
	          image.isTouched = false;
	          return;
	        } if (
	          !swiper.isHorizontal()
	          && (
	            (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
	            || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
	          )
	        ) {
	          image.isTouched = false;
	          return;
	        }
	      }
	      e.preventDefault();
	      e.stopPropagation();
	
	      image.isMoved = true;
	      image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
	      image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;
	
	      if (image.currentX < image.minX) {
	        image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));
	      }
	      if (image.currentX > image.maxX) {
	        image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));
	      }
	
	      if (image.currentY < image.minY) {
	        image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));
	      }
	      if (image.currentY > image.maxY) {
	        image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));
	      }
	
	      // Velocity
	      if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }
	      if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }
	      if (!velocity.prevTime) { velocity.prevTime = Date.now(); }
	      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
	      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
	      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }
	      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }
	      velocity.prevPositionX = image.touchesCurrent.x;
	      velocity.prevPositionY = image.touchesCurrent.y;
	      velocity.prevTime = Date.now();
	
	      gesture.$imageWrapEl.transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
	    },
	    onTouchEnd: function onTouchEnd() {
	      var swiper = this;
	      var zoom = swiper.zoom;
	      var gesture = zoom.gesture;
	      var image = zoom.image;
	      var velocity = zoom.velocity;
	      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	      if (!image.isTouched || !image.isMoved) {
	        image.isTouched = false;
	        image.isMoved = false;
	        return;
	      }
	      image.isTouched = false;
	      image.isMoved = false;
	      var momentumDurationX = 300;
	      var momentumDurationY = 300;
	      var momentumDistanceX = velocity.x * momentumDurationX;
	      var newPositionX = image.currentX + momentumDistanceX;
	      var momentumDistanceY = velocity.y * momentumDurationY;
	      var newPositionY = image.currentY + momentumDistanceY;
	
	      // Fix duration
	      if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }
	      if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }
	      var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
	
	      image.currentX = newPositionX;
	      image.currentY = newPositionY;
	
	      // Define if we need image drag
	      var scaledWidth = image.width * zoom.scale;
	      var scaledHeight = image.height * zoom.scale;
	      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
	      image.maxX = -image.minX;
	      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
	      image.maxY = -image.minY;
	      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
	      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
	
	      gesture.$imageWrapEl.transition(momentumDuration).transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
	    },
	    onTransitionEnd: function onTransitionEnd() {
	      var swiper = this;
	      var zoom = swiper.zoom;
	      var gesture = zoom.gesture;
	      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
	        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
	        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
	
	        zoom.scale = 1;
	        zoom.currentScale = 1;
	
	        gesture.$slideEl = undefined;
	        gesture.$imageEl = undefined;
	        gesture.$imageWrapEl = undefined;
	      }
	    },
	    // Toggle Zoom
	    toggle: function toggle(e) {
	      var swiper = this;
	      var zoom = swiper.zoom;
	
	      if (zoom.scale && zoom.scale !== 1) {
	        // Zoom Out
	        zoom.out();
	      } else {
	        // Zoom In
	        zoom.in(e);
	      }
	    },
	    in: function in$1(e) {
	      var swiper = this;
	
	      var zoom = swiper.zoom;
	      var params = swiper.params.zoom;
	      var gesture = zoom.gesture;
	      var image = zoom.image;
	
	      if (!gesture.$slideEl) {
	        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	        gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	      }
	      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	
	      gesture.$slideEl.addClass(("" + (params.zoomedSlideClass)));
	
	      var touchX;
	      var touchY;
	      var offsetX;
	      var offsetY;
	      var diffX;
	      var diffY;
	      var translateX;
	      var translateY;
	      var imageWidth;
	      var imageHeight;
	      var scaledWidth;
	      var scaledHeight;
	      var translateMinX;
	      var translateMinY;
	      var translateMaxX;
	      var translateMaxY;
	      var slideWidth;
	      var slideHeight;
	
	      if (typeof image.touchesStart.x === 'undefined' && e) {
	        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
	        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
	      } else {
	        touchX = image.touchesStart.x;
	        touchY = image.touchesStart.y;
	      }
	
	      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	      zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	      if (e) {
	        slideWidth = gesture.$slideEl[0].offsetWidth;
	        slideHeight = gesture.$slideEl[0].offsetHeight;
	        offsetX = gesture.$slideEl.offset().left;
	        offsetY = gesture.$slideEl.offset().top;
	        diffX = (offsetX + (slideWidth / 2)) - touchX;
	        diffY = (offsetY + (slideHeight / 2)) - touchY;
	
	        imageWidth = gesture.$imageEl[0].offsetWidth;
	        imageHeight = gesture.$imageEl[0].offsetHeight;
	        scaledWidth = imageWidth * zoom.scale;
	        scaledHeight = imageHeight * zoom.scale;
	
	        translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
	        translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
	        translateMaxX = -translateMinX;
	        translateMaxY = -translateMinY;
	
	        translateX = diffX * zoom.scale;
	        translateY = diffY * zoom.scale;
	
	        if (translateX < translateMinX) {
	          translateX = translateMinX;
	        }
	        if (translateX > translateMaxX) {
	          translateX = translateMaxX;
	        }
	
	        if (translateY < translateMinY) {
	          translateY = translateMinY;
	        }
	        if (translateY > translateMaxY) {
	          translateY = translateMaxY;
	        }
	      } else {
	        translateX = 0;
	        translateY = 0;
	      }
	      gesture.$imageWrapEl.transition(300).transform(("translate3d(" + translateX + "px, " + translateY + "px,0)"));
	      gesture.$imageEl.transition(300).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	    },
	    out: function out() {
	      var swiper = this;
	
	      var zoom = swiper.zoom;
	      var params = swiper.params.zoom;
	      var gesture = zoom.gesture;
	
	      if (!gesture.$slideEl) {
	        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	        gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	      }
	      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	
	      zoom.scale = 1;
	      zoom.currentScale = 1;
	      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
	      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
	      gesture.$slideEl.removeClass(("" + (params.zoomedSlideClass)));
	      gesture.$slideEl = undefined;
	    },
	    // Attach/Detach Events
	    enable: function enable() {
	      var swiper = this;
	      var zoom = swiper.zoom;
	      if (zoom.enabled) { return; }
	      zoom.enabled = true;
	
	      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
	
	      // Scale image
	      if (Support.gestures) {
	        swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
	        swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
	        swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
	      } else if (swiper.touchEvents.start === 'touchstart') {
	        swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
	        swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
	        swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
	      }
	
	      // Move image
	      swiper.$wrapperEl.on(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);
	    },
	    disable: function disable() {
	      var swiper = this;
	      var zoom = swiper.zoom;
	      if (!zoom.enabled) { return; }
	
	      swiper.zoom.enabled = false;
	
	      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
	
	      // Scale image
	      if (Support.gestures) {
	        swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
	        swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
	        swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
	      } else if (swiper.touchEvents.start === 'touchstart') {
	        swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
	        swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
	        swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
	      }
	
	      // Move image
	      swiper.$wrapperEl.off(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);
	    },
	  };
	
	  var Zoom$1 = {
	    name: 'zoom',
	    params: {
	      zoom: {
	        enabled: false,
	        maxRatio: 3,
	        minRatio: 1,
	        toggle: true,
	        containerClass: 'swiper-zoom-container',
	        zoomedSlideClass: 'swiper-slide-zoomed',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      var zoom = {
	        enabled: false,
	        scale: 1,
	        currentScale: 1,
	        isScaling: false,
	        gesture: {
	          $slideEl: undefined,
	          slideWidth: undefined,
	          slideHeight: undefined,
	          $imageEl: undefined,
	          $imageWrapEl: undefined,
	          maxRatio: 3,
	        },
	        image: {
	          isTouched: undefined,
	          isMoved: undefined,
	          currentX: undefined,
	          currentY: undefined,
	          minX: undefined,
	          minY: undefined,
	          maxX: undefined,
	          maxY: undefined,
	          width: undefined,
	          height: undefined,
	          startX: undefined,
	          startY: undefined,
	          touchesStart: {},
	          touchesCurrent: {},
	        },
	        velocity: {
	          x: undefined,
	          y: undefined,
	          prevPositionX: undefined,
	          prevPositionY: undefined,
	          prevTime: undefined,
	        },
	      };
	
	      ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {
	        zoom[methodName] = Zoom[methodName].bind(swiper);
	      });
	      Utils.extend(swiper, {
	        zoom: zoom,
	      });
	
	      var scale = 1;
	      Object.defineProperty(swiper.zoom, 'scale', {
	        get: function get() {
	          return scale;
	        },
	        set: function set(value) {
	          if (scale !== value) {
	            var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
	            var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
	            swiper.emit('zoomChange', value, imageEl, slideEl);
	          }
	          scale = value;
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        if (swiper.params.zoom.enabled) {
	          swiper.zoom.enable();
	        }
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        swiper.zoom.disable();
	      },
	      touchStart: function touchStart(e) {
	        var swiper = this;
	        if (!swiper.zoom.enabled) { return; }
	        swiper.zoom.onTouchStart(e);
	      },
	      touchEnd: function touchEnd(e) {
	        var swiper = this;
	        if (!swiper.zoom.enabled) { return; }
	        swiper.zoom.onTouchEnd(e);
	      },
	      doubleTap: function doubleTap(e) {
	        var swiper = this;
	        if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
	          swiper.zoom.toggle(e);
	        }
	      },
	      transitionEnd: function transitionEnd() {
	        var swiper = this;
	        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
	          swiper.zoom.onTransitionEnd();
	        }
	      },
	    },
	  };
	
	  var Lazy = {
	    loadInSlide: function loadInSlide(index, loadInDuplicate) {
	      if ( loadInDuplicate === void 0 ) loadInDuplicate = true;
	
	      var swiper = this;
	      var params = swiper.params.lazy;
	      if (typeof index === 'undefined') { return; }
	      if (swiper.slides.length === 0) { return; }
	      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	
	      var $slideEl = isVirtual
	        ? swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]"))
	        : swiper.slides.eq(index);
	
	      var $images = $slideEl.find(("." + (params.elementClass) + ":not(." + (params.loadedClass) + "):not(." + (params.loadingClass) + ")"));
	      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
	        $images = $images.add($slideEl[0]);
	      }
	      if ($images.length === 0) { return; }
	
	      $images.each(function (imageIndex, imageEl) {
	        var $imageEl = $(imageEl);
	        $imageEl.addClass(params.loadingClass);
	
	        var background = $imageEl.attr('data-background');
	        var src = $imageEl.attr('data-src');
	        var srcset = $imageEl.attr('data-srcset');
	        var sizes = $imageEl.attr('data-sizes');
	
	        swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {
	          if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }
	          if (background) {
	            $imageEl.css('background-image', ("url(\"" + background + "\")"));
	            $imageEl.removeAttr('data-background');
	          } else {
	            if (srcset) {
	              $imageEl.attr('srcset', srcset);
	              $imageEl.removeAttr('data-srcset');
	            }
	            if (sizes) {
	              $imageEl.attr('sizes', sizes);
	              $imageEl.removeAttr('data-sizes');
	            }
	            if (src) {
	              $imageEl.attr('src', src);
	              $imageEl.removeAttr('data-src');
	            }
	          }
	
	          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
	          $slideEl.find(("." + (params.preloaderClass))).remove();
	          if (swiper.params.loop && loadInDuplicate) {
	            var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
	            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
	              var originalSlide = swiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + (swiper.params.slideDuplicateClass) + ")"));
	              swiper.lazy.loadInSlide(originalSlide.index(), false);
	            } else {
	              var duplicatedSlide = swiper.$wrapperEl.children(("." + (swiper.params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]"));
	              swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
	            }
	          }
	          swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
	        });
	
	        swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
	      });
	    },
	    load: function load() {
	      var swiper = this;
	      var $wrapperEl = swiper.$wrapperEl;
	      var swiperParams = swiper.params;
	      var slides = swiper.slides;
	      var activeIndex = swiper.activeIndex;
	      var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
	      var params = swiperParams.lazy;
	
	      var slidesPerView = swiperParams.slidesPerView;
	      if (slidesPerView === 'auto') {
	        slidesPerView = 0;
	      }
	
	      function slideExist(index) {
	        if (isVirtual) {
	          if ($wrapperEl.children(("." + (swiperParams.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]")).length) {
	            return true;
	          }
	        } else if (slides[index]) { return true; }
	        return false;
	      }
	      function slideIndex(slideEl) {
	        if (isVirtual) {
	          return $(slideEl).attr('data-swiper-slide-index');
	        }
	        return $(slideEl).index();
	      }
	
	      if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }
	      if (swiper.params.watchSlidesVisibility) {
	        $wrapperEl.children(("." + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {
	          var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
	          swiper.lazy.loadInSlide(index);
	        });
	      } else if (slidesPerView > 1) {
	        for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
	          if (slideExist(i)) { swiper.lazy.loadInSlide(i); }
	        }
	      } else {
	        swiper.lazy.loadInSlide(activeIndex);
	      }
	      if (params.loadPrevNext) {
	        if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
	          var amount = params.loadPrevNextAmount;
	          var spv = slidesPerView;
	          var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
	          var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
	          // Next Slides
	          for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
	            if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }
	          }
	          // Prev Slides
	          for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
	            if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }
	          }
	        } else {
	          var nextSlide = $wrapperEl.children(("." + (swiperParams.slideNextClass)));
	          if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }
	
	          var prevSlide = $wrapperEl.children(("." + (swiperParams.slidePrevClass)));
	          if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }
	        }
	      }
	    },
	  };
	
	  var Lazy$1 = {
	    name: 'lazy',
	    params: {
	      lazy: {
	        enabled: false,
	        loadPrevNext: false,
	        loadPrevNextAmount: 1,
	        loadOnTransitionStart: false,
	
	        elementClass: 'swiper-lazy',
	        loadingClass: 'swiper-lazy-loading',
	        loadedClass: 'swiper-lazy-loaded',
	        preloaderClass: 'swiper-lazy-preloader',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        lazy: {
	          initialImageLoaded: false,
	          load: Lazy.load.bind(swiper),
	          loadInSlide: Lazy.loadInSlide.bind(swiper),
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
	          swiper.params.preloadImages = false;
	        }
	      },
	      init: function init() {
	        var swiper = this;
	        if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
	          swiper.lazy.load();
	        }
	      },
	      scroll: function scroll() {
	        var swiper = this;
	        if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
	          swiper.lazy.load();
	        }
	      },
	      resize: function resize() {
	        var swiper = this;
	        if (swiper.params.lazy.enabled) {
	          swiper.lazy.load();
	        }
	      },
	      scrollbarDragMove: function scrollbarDragMove() {
	        var swiper = this;
	        if (swiper.params.lazy.enabled) {
	          swiper.lazy.load();
	        }
	      },
	      transitionStart: function transitionStart() {
	        var swiper = this;
	        if (swiper.params.lazy.enabled) {
	          if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
	            swiper.lazy.load();
	          }
	        }
	      },
	      transitionEnd: function transitionEnd() {
	        var swiper = this;
	        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
	          swiper.lazy.load();
	        }
	      },
	    },
	  };
	
	  /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
	
	  var Controller = {
	    LinearSpline: function LinearSpline(x, y) {
	      var binarySearch = (function search() {
	        var maxIndex;
	        var minIndex;
	        var guess;
	        return function (array, val) {
	          minIndex = -1;
	          maxIndex = array.length;
	          while (maxIndex - minIndex > 1) {
	            guess = maxIndex + minIndex >> 1;
	            if (array[guess] <= val) {
	              minIndex = guess;
	            } else {
	              maxIndex = guess;
	            }
	          }
	          return maxIndex;
	        };
	      }());
	      this.x = x;
	      this.y = y;
	      this.lastIndex = x.length - 1;
	      // Given an x value (x2), return the expected y2 value:
	      // (x1,y1) is the known point before given value,
	      // (x3,y3) is the known point after given value.
	      var i1;
	      var i3;
	
	      this.interpolate = function interpolate(x2) {
	        if (!x2) { return 0; }
	
	        // Get the indexes of x1 and x3 (the array indexes before and after given x2):
	        i3 = binarySearch(this.x, x2);
	        i1 = i3 - 1;
	
	        // We have our indexes i1 & i3, so we can calculate already:
	        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
	        return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
	      };
	      return this;
	    },
	    // xxx: for now i will just save one spline function to to
	    getInterpolateFunction: function getInterpolateFunction(c) {
	      var swiper = this;
	      if (!swiper.controller.spline) {
	        swiper.controller.spline = swiper.params.loop
	          ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
	          : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
	      }
	    },
	    setTranslate: function setTranslate(setTranslate$1, byController) {
	      var swiper = this;
	      var controlled = swiper.controller.control;
	      var multiplier;
	      var controlledTranslate;
	      function setControlledTranslate(c) {
	        // this will create an Interpolate function based on the snapGrids
	        // x is the Grid of the scrolled scroller and y will be the controlled scroller
	        // it makes sense to create this only once and recall it for the interpolation
	        // the function does a lot of value caching for performance
	        var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
	        if (swiper.params.controller.by === 'slide') {
	          swiper.controller.getInterpolateFunction(c);
	          // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
	          // but it did not work out
	          controlledTranslate = -swiper.controller.spline.interpolate(-translate);
	        }
	
	        if (!controlledTranslate || swiper.params.controller.by === 'container') {
	          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
	          controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
	        }
	
	        if (swiper.params.controller.inverse) {
	          controlledTranslate = c.maxTranslate() - controlledTranslate;
	        }
	        c.updateProgress(controlledTranslate);
	        c.setTranslate(controlledTranslate, swiper);
	        c.updateActiveIndex();
	        c.updateSlidesClasses();
	      }
	      if (Array.isArray(controlled)) {
	        for (var i = 0; i < controlled.length; i += 1) {
	          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	            setControlledTranslate(controlled[i]);
	          }
	        }
	      } else if (controlled instanceof Swiper && byController !== controlled) {
	        setControlledTranslate(controlled);
	      }
	    },
	    setTransition: function setTransition(duration, byController) {
	      var swiper = this;
	      var controlled = swiper.controller.control;
	      var i;
	      function setControlledTransition(c) {
	        c.setTransition(duration, swiper);
	        if (duration !== 0) {
	          c.transitionStart();
	          if (c.params.autoHeight) {
	            Utils.nextTick(function () {
	              c.updateAutoHeight();
	            });
	          }
	          c.$wrapperEl.transitionEnd(function () {
	            if (!controlled) { return; }
	            if (c.params.loop && swiper.params.controller.by === 'slide') {
	              c.loopFix();
	            }
	            c.transitionEnd();
	          });
	        }
	      }
	      if (Array.isArray(controlled)) {
	        for (i = 0; i < controlled.length; i += 1) {
	          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	            setControlledTransition(controlled[i]);
	          }
	        }
	      } else if (controlled instanceof Swiper && byController !== controlled) {
	        setControlledTransition(controlled);
	      }
	    },
	  };
	  var Controller$1 = {
	    name: 'controller',
	    params: {
	      controller: {
	        control: undefined,
	        inverse: false,
	        by: 'slide', // or 'container'
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        controller: {
	          control: swiper.params.controller.control,
	          getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
	          setTranslate: Controller.setTranslate.bind(swiper),
	          setTransition: Controller.setTransition.bind(swiper),
	        },
	      });
	    },
	    on: {
	      update: function update() {
	        var swiper = this;
	        if (!swiper.controller.control) { return; }
	        if (swiper.controller.spline) {
	          swiper.controller.spline = undefined;
	          delete swiper.controller.spline;
	        }
	      },
	      resize: function resize() {
	        var swiper = this;
	        if (!swiper.controller.control) { return; }
	        if (swiper.controller.spline) {
	          swiper.controller.spline = undefined;
	          delete swiper.controller.spline;
	        }
	      },
	      observerUpdate: function observerUpdate() {
	        var swiper = this;
	        if (!swiper.controller.control) { return; }
	        if (swiper.controller.spline) {
	          swiper.controller.spline = undefined;
	          delete swiper.controller.spline;
	        }
	      },
	      setTranslate: function setTranslate(translate, byController) {
	        var swiper = this;
	        if (!swiper.controller.control) { return; }
	        swiper.controller.setTranslate(translate, byController);
	      },
	      setTransition: function setTransition(duration, byController) {
	        var swiper = this;
	        if (!swiper.controller.control) { return; }
	        swiper.controller.setTransition(duration, byController);
	      },
	    },
	  };
	
	  var a11y = {
	    makeElFocusable: function makeElFocusable($el) {
	      $el.attr('tabIndex', '0');
	      return $el;
	    },
	    addElRole: function addElRole($el, role) {
	      $el.attr('role', role);
	      return $el;
	    },
	    addElLabel: function addElLabel($el, label) {
	      $el.attr('aria-label', label);
	      return $el;
	    },
	    disableEl: function disableEl($el) {
	      $el.attr('aria-disabled', true);
	      return $el;
	    },
	    enableEl: function enableEl($el) {
	      $el.attr('aria-disabled', false);
	      return $el;
	    },
	    onEnterKey: function onEnterKey(e) {
	      var swiper = this;
	      var params = swiper.params.a11y;
	      if (e.keyCode !== 13) { return; }
	      var $targetEl = $(e.target);
	      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
	        if (!(swiper.isEnd && !swiper.params.loop)) {
	          swiper.slideNext();
	        }
	        if (swiper.isEnd) {
	          swiper.a11y.notify(params.lastSlideMessage);
	        } else {
	          swiper.a11y.notify(params.nextSlideMessage);
	        }
	      }
	      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
	        if (!(swiper.isBeginning && !swiper.params.loop)) {
	          swiper.slidePrev();
	        }
	        if (swiper.isBeginning) {
	          swiper.a11y.notify(params.firstSlideMessage);
	        } else {
	          swiper.a11y.notify(params.prevSlideMessage);
	        }
	      }
	      if (swiper.pagination && $targetEl.is(("." + (swiper.params.pagination.bulletClass)))) {
	        $targetEl[0].click();
	      }
	    },
	    notify: function notify(message) {
	      var swiper = this;
	      var notification = swiper.a11y.liveRegion;
	      if (notification.length === 0) { return; }
	      notification.html('');
	      notification.html(message);
	    },
	    updateNavigation: function updateNavigation() {
	      var swiper = this;
	
	      if (swiper.params.loop) { return; }
	      var ref = swiper.navigation;
	      var $nextEl = ref.$nextEl;
	      var $prevEl = ref.$prevEl;
	
	      if ($prevEl && $prevEl.length > 0) {
	        if (swiper.isBeginning) {
	          swiper.a11y.disableEl($prevEl);
	        } else {
	          swiper.a11y.enableEl($prevEl);
	        }
	      }
	      if ($nextEl && $nextEl.length > 0) {
	        if (swiper.isEnd) {
	          swiper.a11y.disableEl($nextEl);
	        } else {
	          swiper.a11y.enableEl($nextEl);
	        }
	      }
	    },
	    updatePagination: function updatePagination() {
	      var swiper = this;
	      var params = swiper.params.a11y;
	      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	        swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
	          var $bulletEl = $(bulletEl);
	          swiper.a11y.makeElFocusable($bulletEl);
	          swiper.a11y.addElRole($bulletEl, 'button');
	          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
	        });
	      }
	    },
	    init: function init() {
	      var swiper = this;
	
	      swiper.$el.append(swiper.a11y.liveRegion);
	
	      // Navigation
	      var params = swiper.params.a11y;
	      var $nextEl;
	      var $prevEl;
	      if (swiper.navigation && swiper.navigation.$nextEl) {
	        $nextEl = swiper.navigation.$nextEl;
	      }
	      if (swiper.navigation && swiper.navigation.$prevEl) {
	        $prevEl = swiper.navigation.$prevEl;
	      }
	      if ($nextEl) {
	        swiper.a11y.makeElFocusable($nextEl);
	        swiper.a11y.addElRole($nextEl, 'button');
	        swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
	        $nextEl.on('keydown', swiper.a11y.onEnterKey);
	      }
	      if ($prevEl) {
	        swiper.a11y.makeElFocusable($prevEl);
	        swiper.a11y.addElRole($prevEl, 'button');
	        swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
	        $prevEl.on('keydown', swiper.a11y.onEnterKey);
	      }
	
	      // Pagination
	      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	        swiper.pagination.$el.on('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }
	
	      var $nextEl;
	      var $prevEl;
	      if (swiper.navigation && swiper.navigation.$nextEl) {
	        $nextEl = swiper.navigation.$nextEl;
	      }
	      if (swiper.navigation && swiper.navigation.$prevEl) {
	        $prevEl = swiper.navigation.$prevEl;
	      }
	      if ($nextEl) {
	        $nextEl.off('keydown', swiper.a11y.onEnterKey);
	      }
	      if ($prevEl) {
	        $prevEl.off('keydown', swiper.a11y.onEnterKey);
	      }
	
	      // Pagination
	      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	        swiper.pagination.$el.off('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
	      }
	    },
	  };
	  var A11y = {
	    name: 'a11y',
	    params: {
	      a11y: {
	        enabled: true,
	        notificationClass: 'swiper-notification',
	        prevSlideMessage: 'Previous slide',
	        nextSlideMessage: 'Next slide',
	        firstSlideMessage: 'This is the first slide',
	        lastSlideMessage: 'This is the last slide',
	        paginationBulletMessage: 'Go to slide {{index}}',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        a11y: {
	          liveRegion: $(("<span class=\"" + (swiper.params.a11y.notificationClass) + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")),
	        },
	      });
	      Object.keys(a11y).forEach(function (methodName) {
	        swiper.a11y[methodName] = a11y[methodName].bind(swiper);
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        if (!swiper.params.a11y.enabled) { return; }
	        swiper.a11y.init();
	        swiper.a11y.updateNavigation();
	      },
	      toEdge: function toEdge() {
	        var swiper = this;
	        if (!swiper.params.a11y.enabled) { return; }
	        swiper.a11y.updateNavigation();
	      },
	      fromEdge: function fromEdge() {
	        var swiper = this;
	        if (!swiper.params.a11y.enabled) { return; }
	        swiper.a11y.updateNavigation();
	      },
	      paginationUpdate: function paginationUpdate() {
	        var swiper = this;
	        if (!swiper.params.a11y.enabled) { return; }
	        swiper.a11y.updatePagination();
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        if (!swiper.params.a11y.enabled) { return; }
	        swiper.a11y.destroy();
	      },
	    },
	  };
	
	  var History = {
	    init: function init() {
	      var swiper = this;
	      if (!swiper.params.history) { return; }
	      if (!win.history || !win.history.pushState) {
	        swiper.params.history.enabled = false;
	        swiper.params.hashNavigation.enabled = true;
	        return;
	      }
	      var history = swiper.history;
	      history.initialized = true;
	      history.paths = History.getPathValues();
	      if (!history.paths.key && !history.paths.value) { return; }
	      history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
	      if (!swiper.params.history.replaceState) {
	        win.addEventListener('popstate', swiper.history.setHistoryPopState);
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      if (!swiper.params.history.replaceState) {
	        win.removeEventListener('popstate', swiper.history.setHistoryPopState);
	      }
	    },
	    setHistoryPopState: function setHistoryPopState() {
	      var swiper = this;
	      swiper.history.paths = History.getPathValues();
	      swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
	    },
	    getPathValues: function getPathValues() {
	      var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) { return part !== ''; });
	      var total = pathArray.length;
	      var key = pathArray[total - 2];
	      var value = pathArray[total - 1];
	      return { key: key, value: value };
	    },
	    setHistory: function setHistory(key, index) {
	      var swiper = this;
	      if (!swiper.history.initialized || !swiper.params.history.enabled) { return; }
	      var slide = swiper.slides.eq(index);
	      var value = History.slugify(slide.attr('data-history'));
	      if (!win.location.pathname.includes(key)) {
	        value = key + "/" + value;
	      }
	      var currentState = win.history.state;
	      if (currentState && currentState.value === value) {
	        return;
	      }
	      if (swiper.params.history.replaceState) {
	        win.history.replaceState({ value: value }, null, value);
	      } else {
	        win.history.pushState({ value: value }, null, value);
	      }
	    },
	    slugify: function slugify(text) {
	      return text.toString()
	        .replace(/\s+/g, '-')
	        .replace(/[^\w-]+/g, '')
	        .replace(/--+/g, '-')
	        .replace(/^-+/, '')
	        .replace(/-+$/, '');
	    },
	    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
	      var swiper = this;
	      if (value) {
	        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
	          var slide = swiper.slides.eq(i);
	          var slideHistory = History.slugify(slide.attr('data-history'));
	          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
	            var index = slide.index();
	            swiper.slideTo(index, speed, runCallbacks);
	          }
	        }
	      } else {
	        swiper.slideTo(0, speed, runCallbacks);
	      }
	    },
	  };
	
	  var History$1 = {
	    name: 'history',
	    params: {
	      history: {
	        enabled: false,
	        replaceState: false,
	        key: 'slides',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        history: {
	          init: History.init.bind(swiper),
	          setHistory: History.setHistory.bind(swiper),
	          setHistoryPopState: History.setHistoryPopState.bind(swiper),
	          scrollToSlide: History.scrollToSlide.bind(swiper),
	          destroy: History.destroy.bind(swiper),
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        if (swiper.params.history.enabled) {
	          swiper.history.init();
	        }
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        if (swiper.params.history.enabled) {
	          swiper.history.destroy();
	        }
	      },
	      transitionEnd: function transitionEnd() {
	        var swiper = this;
	        if (swiper.history.initialized) {
	          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
	        }
	      },
	    },
	  };
	
	  var HashNavigation = {
	    onHashCange: function onHashCange() {
	      var swiper = this;
	      var newHash = doc.location.hash.replace('#', '');
	      var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
	      if (newHash !== activeSlideHash) {
	        var newIndex = swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-hash=\"" + newHash + "\"]")).index();
	        if (typeof newIndex === 'undefined') { return; }
	        swiper.slideTo(newIndex);
	      }
	    },
	    setHash: function setHash() {
	      var swiper = this;
	      if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) { return; }
	      if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
	        win.history.replaceState(null, null, (("#" + (swiper.slides.eq(swiper.activeIndex).attr('data-hash'))) || ''));
	      } else {
	        var slide = swiper.slides.eq(swiper.activeIndex);
	        var hash = slide.attr('data-hash') || slide.attr('data-history');
	        doc.location.hash = hash || '';
	      }
	    },
	    init: function init() {
	      var swiper = this;
	      if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) { return; }
	      swiper.hashNavigation.initialized = true;
	      var hash = doc.location.hash.replace('#', '');
	      if (hash) {
	        var speed = 0;
	        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
	          var slide = swiper.slides.eq(i);
	          var slideHash = slide.attr('data-hash') || slide.attr('data-history');
	          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
	            var index = slide.index();
	            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
	          }
	        }
	      }
	      if (swiper.params.hashNavigation.watchState) {
	        $(win).on('hashchange', swiper.hashNavigation.onHashCange);
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      if (swiper.params.hashNavigation.watchState) {
	        $(win).off('hashchange', swiper.hashNavigation.onHashCange);
	      }
	    },
	  };
	  var HashNavigation$1 = {
	    name: 'hash-navigation',
	    params: {
	      hashNavigation: {
	        enabled: false,
	        replaceState: false,
	        watchState: false,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        hashNavigation: {
	          initialized: false,
	          init: HashNavigation.init.bind(swiper),
	          destroy: HashNavigation.destroy.bind(swiper),
	          setHash: HashNavigation.setHash.bind(swiper),
	          onHashCange: HashNavigation.onHashCange.bind(swiper),
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        if (swiper.params.hashNavigation.enabled) {
	          swiper.hashNavigation.init();
	        }
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        if (swiper.params.hashNavigation.enabled) {
	          swiper.hashNavigation.destroy();
	        }
	      },
	      transitionEnd: function transitionEnd() {
	        var swiper = this;
	        if (swiper.hashNavigation.initialized) {
	          swiper.hashNavigation.setHash();
	        }
	      },
	    },
	  };
	
	  /* eslint no-underscore-dangle: "off" */
	
	  var Autoplay = {
	    run: function run() {
	      var swiper = this;
	      var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
	      var delay = swiper.params.autoplay.delay;
	      if ($activeSlideEl.attr('data-swiper-autoplay')) {
	        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
	      }
	      swiper.autoplay.timeout = Utils.nextTick(function () {
	        if (swiper.params.autoplay.reverseDirection) {
	          if (swiper.params.loop) {
	            swiper.loopFix();
	            swiper.slidePrev(swiper.params.speed, true, true);
	            swiper.emit('autoplay');
	          } else if (!swiper.isBeginning) {
	            swiper.slidePrev(swiper.params.speed, true, true);
	            swiper.emit('autoplay');
	          } else if (!swiper.params.autoplay.stopOnLastSlide) {
	            swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
	            swiper.emit('autoplay');
	          } else {
	            swiper.autoplay.stop();
	          }
	        } else if (swiper.params.loop) {
	          swiper.loopFix();
	          swiper.slideNext(swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else if (!swiper.isEnd) {
	          swiper.slideNext(swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else if (!swiper.params.autoplay.stopOnLastSlide) {
	          swiper.slideTo(0, swiper.params.speed, true, true);
	          swiper.emit('autoplay');
	        } else {
	          swiper.autoplay.stop();
	        }
	      }, delay);
	    },
	    start: function start() {
	      var swiper = this;
	      if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }
	      if (swiper.autoplay.running) { return false; }
	      swiper.autoplay.running = true;
	      swiper.emit('autoplayStart');
	      swiper.autoplay.run();
	      return true;
	    },
	    stop: function stop() {
	      var swiper = this;
	      if (!swiper.autoplay.running) { return false; }
	      if (typeof swiper.autoplay.timeout === 'undefined') { return false; }
	
	      if (swiper.autoplay.timeout) {
	        clearTimeout(swiper.autoplay.timeout);
	        swiper.autoplay.timeout = undefined;
	      }
	      swiper.autoplay.running = false;
	      swiper.emit('autoplayStop');
	      return true;
	    },
	    pause: function pause(speed) {
	      var swiper = this;
	      if (!swiper.autoplay.running) { return; }
	      if (swiper.autoplay.paused) { return; }
	      if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }
	      swiper.autoplay.paused = true;
	      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
	        swiper.autoplay.paused = false;
	        swiper.autoplay.run();
	      } else {
	        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
	        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
	      }
	    },
	  };
	
	  var Autoplay$1 = {
	    name: 'autoplay',
	    params: {
	      autoplay: {
	        enabled: false,
	        delay: 3000,
	        waitForTransition: true,
	        disableOnInteraction: true,
	        stopOnLastSlide: false,
	        reverseDirection: false,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        autoplay: {
	          running: false,
	          paused: false,
	          run: Autoplay.run.bind(swiper),
	          start: Autoplay.start.bind(swiper),
	          stop: Autoplay.stop.bind(swiper),
	          pause: Autoplay.pause.bind(swiper),
	          onTransitionEnd: function onTransitionEnd(e) {
	            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) { return; }
	            if (e.target !== this) { return; }
	            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
	            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
	            swiper.autoplay.paused = false;
	            if (!swiper.autoplay.running) {
	              swiper.autoplay.stop();
	            } else {
	              swiper.autoplay.run();
	            }
	          },
	        },
	      });
	    },
	    on: {
	      init: function init() {
	        var swiper = this;
	        if (swiper.params.autoplay.enabled) {
	          swiper.autoplay.start();
	        }
	      },
	      beforeTransitionStart: function beforeTransitionStart(speed, internal) {
	        var swiper = this;
	        if (swiper.autoplay.running) {
	          if (internal || !swiper.params.autoplay.disableOnInteraction) {
	            swiper.autoplay.pause(speed);
	          } else {
	            swiper.autoplay.stop();
	          }
	        }
	      },
	      sliderFirstMove: function sliderFirstMove() {
	        var swiper = this;
	        if (swiper.autoplay.running) {
	          if (swiper.params.autoplay.disableOnInteraction) {
	            swiper.autoplay.stop();
	          } else {
	            swiper.autoplay.pause();
	          }
	        }
	      },
	      destroy: function destroy() {
	        var swiper = this;
	        if (swiper.autoplay.running) {
	          swiper.autoplay.stop();
	        }
	      },
	    },
	  };
	
	  var Fade = {
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      var slides = swiper.slides;
	      for (var i = 0; i < slides.length; i += 1) {
	        var $slideEl = swiper.slides.eq(i);
	        var offset = $slideEl[0].swiperSlideOffset;
	        var tx = -offset;
	        if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }
	        var ty = 0;
	        if (!swiper.isHorizontal()) {
	          ty = tx;
	          tx = 0;
	        }
	        var slideOpacity = swiper.params.fadeEffect.crossFade
	          ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
	          : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
	        $slideEl
	          .css({
	            opacity: slideOpacity,
	          })
	          .transform(("translate3d(" + tx + "px, " + ty + "px, 0px)"));
	      }
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      var slides = swiper.slides;
	      var $wrapperEl = swiper.$wrapperEl;
	      slides.transition(duration);
	      if (swiper.params.virtualTranslate && duration !== 0) {
	        var eventTriggered = false;
	        slides.transitionEnd(function () {
	          if (eventTriggered) { return; }
	          if (!swiper || swiper.destroyed) { return; }
	          eventTriggered = true;
	          swiper.animating = false;
	          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	          for (var i = 0; i < triggerEvents.length; i += 1) {
	            $wrapperEl.trigger(triggerEvents[i]);
	          }
	        });
	      }
	    },
	  };
	
	  var EffectFade = {
	    name: 'effect-fade',
	    params: {
	      fadeEffect: {
	        crossFade: false,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        fadeEffect: {
	          setTranslate: Fade.setTranslate.bind(swiper),
	          setTransition: Fade.setTransition.bind(swiper),
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        if (swiper.params.effect !== 'fade') { return; }
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "fade"));
	        var overwriteParams = {
	          slidesPerView: 1,
	          slidesPerColumn: 1,
	          slidesPerGroup: 1,
	          watchSlidesProgress: true,
	          spaceBetween: 0,
	          virtualTranslate: true,
	        };
	        Utils.extend(swiper.params, overwriteParams);
	        Utils.extend(swiper.originalParams, overwriteParams);
	      },
	      setTranslate: function setTranslate() {
	        var swiper = this;
	        if (swiper.params.effect !== 'fade') { return; }
	        swiper.fadeEffect.setTranslate();
	      },
	      setTransition: function setTransition(duration) {
	        var swiper = this;
	        if (swiper.params.effect !== 'fade') { return; }
	        swiper.fadeEffect.setTransition(duration);
	      },
	    },
	  };
	
	  var Cube = {
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      var $el = swiper.$el;
	      var $wrapperEl = swiper.$wrapperEl;
	      var slides = swiper.slides;
	      var swiperWidth = swiper.width;
	      var swiperHeight = swiper.height;
	      var rtl = swiper.rtlTranslate;
	      var swiperSize = swiper.size;
	      var params = swiper.params.cubeEffect;
	      var isHorizontal = swiper.isHorizontal();
	      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	      var wrapperRotate = 0;
	      var $cubeShadowEl;
	      if (params.shadow) {
	        if (isHorizontal) {
	          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
	          if ($cubeShadowEl.length === 0) {
	            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
	            $wrapperEl.append($cubeShadowEl);
	          }
	          $cubeShadowEl.css({ height: (swiperWidth + "px") });
	        } else {
	          $cubeShadowEl = $el.find('.swiper-cube-shadow');
	          if ($cubeShadowEl.length === 0) {
	            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
	            $el.append($cubeShadowEl);
	          }
	        }
	      }
	      for (var i = 0; i < slides.length; i += 1) {
	        var $slideEl = slides.eq(i);
	        var slideIndex = i;
	        if (isVirtual) {
	          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
	        }
	        var slideAngle = slideIndex * 90;
	        var round = Math.floor(slideAngle / 360);
	        if (rtl) {
	          slideAngle = -slideAngle;
	          round = Math.floor(-slideAngle / 360);
	        }
	        var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	        var tx = 0;
	        var ty = 0;
	        var tz = 0;
	        if (slideIndex % 4 === 0) {
	          tx = -round * 4 * swiperSize;
	          tz = 0;
	        } else if ((slideIndex - 1) % 4 === 0) {
	          tx = 0;
	          tz = -round * 4 * swiperSize;
	        } else if ((slideIndex - 2) % 4 === 0) {
	          tx = swiperSize + (round * 4 * swiperSize);
	          tz = swiperSize;
	        } else if ((slideIndex - 3) % 4 === 0) {
	          tx = -swiperSize;
	          tz = (3 * swiperSize) + (swiperSize * 4 * round);
	        }
	        if (rtl) {
	          tx = -tx;
	        }
	
	        if (!isHorizontal) {
	          ty = tx;
	          tx = 0;
	        }
	
	        var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
	        if (progress <= 1 && progress > -1) {
	          wrapperRotate = (slideIndex * 90) + (progress * 90);
	          if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }
	        }
	        $slideEl.transform(transform);
	        if (params.slideShadows) {
	          // Set shadows
	          var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	          var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	          if (shadowBefore.length === 0) {
	            shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
	            $slideEl.append(shadowBefore);
	          }
	          if (shadowAfter.length === 0) {
	            shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
	            $slideEl.append(shadowAfter);
	          }
	          if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
	          if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
	        }
	      }
	      $wrapperEl.css({
	        '-webkit-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	        '-moz-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	        '-ms-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	        'transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	      });
	
	      if (params.shadow) {
	        if (isHorizontal) {
	          $cubeShadowEl.transform(("translate3d(0px, " + ((swiperWidth / 2) + params.shadowOffset) + "px, " + (-swiperWidth / 2) + "px) rotateX(90deg) rotateZ(0deg) scale(" + (params.shadowScale) + ")"));
	        } else {
	          var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
	          var multiplier = 1.5 - (
	            (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
	            + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
	          );
	          var scale1 = params.shadowScale;
	          var scale2 = params.shadowScale / multiplier;
	          var offset = params.shadowOffset;
	          $cubeShadowEl.transform(("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + ((swiperHeight / 2) + offset) + "px, " + (-swiperHeight / 2 / scale2) + "px) rotateX(-90deg)"));
	        }
	      }
	      var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
	      $wrapperEl
	        .transform(("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)"));
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      var $el = swiper.$el;
	      var slides = swiper.slides;
	      slides
	        .transition(duration)
	        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	        .transition(duration);
	      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
	        $el.find('.swiper-cube-shadow').transition(duration);
	      }
	    },
	  };
	
	  var EffectCube = {
	    name: 'effect-cube',
	    params: {
	      cubeEffect: {
	        slideShadows: true,
	        shadow: true,
	        shadowOffset: 20,
	        shadowScale: 0.94,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        cubeEffect: {
	          setTranslate: Cube.setTranslate.bind(swiper),
	          setTransition: Cube.setTransition.bind(swiper),
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        if (swiper.params.effect !== 'cube') { return; }
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "cube"));
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
	        var overwriteParams = {
	          slidesPerView: 1,
	          slidesPerColumn: 1,
	          slidesPerGroup: 1,
	          watchSlidesProgress: true,
	          resistanceRatio: 0,
	          spaceBetween: 0,
	          centeredSlides: false,
	          virtualTranslate: true,
	        };
	        Utils.extend(swiper.params, overwriteParams);
	        Utils.extend(swiper.originalParams, overwriteParams);
	      },
	      setTranslate: function setTranslate() {
	        var swiper = this;
	        if (swiper.params.effect !== 'cube') { return; }
	        swiper.cubeEffect.setTranslate();
	      },
	      setTransition: function setTransition(duration) {
	        var swiper = this;
	        if (swiper.params.effect !== 'cube') { return; }
	        swiper.cubeEffect.setTransition(duration);
	      },
	    },
	  };
	
	  var Flip = {
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      var slides = swiper.slides;
	      var rtl = swiper.rtlTranslate;
	      for (var i = 0; i < slides.length; i += 1) {
	        var $slideEl = slides.eq(i);
	        var progress = $slideEl[0].progress;
	        if (swiper.params.flipEffect.limitRotation) {
	          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	        }
	        var offset = $slideEl[0].swiperSlideOffset;
	        var rotate = -180 * progress;
	        var rotateY = rotate;
	        var rotateX = 0;
	        var tx = -offset;
	        var ty = 0;
	        if (!swiper.isHorizontal()) {
	          ty = tx;
	          tx = 0;
	          rotateX = -rotateY;
	          rotateY = 0;
	        } else if (rtl) {
	          rotateY = -rotateY;
	        }
	
	        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
	
	        if (swiper.params.flipEffect.slideShadows) {
	          // Set shadows
	          var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	          var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	          if (shadowBefore.length === 0) {
	            shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>"));
	            $slideEl.append(shadowBefore);
	          }
	          if (shadowAfter.length === 0) {
	            shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>"));
	            $slideEl.append(shadowAfter);
	          }
	          if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
	          if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
	        }
	        $slideEl
	          .transform(("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)"));
	      }
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      var slides = swiper.slides;
	      var activeIndex = swiper.activeIndex;
	      var $wrapperEl = swiper.$wrapperEl;
	      slides
	        .transition(duration)
	        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	        .transition(duration);
	      if (swiper.params.virtualTranslate && duration !== 0) {
	        var eventTriggered = false;
	        // eslint-disable-next-line
	        slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
	          if (eventTriggered) { return; }
	          if (!swiper || swiper.destroyed) { return; }
	          // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
	          eventTriggered = true;
	          swiper.animating = false;
	          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	          for (var i = 0; i < triggerEvents.length; i += 1) {
	            $wrapperEl.trigger(triggerEvents[i]);
	          }
	        });
	      }
	    },
	  };
	
	  var EffectFlip = {
	    name: 'effect-flip',
	    params: {
	      flipEffect: {
	        slideShadows: true,
	        limitRotation: true,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        flipEffect: {
	          setTranslate: Flip.setTranslate.bind(swiper),
	          setTransition: Flip.setTransition.bind(swiper),
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        if (swiper.params.effect !== 'flip') { return; }
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "flip"));
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
	        var overwriteParams = {
	          slidesPerView: 1,
	          slidesPerColumn: 1,
	          slidesPerGroup: 1,
	          watchSlidesProgress: true,
	          spaceBetween: 0,
	          virtualTranslate: true,
	        };
	        Utils.extend(swiper.params, overwriteParams);
	        Utils.extend(swiper.originalParams, overwriteParams);
	      },
	      setTranslate: function setTranslate() {
	        var swiper = this;
	        if (swiper.params.effect !== 'flip') { return; }
	        swiper.flipEffect.setTranslate();
	      },
	      setTransition: function setTransition(duration) {
	        var swiper = this;
	        if (swiper.params.effect !== 'flip') { return; }
	        swiper.flipEffect.setTransition(duration);
	      },
	    },
	  };
	
	  var Coverflow = {
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      var swiperWidth = swiper.width;
	      var swiperHeight = swiper.height;
	      var slides = swiper.slides;
	      var $wrapperEl = swiper.$wrapperEl;
	      var slidesSizesGrid = swiper.slidesSizesGrid;
	      var params = swiper.params.coverflowEffect;
	      var isHorizontal = swiper.isHorizontal();
	      var transform = swiper.translate;
	      var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
	      var rotate = isHorizontal ? params.rotate : -params.rotate;
	      var translate = params.depth;
	      // Each slide offset from center
	      for (var i = 0, length = slides.length; i < length; i += 1) {
	        var $slideEl = slides.eq(i);
	        var slideSize = slidesSizesGrid[i];
	        var slideOffset = $slideEl[0].swiperSlideOffset;
	        var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;
	
	        var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
	        var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
	        // var rotateZ = 0
	        var translateZ = -translate * Math.abs(offsetMultiplier);
	
	        var translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
	        var translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;
	
	        // Fix for ultra small values
	        if (Math.abs(translateX) < 0.001) { translateX = 0; }
	        if (Math.abs(translateY) < 0.001) { translateY = 0; }
	        if (Math.abs(translateZ) < 0.001) { translateZ = 0; }
	        if (Math.abs(rotateY) < 0.001) { rotateY = 0; }
	        if (Math.abs(rotateX) < 0.001) { rotateX = 0; }
	
	        var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
	
	        $slideEl.transform(slideTransform);
	        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
	        if (params.slideShadows) {
	          // Set shadows
	          var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	          var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	          if ($shadowBeforeEl.length === 0) {
	            $shadowBeforeEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
	            $slideEl.append($shadowBeforeEl);
	          }
	          if ($shadowAfterEl.length === 0) {
	            $shadowAfterEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
	            $slideEl.append($shadowAfterEl);
	          }
	          if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }
	          if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }
	        }
	      }
	
	      // Set correct perspective for IE10
	      if (Support.pointerEvents || Support.prefixedPointerEvents) {
	        var ws = $wrapperEl[0].style;
	        ws.perspectiveOrigin = center + "px 50%";
	      }
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      swiper.slides
	        .transition(duration)
	        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	        .transition(duration);
	    },
	  };
	
	  var EffectCoverflow = {
	    name: 'effect-coverflow',
	    params: {
	      coverflowEffect: {
	        rotate: 50,
	        stretch: 0,
	        depth: 100,
	        modifier: 1,
	        slideShadows: true,
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        coverflowEffect: {
	          setTranslate: Coverflow.setTranslate.bind(swiper),
	          setTransition: Coverflow.setTransition.bind(swiper),
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        if (swiper.params.effect !== 'coverflow') { return; }
	
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "coverflow"));
	        swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
	
	        swiper.params.watchSlidesProgress = true;
	        swiper.originalParams.watchSlidesProgress = true;
	      },
	      setTranslate: function setTranslate() {
	        var swiper = this;
	        if (swiper.params.effect !== 'coverflow') { return; }
	        swiper.coverflowEffect.setTranslate();
	      },
	      setTransition: function setTransition(duration) {
	        var swiper = this;
	        if (swiper.params.effect !== 'coverflow') { return; }
	        swiper.coverflowEffect.setTransition(duration);
	      },
	    },
	  };
	
	  var Thumbs = {
	    init: function init() {
	      var swiper = this;
	      var ref = swiper.params;
	      var thumbsParams = ref.thumbs;
	      var SwiperClass = swiper.constructor;
	      if (thumbsParams.swiper instanceof SwiperClass) {
	        swiper.thumbs.swiper = thumbsParams.swiper;
	        Utils.extend(swiper.thumbs.swiper.originalParams, {
	          watchSlidesProgress: true,
	          slideToClickedSlide: false,
	        });
	        Utils.extend(swiper.thumbs.swiper.params, {
	          watchSlidesProgress: true,
	          slideToClickedSlide: false,
	        });
	      } else if (Utils.isObject(thumbsParams.swiper)) {
	        swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
	          watchSlidesVisibility: true,
	          watchSlidesProgress: true,
	          slideToClickedSlide: false,
	        }));
	        swiper.thumbs.swiperCreated = true;
	      }
	      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
	      swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
	    },
	    onThumbClick: function onThumbClick() {
	      var swiper = this;
	      var thumbsSwiper = swiper.thumbs.swiper;
	      if (!thumbsSwiper) { return; }
	      var clickedIndex = thumbsSwiper.clickedIndex;
	      var clickedSlide = thumbsSwiper.clickedSlide;
	      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) { return; }
	      if (typeof clickedIndex === 'undefined' || clickedIndex === null) { return; }
	      var slideToIndex;
	      if (thumbsSwiper.params.loop) {
	        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
	      } else {
	        slideToIndex = clickedIndex;
	      }
	      if (swiper.params.loop) {
	        var currentIndex = swiper.activeIndex;
	        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
	          swiper.loopFix();
	          // eslint-disable-next-line
	          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	          currentIndex = swiper.activeIndex;
	        }
	        var prevIndex = swiper.slides.eq(currentIndex).prevAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
	        var nextIndex = swiper.slides.eq(currentIndex).nextAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
	        if (typeof prevIndex === 'undefined') { slideToIndex = nextIndex; }
	        else if (typeof nextIndex === 'undefined') { slideToIndex = prevIndex; }
	        else if (nextIndex - currentIndex < currentIndex - prevIndex) { slideToIndex = nextIndex; }
	        else { slideToIndex = prevIndex; }
	      }
	      swiper.slideTo(slideToIndex);
	    },
	    update: function update(initial) {
	      var swiper = this;
	      var thumbsSwiper = swiper.thumbs.swiper;
	      if (!thumbsSwiper) { return; }
	
	      var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
	        ? thumbsSwiper.slidesPerViewDynamic()
	        : thumbsSwiper.params.slidesPerView;
	
	      if (swiper.realIndex !== thumbsSwiper.realIndex) {
	        var currentThumbsIndex = thumbsSwiper.activeIndex;
	        var newThumbsIndex;
	        if (thumbsSwiper.params.loop) {
	          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
	            thumbsSwiper.loopFix();
	            // eslint-disable-next-line
	            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
	            currentThumbsIndex = thumbsSwiper.activeIndex;
	          }
	          // Find actual thumbs index to slide to
	          var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
	          var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
	          if (typeof prevThumbsIndex === 'undefined') { newThumbsIndex = nextThumbsIndex; }
	          else if (typeof nextThumbsIndex === 'undefined') { newThumbsIndex = prevThumbsIndex; }
	          else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = currentThumbsIndex; }
	          else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = nextThumbsIndex; }
	          else { newThumbsIndex = prevThumbsIndex; }
	        } else {
	          newThumbsIndex = swiper.realIndex;
	        }
	        if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
	          if (thumbsSwiper.params.centeredSlides) {
	            if (newThumbsIndex > currentThumbsIndex) {
	              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
	            } else {
	              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
	            }
	          } else if (newThumbsIndex > currentThumbsIndex) {
	            newThumbsIndex = newThumbsIndex - slidesPerView + 1;
	          }
	          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
	        }
	      }
	
	      // Activate thumbs
	      var thumbsToActivate = 1;
	      var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
	
	      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
	        thumbsToActivate = swiper.params.slidesPerView;
	      }
	
	      thumbsSwiper.slides.removeClass(thumbActiveClass);
	      if (thumbsSwiper.params.loop) {
	        for (var i = 0; i < thumbsToActivate; i += 1) {
	          thumbsSwiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]")).addClass(thumbActiveClass);
	        }
	      } else {
	        for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
	          thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
	        }
	      }
	    },
	  };
	  var Thumbs$1 = {
	    name: 'thumbs',
	    params: {
	      thumbs: {
	        swiper: null,
	        slideThumbActiveClass: 'swiper-slide-thumb-active',
	        thumbsContainerClass: 'swiper-container-thumbs',
	      },
	    },
	    create: function create() {
	      var swiper = this;
	      Utils.extend(swiper, {
	        thumbs: {
	          swiper: null,
	          init: Thumbs.init.bind(swiper),
	          update: Thumbs.update.bind(swiper),
	          onThumbClick: Thumbs.onThumbClick.bind(swiper),
	        },
	      });
	    },
	    on: {
	      beforeInit: function beforeInit() {
	        var swiper = this;
	        var ref = swiper.params;
	        var thumbs = ref.thumbs;
	        if (!thumbs || !thumbs.swiper) { return; }
	        swiper.thumbs.init();
	        swiper.thumbs.update(true);
	      },
	      slideChange: function slideChange() {
	        var swiper = this;
	        if (!swiper.thumbs.swiper) { return; }
	        swiper.thumbs.update();
	      },
	      update: function update() {
	        var swiper = this;
	        if (!swiper.thumbs.swiper) { return; }
	        swiper.thumbs.update();
	      },
	      resize: function resize() {
	        var swiper = this;
	        if (!swiper.thumbs.swiper) { return; }
	        swiper.thumbs.update();
	      },
	      observerUpdate: function observerUpdate() {
	        var swiper = this;
	        if (!swiper.thumbs.swiper) { return; }
	        swiper.thumbs.update();
	      },
	      setTransition: function setTransition(duration) {
	        var swiper = this;
	        var thumbsSwiper = swiper.thumbs.swiper;
	        if (!thumbsSwiper) { return; }
	        thumbsSwiper.setTransition(duration);
	      },
	      beforeDestroy: function beforeDestroy() {
	        var swiper = this;
	        var thumbsSwiper = swiper.thumbs.swiper;
	        if (!thumbsSwiper) { return; }
	        if (swiper.thumbs.swiperCreated && thumbsSwiper) {
	          thumbsSwiper.destroy();
	        }
	      },
	    },
	  };
	
	  // Swiper Class
	
	  var components = [
	    Device$1,
	    Support$1,
	    Browser$1,
	    Resize,
	    Observer$1,
	    Virtual$1,
	    Keyboard$1,
	    Mousewheel$1,
	    Navigation$1,
	    Pagination$1,
	    Scrollbar$1,
	    Parallax$1,
	    Zoom$1,
	    Lazy$1,
	    Controller$1,
	    A11y,
	    History$1,
	    HashNavigation$1,
	    Autoplay$1,
	    EffectFade,
	    EffectCube,
	    EffectFlip,
	    EffectCoverflow,
	    Thumbs$1
	  ];
	
	  if (typeof Swiper.use === 'undefined') {
	    Swiper.use = Swiper.Class.use;
	    Swiper.installModule = Swiper.Class.installModule;
	  }
	
	  Swiper.use(components);
	
	  return Swiper;
	
	}));


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(431);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(379)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(431, function() {
				var newContent = __webpack_require__(431);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(378)();
	// imports
	
	
	// module
	exports.push([module.id, ".swiper-container{margin:0 auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-no-flexbox .swiper-slide{float:left}.swiper-container-vertical>.swiper-wrapper{-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-ms-flexbox;display:flex;transition-property:transform;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{transform:translateZ(0)}.swiper-container-multirow>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-slide{-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-ms-flex-align:start;align-items:flex-start;transition-property:transform,height}.swiper-container-3d{perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:linear-gradient(270deg,rgba(0,0,0,.5),transparent)}.swiper-container-3d .swiper-slide-shadow-right{background-image:linear-gradient(90deg,rgba(0,0,0,.5),transparent)}.swiper-container-3d .swiper-slide-shadow-top{background-image:linear-gradient(0deg,rgba(0,0,0,.5),transparent)}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(180deg,rgba(0,0,0,.5),transparent)}.swiper-container-wp8-horizontal,.swiper-container-wp8-horizontal>.swiper-wrapper{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-wp8-vertical,.swiper-container-wp8-vertical>.swiper-wrapper{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:27px;height:44px;margin-top:-22px;z-index:10;cursor:pointer;background-size:27px 44px;background-position:50%;background-repeat:no-repeat}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 27 44'%3E%3Cpath d='M0 22L22 0l2.1 2.1L4.2 22l19.9 19.9L22 44 0 22z' fill='%23007aff'/%3E%3C/svg%3E\");left:10px;right:auto}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 27 44'%3E%3Cpath d='M27 22L5 44l-2.1-2.1L22.8 22 2.9 2.1 5 0l22 22z' fill='%23007aff'/%3E%3C/svg%3E\");right:10px;left:auto}.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 27 44'%3E%3Cpath d='M0 22L22 0l2.1 2.1L4.2 22l19.9 19.9L22 44 0 22z' fill='%23fff'/%3E%3C/svg%3E\")}.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 27 44'%3E%3Cpath d='M27 22L5 44l-2.1-2.1L22.8 22 2.9 2.1 5 0l22 22z' fill='%23fff'/%3E%3C/svg%3E\")}.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 27 44'%3E%3Cpath d='M0 22L22 0l2.1 2.1L4.2 22l19.9 19.9L22 44 0 22z'/%3E%3C/svg%3E\")}.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 27 44'%3E%3Cpath d='M27 22L5 44l-2.1-2.1L22.8 22 2.9 2.1 5 0l22 22z'/%3E%3C/svg%3E\")}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:opacity .3s;transform:translateZ(0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-container-horizontal>.swiper-pagination-bullets,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active,.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:100%;background:#000;opacity:.2}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1;background:#007aff}.swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;transform:translate3d(0,-50%,0)}.swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:top .2s,-webkit-transform .2s;transition:transform .2s,top .2s;transition:transform .2s,top .2s,-webkit-transform .2s}.swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:left .2s,-webkit-transform .2s;transition:transform .2s,left .2s;transition:transform .2s,left .2s,-webkit-transform .2s}.swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:right .2s,-webkit-transform .2s;transition:transform .2s,right .2s;transition:transform .2s,right .2s,-webkit-transform .2s}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:#007aff;position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-container-horizontal>.swiper-pagination-progressbar,.swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-container-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-white .swiper-pagination-bullet-active{background:#fff}.swiper-pagination-progressbar.swiper-pagination-white{background:hsla(0,0%,100%,.25)}.swiper-pagination-progressbar.swiper-pagination-white .swiper-pagination-progressbar-fill{background:#fff}.swiper-pagination-black .swiper-pagination-bullet-active{background:#000}.swiper-pagination-progressbar.swiper-pagination-black{background:rgba(0,0,0,.25)}.swiper-pagination-progressbar.swiper-pagination-black .swiper-pagination-progressbar-fill{background:#000}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;animation:swiper-preloader-spin 1s steps(12) infinite}.swiper-lazy-preloader:after{display:block;content:\"\";width:100%;height:100%;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 120 120' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cdefs%3E%3Cpath id='a' stroke='%236c6c6c' stroke-width='11' stroke-linecap='round' d='M60 7v20'/%3E%3C/defs%3E%3Cuse xlink:href='%23a' opacity='.27'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(30 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(60 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(90 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(120 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(150 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.37' transform='rotate(180 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.46' transform='rotate(210 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.56' transform='rotate(240 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.66' transform='rotate(270 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.75' transform='rotate(300 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.85' transform='rotate(330 60 60)'/%3E%3C/svg%3E\");background-position:50%;background-size:100%;background-repeat:no-repeat}.swiper-lazy-preloader-white:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg viewBox='0 0 120 120' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Cdefs%3E%3Cpath id='a' stroke='%23fff' stroke-width='11' stroke-linecap='round' d='M60 7v20'/%3E%3C/defs%3E%3Cuse xlink:href='%23a' opacity='.27'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(30 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(60 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(90 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(120 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.27' transform='rotate(150 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.37' transform='rotate(180 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.46' transform='rotate(210 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.56' transform='rotate(240 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.66' transform='rotate(270 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.75' transform='rotate(300 60 60)'/%3E%3Cuse xlink:href='%23a' opacity='.85' transform='rotate(330 60 60)'/%3E%3C/svg%3E\")}@keyframes swiper-preloader-spin{to{transform:rotate(1turn)}}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-container-fade.swiper-container-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-container-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-container-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-cube.swiper-container-rtl .swiper-slide{transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-next+.swiper-slide,.swiper-container-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right,.swiper-container-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0;width:100%;height:100%;background:#000;opacity:.6;filter:blur(50px);z-index:0}.swiper-container-flip{overflow:visible}.swiper-container-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-container-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-flip .swiper-slide-active,.swiper-container-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-flip .swiper-slide-shadow-bottom,.swiper-container-flip .swiper-slide-shadow-left,.swiper-container-flip .swiper-slide-shadow-right,.swiper-container-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-coverflow .swiper-wrapper{-ms-perspective:1200px}", "", {"version":3,"sources":["/Users/baidu/Desktop/project/ai-web-2019/node_modules/swiper/dist/css/swiper.min.css"],"names":[],"mappings":"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","file":"swiper.min.css","sourcesContent":["/**\n * Swiper 4.5.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * http://www.idangero.us/swiper/\n *\n * Copyright 2014-2019 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: February 22, 2019\n */\n.swiper-container{margin:0 auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-no-flexbox .swiper-slide{float:left}.swiper-container-vertical>.swiper-wrapper{-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;-o-transition-property:transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-box-sizing:content-box;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.swiper-container-multirow>.swiper-wrapper{-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-slide{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;-o-transition-property:transform;transition-property:transform;transition-property:transform,-webkit-transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-transition-property:height,-webkit-transform;transition-property:height,-webkit-transform;-o-transition-property:transform,height;transition-property:transform,height;transition-property:transform,height,-webkit-transform}.swiper-container-3d{-webkit-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear,right top,left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(right,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-o-linear-gradient(right,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-o-linear-gradient(left,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear,left bottom,left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(bottom,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-o-linear-gradient(bottom,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear,left top,left bottom,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(top,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:-o-linear-gradient(top,rgba(0,0,0,.5),rgba(0,0,0,0));background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-wp8-horizontal,.swiper-container-wp8-horizontal>.swiper-wrapper{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-wp8-vertical,.swiper-container-wp8-vertical>.swiper-wrapper{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:27px;height:44px;margin-top:-22px;z-index:10;cursor:pointer;background-size:27px 44px;background-position:center;background-repeat:no-repeat}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");left:10px;right:auto}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");right:10px;left:auto}.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;-webkit-transition:.3s opacity;-o-transition:.3s opacity;transition:.3s opacity;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-container-horizontal>.swiper-pagination-bullets,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transform:scale(.33);-ms-transform:scale(.33);transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{-webkit-transform:scale(.66);-ms-transform:scale(.66);transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{-webkit-transform:scale(.33);-ms-transform:scale(.33);transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{-webkit-transform:scale(.66);-ms-transform:scale(.66);transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{-webkit-transform:scale(.33);-ms-transform:scale(.33);transform:scale(.33)}.swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:100%;background:#000;opacity:.2}button.swiper-pagination-bullet{border:none;margin:0;padding:0;-webkit-box-shadow:none;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1;background:#007aff}.swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;-webkit-transform:translate3d(0,-50%,0);transform:translate3d(0,-50%,0)}.swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);width:8px}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;-webkit-transition:.2s top,.2s -webkit-transform;transition:.2s top,.2s -webkit-transform;-o-transition:.2s transform,.2s top;transition:.2s transform,.2s top;transition:.2s transform,.2s top,.2s -webkit-transform}.swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translateX(-50%);white-space:nowrap}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:.2s left,.2s -webkit-transform;transition:.2s left,.2s -webkit-transform;-o-transition:.2s transform,.2s left;transition:.2s transform,.2s left;transition:.2s transform,.2s left,.2s -webkit-transform}.swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:.2s right,.2s -webkit-transform;transition:.2s right,.2s -webkit-transform;-o-transition:.2s transform,.2s right;transition:.2s transform,.2s right;transition:.2s transform,.2s right,.2s -webkit-transform}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:#007aff;position:absolute;left:0;top:0;width:100%;height:100%;-webkit-transform:scale(0);-ms-transform:scale(0);transform:scale(0);-webkit-transform-origin:left top;-ms-transform-origin:left top;transform-origin:left top}.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{-webkit-transform-origin:right top;-ms-transform-origin:right top;transform-origin:right top}.swiper-container-horizontal>.swiper-pagination-progressbar,.swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-container-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-white .swiper-pagination-bullet-active{background:#fff}.swiper-pagination-progressbar.swiper-pagination-white{background:rgba(255,255,255,.25)}.swiper-pagination-progressbar.swiper-pagination-white .swiper-pagination-progressbar-fill{background:#fff}.swiper-pagination-black .swiper-pagination-bullet-active{background:#000}.swiper-pagination-progressbar.swiper-pagination-black{background:rgba(0,0,0,.25)}.swiper-pagination-progressbar.swiper-pagination-black .swiper-pagination-progressbar-fill{background:#000}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;-o-object-fit:contain;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;-webkit-transform-origin:50%;-ms-transform-origin:50%;transform-origin:50%;-webkit-animation:swiper-preloader-spin 1s steps(12,end) infinite;animation:swiper-preloader-spin 1s steps(12,end) infinite}.swiper-lazy-preloader:after{display:block;content:'';width:100%;height:100%;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%236c6c6c'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\");background-position:50%;background-size:100%;background-repeat:no-repeat}.swiper-lazy-preloader-white:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%23fff'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\")}@-webkit-keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-container-fade.swiper-container-free-mode .swiper-slide{-webkit-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out}.swiper-container-fade .swiper-slide{pointer-events:none;-webkit-transition-property:opacity;-o-transition-property:opacity;transition-property:opacity}.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0;width:100%;height:100%}.swiper-container-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-cube.swiper-container-rtl .swiper-slide{-webkit-transform-origin:100% 0;-ms-transform-origin:100% 0;transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-next+.swiper-slide,.swiper-container-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right,.swiper-container-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0;width:100%;height:100%;background:#000;opacity:.6;-webkit-filter:blur(50px);filter:blur(50px);z-index:0}.swiper-container-flip{overflow:visible}.swiper-container-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-container-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-flip .swiper-slide-active,.swiper-container-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-flip .swiper-slide-shadow-bottom,.swiper-container-flip .swiper-slide-shadow-left,.swiper-container-flip .swiper-slide-shadow-right,.swiper-container-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-coverflow .swiper-wrapper{-ms-perspective:1200px}"],"sourceRoot":""}]);
	
	// exports


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;(typeof navigator !== "undefined") && (function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	            return factory(root);
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === "object" && module.exports) {
	        module.exports = factory(root);
	    } else {
	        root.lottie = factory(root);
	        root.bodymovin = root.lottie;
	    }
	}((window || {}), function(window) {
	    "use strict";
	    var svgNS = "http://www.w3.org/2000/svg";
	
	var locationHref = '';
	
	var initialDefaultFrame = -999999;
	
	var subframeEnabled = true;
	var expressionsPlugin;
	var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	var cachedColors = {};
	var bm_rounder = Math.round;
	var bm_rnd;
	var bm_pow = Math.pow;
	var bm_sqrt = Math.sqrt;
	var bm_abs = Math.abs;
	var bm_floor = Math.floor;
	var bm_max = Math.max;
	var bm_min = Math.min;
	var blitter = 10;
	
	var BMMath = {};
	(function(){
	    var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
	    var i, len = propertyNames.length;
	    for(i=0;i<len;i+=1){
	        BMMath[propertyNames[i]] = Math[propertyNames[i]];
	    }
	}());
	
	function ProjectInterface(){return {};}
	
	BMMath.random = Math.random;
	BMMath.abs = function(val){
	    var tOfVal = typeof val;
	    if(tOfVal === 'object' && val.length){
	        var absArr = createSizedArray(val.length);
	        var i, len = val.length;
	        for(i=0;i<len;i+=1){
	            absArr[i] = Math.abs(val[i]);
	        }
	        return absArr;
	    }
	    return Math.abs(val);
	
	};
	var defaultCurveSegments = 150;
	var degToRads = Math.PI/180;
	var roundCorner = 0.5519;
	
	function roundValues(flag){
	    if(flag){
	        bm_rnd = Math.round;
	    }else{
	        bm_rnd = function(val){
	            return val;
	        };
	    }
	}
	roundValues(false);
	
	function styleDiv(element){
	    element.style.position = 'absolute';
	    element.style.top = 0;
	    element.style.left = 0;
	    element.style.display = 'block';
	    element.style.transformOrigin = element.style.webkitTransformOrigin = '0 0';
	    element.style.backfaceVisibility  = element.style.webkitBackfaceVisibility = 'visible';
	    element.style.transformStyle = element.style.webkitTransformStyle = element.style.mozTransformStyle = "preserve-3d";
	}
	
	function BMEnterFrameEvent(n,c,t,d){
	    this.type = n;
	    this.currentTime = c;
	    this.totalTime = t;
	    this.direction = d < 0 ? -1:1;
	}
	
	function BMCompleteEvent(n,d){
	    this.type = n;
	    this.direction = d < 0 ? -1:1;
	}
	
	function BMCompleteLoopEvent(n,c,t,d){
	    this.type = n;
	    this.currentLoop = t;
	    this.totalLoops = c;
	    this.direction = d < 0 ? -1:1;
	}
	
	function BMSegmentStartEvent(n,f,t){
	    this.type = n;
	    this.firstFrame = f;
	    this.totalFrames = t;
	}
	
	function BMDestroyEvent(n,t){
	    this.type = n;
	    this.target = t;
	}
	
	var createElementID = (function(){
	    var _count = 0;
	    return function createID() {
	        return '__lottie_element_' + ++_count
	    }
	}())
	
	function HSVtoRGB(h, s, v) {
	    var r, g, b, i, f, p, q, t;
	    i = Math.floor(h * 6);
	    f = h * 6 - i;
	    p = v * (1 - s);
	    q = v * (1 - f * s);
	    t = v * (1 - (1 - f) * s);
	    switch (i % 6) {
	        case 0: r = v; g = t; b = p; break;
	        case 1: r = q; g = v; b = p; break;
	        case 2: r = p; g = v; b = t; break;
	        case 3: r = p; g = q; b = v; break;
	        case 4: r = t; g = p; b = v; break;
	        case 5: r = v; g = p; b = q; break;
	    }
	    return [ r,
	        g,
	         b ];
	}
	
	function RGBtoHSV(r, g, b) {
	    var max = Math.max(r, g, b), min = Math.min(r, g, b),
	        d = max - min,
	        h,
	        s = (max === 0 ? 0 : d / max),
	        v = max / 255;
	
	    switch (max) {
	        case min: h = 0; break;
	        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
	        case g: h = (b - r) + d * 2; h /= 6 * d; break;
	        case b: h = (r - g) + d * 4; h /= 6 * d; break;
	    }
	
	    return [
	         h,
	         s,
	         v
	    ];
	}
	
	function addSaturationToRGB(color,offset){
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[1] += offset;
	    if (hsv[1] > 1) {
	        hsv[1] = 1;
	    }
	    else if (hsv[1] <= 0) {
	        hsv[1] = 0;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}
	
	function addBrightnessToRGB(color,offset){
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[2] += offset;
	    if (hsv[2] > 1) {
	        hsv[2] = 1;
	    }
	    else if (hsv[2] < 0) {
	        hsv[2] = 0;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}
	
	function addHueToRGB(color,offset) {
	    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
	    hsv[0] += offset/360;
	    if (hsv[0] > 1) {
	        hsv[0] -= 1;
	    }
	    else if (hsv[0] < 0) {
	        hsv[0] += 1;
	    }
	    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
	}
	
	var rgbToHex = (function(){
	    var colorMap = [];
	    var i;
	    var hex;
	    for(i=0;i<256;i+=1){
	        hex = i.toString(16);
	        colorMap[i] = hex.length == 1 ? '0' + hex : hex;
	    }
	
	    return function(r, g, b) {
	        if(r<0){
	            r = 0;
	        }
	        if(g<0){
	            g = 0;
	        }
	        if(b<0){
	            b = 0;
	        }
	        return '#' + colorMap[r] + colorMap[g] + colorMap[b];
	    };
	}());
	function BaseEvent(){}
	BaseEvent.prototype = {
		triggerEvent: function (eventName, args) {
		    if (this._cbs[eventName]) {
		        var len = this._cbs[eventName].length;
		        for (var i = 0; i < len; i++){
		            this._cbs[eventName][i](args);
		        }
		    }
		},
		addEventListener: function (eventName, callback) {
		    if (!this._cbs[eventName]){
		        this._cbs[eventName] = [];
		    }
		    this._cbs[eventName].push(callback);
	
			return function() {
				this.removeEventListener(eventName, callback);
			}.bind(this);
		},
		removeEventListener: function (eventName,callback){
		    if (!callback){
		        this._cbs[eventName] = null;
		    }else if(this._cbs[eventName]){
		        var i = 0, len = this._cbs[eventName].length;
		        while(i<len){
		            if(this._cbs[eventName][i] === callback){
		                this._cbs[eventName].splice(i,1);
		                i -=1;
		                len -= 1;
		            }
		            i += 1;
		        }
		        if(!this._cbs[eventName].length){
		            this._cbs[eventName] = null;
		        }
		    }
		}
	};
	var createTypedArray = (function(){
		function createRegularArray(type, len){
			var i = 0, arr = [], value;
			switch(type) {
				case 'int16':
				case 'uint8c':
					value = 1;
					break;
				default:
					value = 1.1;
					break;
			}
			for(i = 0; i < len; i += 1) {
				arr.push(value);
			}
			return arr;
		}
		function createTypedArray(type, len){
			if(type === 'float32') {
				return new Float32Array(len);
			} else if(type === 'int16') {
				return new Int16Array(len);
			} else if(type === 'uint8c') {
				return new Uint8ClampedArray(len);
			}
		}
		if(typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
			return createTypedArray;
		} else {
			return createRegularArray;
		}
	}());
	
	function createSizedArray(len) {
		return Array.apply(null,{length:len});
	}
	function createNS(type) {
		//return {appendChild:function(){},setAttribute:function(){},style:{}}
		return document.createElementNS(svgNS, type);
	}
	function createTag(type) {
		//return {appendChild:function(){},setAttribute:function(){},style:{}}
		return document.createElement(type);
	}
	function DynamicPropertyContainer(){};
	DynamicPropertyContainer.prototype = {
		addDynamicProperty: function(prop) {
			if(this.dynamicProperties.indexOf(prop) === -1) {
		        this.dynamicProperties.push(prop);
		        this.container.addDynamicProperty(this);
		    	this._isAnimated = true;
		    }
		},
		iterateDynamicProperties: function(){
		    this._mdf = false;
		    var i, len = this.dynamicProperties.length;
		    for(i=0;i<len;i+=1){
		        this.dynamicProperties[i].getValue();
		        if(this.dynamicProperties[i]._mdf) {
		            this._mdf = true;
		        }
		    }
		},
		initDynamicPropertyContainer: function(container){
		    this.container = container;
		    this.dynamicProperties = [];
		    this._mdf = false;
		    this._isAnimated = false;
		}
	}
	var getBlendMode = (function() {
	
		var blendModeEnums = {
	        0:'source-over',
	        1:'multiply',
	        2:'screen',
	        3:'overlay',
	        4:'darken',
	        5:'lighten',
	        6:'color-dodge',
	        7:'color-burn',
	        8:'hard-light',
	        9:'soft-light',
	        10:'difference',
	        11:'exclusion',
	        12:'hue',
	        13:'saturation',
	        14:'color',
	        15:'luminosity'
	    }
	
		return function(mode) {
			return blendModeEnums[mode] || '';
		}
	}())
	/*!
	 Transformation Matrix v2.0
	 (c) Epistemex 2014-2015
	 www.epistemex.com
	 By Ken Fyrstenberg
	 Contributions by leeoniya.
	 License: MIT, header required.
	 */
	
	/**
	 * 2D transformation matrix object initialized with identity matrix.
	 *
	 * The matrix can synchronize a canvas context by supplying the context
	 * as an argument, or later apply current absolute transform to an
	 * existing context.
	 *
	 * All values are handled as floating point values.
	 *
	 * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
	 * @prop {number} a - scale x
	 * @prop {number} b - shear y
	 * @prop {number} c - shear x
	 * @prop {number} d - scale y
	 * @prop {number} e - translate x
	 * @prop {number} f - translate y
	 * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
	 * @constructor
	 */
	
	var Matrix = (function(){
	
	    var _cos = Math.cos;
	    var _sin = Math.sin;
	    var _tan = Math.tan;
	    var _rnd = Math.round;
	
	    function reset(){
	        this.props[0] = 1;
	        this.props[1] = 0;
	        this.props[2] = 0;
	        this.props[3] = 0;
	        this.props[4] = 0;
	        this.props[5] = 1;
	        this.props[6] = 0;
	        this.props[7] = 0;
	        this.props[8] = 0;
	        this.props[9] = 0;
	        this.props[10] = 1;
	        this.props[11] = 0;
	        this.props[12] = 0;
	        this.props[13] = 0;
	        this.props[14] = 0;
	        this.props[15] = 1;
	        return this;
	    }
	
	    function rotate(angle) {
	        if(angle === 0){
	            return this;
	        }
	        var mCos = _cos(angle);
	        var mSin = _sin(angle);
	        return this._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);
	    }
	
	    function rotateX(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = _cos(angle);
	        var mSin = _sin(angle);
	        return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin,  mCos, 0, 0, 0, 0, 1);
	    }
	
	    function rotateY(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = _cos(angle);
	        var mSin = _sin(angle);
	        return this._t(mCos,  0,  mSin, 0, 0, 1, 0, 0, -mSin,  0,  mCos, 0, 0, 0, 0, 1);
	    }
	
	    function rotateZ(angle){
	        if(angle === 0){
	            return this;
	        }
	        var mCos = _cos(angle);
	        var mSin = _sin(angle);
	        return this._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);
	    }
	
	    function shear(sx,sy){
	        return this._t(1, sy, sx, 1, 0, 0);
	    }
	
	    function skew(ax, ay){
	        return this.shear(_tan(ax), _tan(ay));
	    }
	
	    function skewFromAxis(ax, angle){
	        var mCos = _cos(angle);
	        var mSin = _sin(angle);
	        return this._t(mCos, mSin,  0, 0, -mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1)
	            ._t(1, 0,  0, 0, _tan(ax),  1, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1)
	            ._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);
	        //return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
	    }
	
	    function scale(sx, sy, sz) {
	        if(!sz && sz !== 0) {
	            sz = 1;
	        }
	        if(sx === 1 && sy === 1 && sz === 1){
	            return this;
	        }
	        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
	    }
	
	    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
	        this.props[0] = a;
	        this.props[1] = b;
	        this.props[2] = c;
	        this.props[3] = d;
	        this.props[4] = e;
	        this.props[5] = f;
	        this.props[6] = g;
	        this.props[7] = h;
	        this.props[8] = i;
	        this.props[9] = j;
	        this.props[10] = k;
	        this.props[11] = l;
	        this.props[12] = m;
	        this.props[13] = n;
	        this.props[14] = o;
	        this.props[15] = p;
	        return this;
	    }
	
	    function translate(tx, ty, tz) {
	        tz = tz || 0;
	        if(tx !== 0 || ty !== 0 || tz !== 0){
	            return this._t(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1);
	        }
	        return this;
	    }
	
	    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
	
	        var _p = this.props;
	
	        if(a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0){
	            //NOTE: commenting this condition because TurboFan deoptimizes code when present
	            //if(m2 !== 0 || n2 !== 0 || o2 !== 0){
	                _p[12] = _p[12] * a2 + _p[15] * m2;
	                _p[13] = _p[13] * f2 + _p[15] * n2;
	                _p[14] = _p[14] * k2 + _p[15] * o2;
	                _p[15] = _p[15] * p2;
	            //}
	            this._identityCalculated = false;
	            return this;
	        }
	
	        var a1 = _p[0];
	        var b1 = _p[1];
	        var c1 = _p[2];
	        var d1 = _p[3];
	        var e1 = _p[4];
	        var f1 = _p[5];
	        var g1 = _p[6];
	        var h1 = _p[7];
	        var i1 = _p[8];
	        var j1 = _p[9];
	        var k1 = _p[10];
	        var l1 = _p[11];
	        var m1 = _p[12];
	        var n1 = _p[13];
	        var o1 = _p[14];
	        var p1 = _p[15];
	
	        /* matrix order (canvas compatible):
	         * ace
	         * bdf
	         * 001
	         */
	        _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
	        _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2 ;
	        _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2 ;
	        _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2 ;
	
	        _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2 ;
	        _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2 ;
	        _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2 ;
	        _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2 ;
	
	        _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2 ;
	        _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2 ;
	        _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2 ;
	        _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2 ;
	
	        _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2 ;
	        _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2 ;
	        _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2 ;
	        _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2 ;
	
	        this._identityCalculated = false;
	        return this;
	    }
	
	    function isIdentity() {
	        if(!this._identityCalculated){
	            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
	            this._identityCalculated = true;
	        }
	        return this._identity;
	    }
	
	    function equals(matr){
	        var i = 0;
	        while (i < 16) {
	            if(matr.props[i] !== this.props[i]) {
	                return false;
	            }
	            i+=1;
	        }
	        return true;
	    }
	
	    function clone(matr){
	        var i;
	        for(i=0;i<16;i+=1){
	            matr.props[i] = this.props[i];
	        }
	    }
	
	    function cloneFromProps(props){
	        var i;
	        for(i=0;i<16;i+=1){
	            this.props[i] = props[i];
	        }
	    }
	
	    function applyToPoint(x, y, z) {
	
	        return {
	            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
	            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
	            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
	        };
	        /*return {
	         x: x * me.a + y * me.c + me.e,
	         y: x * me.b + y * me.d + me.f
	         };*/
	    }
	    function applyToX(x, y, z) {
	        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
	    }
	    function applyToY(x, y, z) {
	        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
	    }
	    function applyToZ(x, y, z) {
	        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
	    }
	
	    function inversePoint(pt) {
	        var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
	        var a = this.props[5]/determinant;
	        var b = - this.props[1]/determinant;
	        var c = - this.props[4]/determinant;
	        var d = this.props[0]/determinant;
	        var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12])/determinant;
	        var f = - (this.props[0] * this.props[13] - this.props[1] * this.props[12])/determinant;
	        return [pt[0] * a + pt[1] * c + e, pt[0] * b + pt[1] * d + f, 0];
	    }
	
	    function inversePoints(pts){
	        var i, len = pts.length, retPts = [];
	        for(i=0;i<len;i+=1){
	            retPts[i] = inversePoint(pts[i]);
	        }
	        return retPts;
	    }
	
	    function applyToTriplePoints(pt1, pt2, pt3) {
	        var arr = createTypedArray('float32', 6);
	        if(this.isIdentity()) {
	            arr[0] = pt1[0];
	            arr[1] = pt1[1];
	            arr[2] = pt2[0];
	            arr[3] = pt2[1];
	            arr[4] = pt3[0];
	            arr[5] = pt3[1];
	        } else {
	            var p0 = this.props[0], p1 = this.props[1], p4 = this.props[4], p5 = this.props[5], p12 = this.props[12], p13 = this.props[13];
	            arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
	            arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
	            arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
	            arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
	            arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
	            arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
	        }
	        return arr;
	    }
	
	    function applyToPointArray(x,y,z){
	        var arr;
	        if(this.isIdentity()) {
	            arr = [x,y,z];
	        } else {
	            arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
	        }
	        return arr;
	    }
	
	    function applyToPointStringified(x, y) {
	        if(this.isIdentity()) {
	            return x + ',' + y;
	        }
	        var _p = this.props;
	        return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100+','+ Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
	    }
	
	    function toCSS() {
	        //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
	        /*if(this.isIdentity()) {
	            return '';
	        }*/
	        var i = 0;
	        var props = this.props;
	        var cssValue = 'matrix3d(';
	        var v = 10000;
	        while(i<16){
	            cssValue += _rnd(props[i]*v)/v;
	            cssValue += i === 15 ? ')':',';
	            i += 1;
	        }
	        return cssValue;
	    }
	
	    function roundMatrixProperty(val) {
	        var v = 10000;
	        if((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {
	            return _rnd(val * v) / v;
	        }
	        return val;
	    }
	
	    function to2dCSS() {
	        //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
	        /*if(this.isIdentity()) {
	            return '';
	        }*/
	        var props = this.props;
	        var _a = roundMatrixProperty(props[0]);
	        var _b = roundMatrixProperty(props[1]);
	        var _c = roundMatrixProperty(props[4]);
	        var _d = roundMatrixProperty(props[5]);
	        var _e = roundMatrixProperty(props[12]);
	        var _f = roundMatrixProperty(props[13]);
	        return "matrix(" + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ")";
	    }
	
	    return function(){
	        this.reset = reset;
	        this.rotate = rotate;
	        this.rotateX = rotateX;
	        this.rotateY = rotateY;
	        this.rotateZ = rotateZ;
	        this.skew = skew;
	        this.skewFromAxis = skewFromAxis;
	        this.shear = shear;
	        this.scale = scale;
	        this.setTransform = setTransform;
	        this.translate = translate;
	        this.transform = transform;
	        this.applyToPoint = applyToPoint;
	        this.applyToX = applyToX;
	        this.applyToY = applyToY;
	        this.applyToZ = applyToZ;
	        this.applyToPointArray = applyToPointArray;
	        this.applyToTriplePoints = applyToTriplePoints;
	        this.applyToPointStringified = applyToPointStringified;
	        this.toCSS = toCSS;
	        this.to2dCSS = to2dCSS;
	        this.clone = clone;
	        this.cloneFromProps = cloneFromProps;
	        this.equals = equals;
	        this.inversePoints = inversePoints;
	        this.inversePoint = inversePoint;
	        this._t = this.transform;
	        this.isIdentity = isIdentity;
	        this._identity = true;
	        this._identityCalculated = false;
	
	        this.props = createTypedArray('float32', 16);
	        this.reset();
	    };
	}());
	
	/*
	 Copyright 2014 David Bau.
	
	 Permission is hereby granted, free of charge, to any person obtaining
	 a copy of this software and associated documentation files (the
	 "Software"), to deal in the Software without restriction, including
	 without limitation the rights to use, copy, modify, merge, publish,
	 distribute, sublicense, and/or sell copies of the Software, and to
	 permit persons to whom the Software is furnished to do so, subject to
	 the following conditions:
	
	 The above copyright notice and this permission notice shall be
	 included in all copies or substantial portions of the Software.
	
	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	 */
	
	(function (pool, math) {
	//
	// The following constants are related to IEEE 754 limits.
	//
	    var global = this,
	        width = 256,        // each RC4 output is 0 <= x < 256
	        chunks = 6,         // at least six RC4 outputs for each double
	        digits = 52,        // there are 52 significant digits in a double
	        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
	        startdenom = math.pow(width, chunks),
	        significance = math.pow(2, digits),
	        overflow = significance * 2,
	        mask = width - 1,
	        nodecrypto;         // node.js crypto module, initialized at the bottom.
	
	//
	// seedrandom()
	// This is the seedrandom function described above.
	//
	    function seedrandom(seed, options, callback) {
	        var key = [];
	        options = (options === true) ? { entropy: true } : (options || {});
	
	        // Flatten the seed string or build one from local entropy if needed.
	        var shortseed = mixkey(flatten(
	            options.entropy ? [seed, tostring(pool)] :
	                (seed === null) ? autoseed() : seed, 3), key);
	
	        // Use the seed to initialize an ARC4 generator.
	        var arc4 = new ARC4(key);
	
	        // This function returns a random double in [0, 1) that contains
	        // randomness in every bit of the mantissa of the IEEE 754 value.
	        var prng = function() {
	            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
	                d = startdenom,                 //   and denominator d = 2 ^ 48.
	                x = 0;                          //   and no 'extra last byte'.
	            while (n < significance) {          // Fill up all significant digits by
	                n = (n + x) * width;              //   shifting numerator and
	                d *= width;                       //   denominator and generating a
	                x = arc4.g(1);                    //   new least-significant-byte.
	            }
	            while (n >= overflow) {             // To avoid rounding up, before adding
	                n /= 2;                           //   last byte, shift everything
	                d /= 2;                           //   right using integer math until
	                x >>>= 1;                         //   we have exactly the desired bits.
	            }
	            return (n + x) / d;                 // Form the number within [0, 1).
	        };
	
	        prng.int32 = function() { return arc4.g(4) | 0; };
	        prng.quick = function() { return arc4.g(4) / 0x100000000; };
	        prng.double = prng;
	
	        // Mix the randomness into accumulated entropy.
	        mixkey(tostring(arc4.S), pool);
	
	        // Calling convention: what to return as a function of prng, seed, is_math.
	        return (options.pass || callback ||
	        function(prng, seed, is_math_call, state) {
	            if (state) {
	                // Load the arc4 state from the given state if it has an S array.
	                if (state.S) { copy(state, arc4); }
	                // Only provide the .state method if requested via options.state.
	                prng.state = function() { return copy(arc4, {}); };
	            }
	
	            // If called as a method of Math (Math.seedrandom()), mutate
	            // Math.random because that is how seedrandom.js has worked since v1.0.
	            if (is_math_call) { math[rngname] = prng; return seed; }
	
	            // Otherwise, it is a newer calling convention, so return the
	            // prng directly.
	            else return prng;
	        })(
	            prng,
	            shortseed,
	            'global' in options ? options.global : (this == math),
	            options.state);
	    }
	    math['seed' + rngname] = seedrandom;
	
	//
	// ARC4
	//
	// An ARC4 implementation.  The constructor takes a key in the form of
	// an array of at most (width) integers that should be 0 <= x < (width).
	//
	// The g(count) method returns a pseudorandom integer that concatenates
	// the next (count) outputs from ARC4.  Its return value is a number x
	// that is in the range 0 <= x < (width ^ count).
	//
	    function ARC4(key) {
	        var t, keylen = key.length,
	            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
	
	        // The empty key [] is treated as [0].
	        if (!keylen) { key = [keylen++]; }
	
	        // Set up S using the standard key scheduling algorithm.
	        while (i < width) {
	            s[i] = i++;
	        }
	        for (i = 0; i < width; i++) {
	            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
	            s[j] = t;
	        }
	
	        // The "g" method returns the next (count) outputs as one number.
	        me.g = function(count) {
	            // Using instance members instead of closure state nearly doubles speed.
	            var t, r = 0,
	                i = me.i, j = me.j, s = me.S;
	            while (count--) {
	                t = s[i = mask & (i + 1)];
	                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
	            }
	            me.i = i; me.j = j;
	            return r;
	            // For robust unpredictability, the function call below automatically
	            // discards an initial batch of values.  This is called RC4-drop[256].
	            // See http://google.com/search?q=rsa+fluhrer+response&btnI
	        };
	    }
	
	//
	// copy()
	// Copies internal state of ARC4 to or from a plain object.
	//
	    function copy(f, t) {
	        t.i = f.i;
	        t.j = f.j;
	        t.S = f.S.slice();
	        return t;
	    }
	
	//
	// flatten()
	// Converts an object tree to nested arrays of strings.
	//
	    function flatten(obj, depth) {
	        var result = [], typ = (typeof obj), prop;
	        if (depth && typ == 'object') {
	            for (prop in obj) {
	                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
	            }
	        }
	        return (result.length ? result : typ == 'string' ? obj : obj + '\0');
	    }
	
	//
	// mixkey()
	// Mixes a string seed into a key that is an array of integers, and
	// returns a shortened string seed that is equivalent to the result key.
	//
	    function mixkey(seed, key) {
	        var stringseed = seed + '', smear, j = 0;
	        while (j < stringseed.length) {
	            key[mask & j] =
	                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
	        }
	        return tostring(key);
	    }
	
	//
	// autoseed()
	// Returns an object for autoseeding, using window.crypto and Node crypto
	// module if available.
	//
	    function autoseed() {
	        try {
	            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
	            var out = new Uint8Array(width);
	            (global.crypto || global.msCrypto).getRandomValues(out);
	            return tostring(out);
	        } catch (e) {
	            var browser = global.navigator,
	                plugins = browser && browser.plugins;
	            return [+new Date(), global, plugins, global.screen, tostring(pool)];
	        }
	    }
	
	//
	// tostring()
	// Converts an array of charcodes to a string
	//
	    function tostring(a) {
	        return String.fromCharCode.apply(0, a);
	    }
	
	//
	// When seedrandom.js is loaded, we immediately mix a few bits
	// from the built-in RNG into the entropy pool.  Because we do
	// not want to interfere with deterministic PRNG state later,
	// seedrandom will not call math.random on its own again after
	// initialization.
	//
	    mixkey(math.random(), pool);
	
	//
	// Nodejs and AMD support: export the implementation as a module using
	// either convention.
	//
	
	// End anonymous scope, and pass initial values.
	})(
	    [],     // pool: entropy pool starts empty
	    BMMath    // math: package containing random, pow, and seedrandom
	);
	var BezierFactory = (function(){
	    /**
	     * BezierEasing - use bezier curve for transition easing function
	     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
	     *
	     * Credits: is based on Firefox's nsSMILKeySpline.cpp
	     * Usage:
	     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
	     * spline.get(x) => returns the easing value | x must be in [0, 1] range
	     *
	     */
	
	        var ob = {};
	    ob.getBezierEasing = getBezierEasing;
	    var beziers = {};
	
	    function getBezierEasing(a,b,c,d,nm){
	        var str = nm || ('bez_' + a+'_'+b+'_'+c+'_'+d).replace(/\./g, 'p');
	        if(beziers[str]){
	            return beziers[str];
	        }
	        var bezEasing = new BezierEasing([a,b,c,d]);
	        beziers[str] = bezEasing;
	        return bezEasing;
	    }
	
	// These values are established by empiricism with tests (tradeoff: performance VS precision)
	    var NEWTON_ITERATIONS = 4;
	    var NEWTON_MIN_SLOPE = 0.001;
	    var SUBDIVISION_PRECISION = 0.0000001;
	    var SUBDIVISION_MAX_ITERATIONS = 10;
	
	    var kSplineTableSize = 11;
	    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
	
	    var float32ArraySupported = typeof Float32Array === "function";
	
	    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
	    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
	    function C (aA1)      { return 3.0 * aA1; }
	
	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	    function calcBezier (aT, aA1, aA2) {
	        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
	    }
	
	// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	    function getSlope (aT, aA1, aA2) {
	        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
	    }
	
	    function binarySubdivide (aX, aA, aB, mX1, mX2) {
	        var currentX, currentT, i = 0;
	        do {
	            currentT = aA + (aB - aA) / 2.0;
	            currentX = calcBezier(currentT, mX1, mX2) - aX;
	            if (currentX > 0.0) {
	                aB = currentT;
	            } else {
	                aA = currentT;
	            }
	        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	        return currentT;
	    }
	
	    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
	        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	            var currentSlope = getSlope(aGuessT, mX1, mX2);
	            if (currentSlope === 0.0) return aGuessT;
	            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	            aGuessT -= currentX / currentSlope;
	        }
	        return aGuessT;
	    }
	
	    /**
	     * points is an array of [ mX1, mY1, mX2, mY2 ]
	     */
	    function BezierEasing (points) {
	        this._p = points;
	        this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
	        this._precomputed = false;
	
	        this.get = this.get.bind(this);
	    }
	
	    BezierEasing.prototype = {
	
	        get: function (x) {
	            var mX1 = this._p[0],
	                mY1 = this._p[1],
	                mX2 = this._p[2],
	                mY2 = this._p[3];
	            if (!this._precomputed) this._precompute();
	            if (mX1 === mY1 && mX2 === mY2) return x; // linear
	            // Because JavaScript number are imprecise, we should guarantee the extremes are right.
	            if (x === 0) return 0;
	            if (x === 1) return 1;
	            return calcBezier(this._getTForX(x), mY1, mY2);
	        },
	
	        // Private part
	
	        _precompute: function () {
	            var mX1 = this._p[0],
	                mY1 = this._p[1],
	                mX2 = this._p[2],
	                mY2 = this._p[3];
	            this._precomputed = true;
	            if (mX1 !== mY1 || mX2 !== mY2)
	                this._calcSampleValues();
	        },
	
	        _calcSampleValues: function () {
	            var mX1 = this._p[0],
	                mX2 = this._p[2];
	            for (var i = 0; i < kSplineTableSize; ++i) {
	                this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	            }
	        },
	
	        /**
	         * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
	         */
	        _getTForX: function (aX) {
	            var mX1 = this._p[0],
	                mX2 = this._p[2],
	                mSampleValues = this._mSampleValues;
	
	            var intervalStart = 0.0;
	            var currentSample = 1;
	            var lastSample = kSplineTableSize - 1;
	
	            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
	                intervalStart += kSampleStepSize;
	            }
	            --currentSample;
	
	            // Interpolate to provide an initial guess for t
	            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
	            var guessForT = intervalStart + dist * kSampleStepSize;
	
	            var initialSlope = getSlope(guessForT, mX1, mX2);
	            if (initialSlope >= NEWTON_MIN_SLOPE) {
	                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	            } else if (initialSlope === 0.0) {
	                return guessForT;
	            } else {
	                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	            }
	        }
	    };
	
	    return ob;
	
	}());
	(function () {
	    var lastTime = 0;
	    var vendors = ['ms', 'moz', 'webkit', 'o'];
	    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
	        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	    }
	    if(!window.requestAnimationFrame)
	        window.requestAnimationFrame = function (callback, element) {
	            var currTime = new Date().getTime();
	            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	            var id = setTimeout(function () {
	                    callback(currTime + timeToCall);
	                },
	                timeToCall);
	            lastTime = currTime + timeToCall;
	            return id;
	        };
	    if(!window.cancelAnimationFrame)
	        window.cancelAnimationFrame = function (id) {
	            clearTimeout(id);
	        };
	}());
	
	function extendPrototype(sources,destination){
	    var i, len = sources.length, sourcePrototype;
	    for (i = 0;i < len;i += 1) {
	        sourcePrototype = sources[i].prototype;
	        for (var attr in sourcePrototype) {
	            if (sourcePrototype.hasOwnProperty(attr)) destination.prototype[attr] = sourcePrototype[attr];
	        }
	    }
	}
	
	function getDescriptor(object, prop) {
	    return Object.getOwnPropertyDescriptor(object, prop);
	}
	
	function createProxyFunction(prototype) {
		function ProxyFunction(){}
		ProxyFunction.prototype = prototype;
		return ProxyFunction;
	}
	function bezFunction(){
	
	    var easingFunctions = [];
	    var math = Math;
	
	    function pointOnLine2D(x1,y1, x2,y2, x3,y3){
	        var det1 = (x1*y2) + (y1*x3) + (x2*y3) - (x3*y2) - (y3*x1) - (x2*y1);
	        return det1 > -0.001 && det1 < 0.001;
	    }
	
	    function pointOnLine3D(x1,y1,z1, x2,y2,z2, x3,y3,z3){
	        if(z1 === 0 && z2 === 0 && z3 === 0) {
	            return pointOnLine2D(x1,y1, x2,y2, x3,y3);
	        }
	        var dist1 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2));
	        var dist2 = Math.sqrt(Math.pow(x3 - x1, 2) + Math.pow(y3 - y1, 2) + Math.pow(z3 - z1, 2));
	        var dist3 = Math.sqrt(Math.pow(x3 - x2, 2) + Math.pow(y3 - y2, 2) + Math.pow(z3 - z2, 2));
	        var diffDist;
	        if(dist1 > dist2){
	            if(dist1 > dist3){
	                diffDist = dist1 - dist2 - dist3;
	            } else {
	                diffDist = dist3 - dist2 - dist1;
	            }
	        } else if(dist3 > dist2){
	            diffDist = dist3 - dist2 - dist1;
	        } else {
	            diffDist = dist2 - dist1 - dist3;
	        }
	        return diffDist > -0.0001 && diffDist < 0.0001;
	    }
	
	    var getBezierLength = (function(){
	
	        return function(pt1,pt2,pt3,pt4){
	            var curveSegments = defaultCurveSegments;
	            var k;
	            var i, len;
	            var ptCoord,perc,addedLength = 0;
	            var ptDistance;
	            var point = [],lastPoint = [];
	            var lengthData = bezier_length_pool.newElement();
	            len = pt3.length;
	            for(k=0;k<curveSegments;k+=1){
	                perc = k/(curveSegments-1);
	                ptDistance = 0;
	                for(i=0;i<len;i+=1){
	                    ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*pt3[i]+3*(1-perc)*bm_pow(perc,2)*pt4[i]+bm_pow(perc,3)*pt2[i];
	                    point[i] = ptCoord;
	                    if(lastPoint[i] !== null){
	                        ptDistance += bm_pow(point[i] - lastPoint[i],2);
	                    }
	                    lastPoint[i] = point[i];
	                }
	                if(ptDistance){
	                    ptDistance = bm_sqrt(ptDistance);
	                    addedLength += ptDistance;
	                }
	                lengthData.percents[k] = perc;
	                lengthData.lengths[k] = addedLength;
	            }
	            lengthData.addedLength = addedLength;
	            return lengthData;
	        };
	    }());
	
	    function getSegmentsLength(shapeData) {
	        var segmentsLength = segments_length_pool.newElement();
	        var closed = shapeData.c;
	        var pathV = shapeData.v;
	        var pathO = shapeData.o;
	        var pathI = shapeData.i;
	        var i, len = shapeData._length;
	        var lengths = segmentsLength.lengths;
	        var totalLength = 0;
	        for(i=0;i<len-1;i+=1){
	            lengths[i] = getBezierLength(pathV[i],pathV[i+1],pathO[i],pathI[i+1]);
	            totalLength += lengths[i].addedLength;
	        }
	        if(closed && len){
	            lengths[i] = getBezierLength(pathV[i],pathV[0],pathO[i],pathI[0]);
	            totalLength += lengths[i].addedLength;
	        }
	        segmentsLength.totalLength = totalLength;
	        return segmentsLength;
	    }
	
	    function BezierData(length){
	        this.segmentLength = 0;
	        this.points = new Array(length);
	    }
	
	    function PointData(partial,point){
	        this.partialLength = partial;
	        this.point = point;
	    }
	
	    var buildBezierData = (function(){
	
	        var storedData = {};
	
	        return function (pt1, pt2, pt3, pt4){
	            var bezierName = (pt1[0]+'_'+pt1[1]+'_'+pt2[0]+'_'+pt2[1]+'_'+pt3[0]+'_'+pt3[1]+'_'+pt4[0]+'_'+pt4[1]).replace(/\./g, 'p');
	            if(!storedData[bezierName]){
	                var curveSegments = defaultCurveSegments;
	                var k, i, len;
	                var ptCoord,perc,addedLength = 0;
	                var ptDistance;
	                var point,lastPoint = null;
	                if (pt1.length === 2 && (pt1[0] != pt2[0] || pt1[1] != pt2[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt1[0]+pt3[0],pt1[1]+pt3[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt2[0]+pt4[0],pt2[1]+pt4[1])){
	                    curveSegments = 2;
	                }
	                var bezierData = new BezierData(curveSegments);
	                len = pt3.length;
	                for (k = 0; k < curveSegments; k += 1) {
	                    point = createSizedArray(len);
	                    perc = k / (curveSegments - 1);
	                    ptDistance = 0;
	                    for (i = 0; i < len; i += 1){
	                        ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*(pt1[i] + pt3[i])+3*(1-perc)*bm_pow(perc,2)*(pt2[i] + pt4[i])+bm_pow(perc,3)*pt2[i];
	                        point[i] = ptCoord;
	                        if(lastPoint !== null){
	                            ptDistance += bm_pow(point[i] - lastPoint[i],2);
	                        }
	                    }
	                    ptDistance = bm_sqrt(ptDistance);
	                    addedLength += ptDistance;
	                    bezierData.points[k] = new PointData(ptDistance, point);
	                    lastPoint = point;
	                }
	                bezierData.segmentLength = addedLength;
	                storedData[bezierName] = bezierData;
	            }
	            return storedData[bezierName];
	        };
	    }());
	
	    function getDistancePerc(perc,bezierData){
	        var percents = bezierData.percents;
	        var lengths = bezierData.lengths;
	        var len = percents.length;
	        var initPos = bm_floor((len-1)*perc);
	        var lengthPos = perc*bezierData.addedLength;
	        var lPerc = 0;
	        if(initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]){
	            return percents[initPos];
	        }else{
	            var dir = lengths[initPos] > lengthPos ? -1 : 1;
	            var flag = true;
	            while(flag){
	                if(lengths[initPos] <= lengthPos && lengths[initPos+1] > lengthPos){
	                    lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos+1] - lengths[initPos]);
	                    flag = false;
	                }else{
	                    initPos += dir;
	                }
	                if(initPos < 0 || initPos >= len - 1){
	                    //FIX for TypedArrays that don't store floating point values with enough accuracy
	                    if(initPos === len - 1) {
	                        return percents[initPos];
	                    }
	                    flag = false;
	                }
	            }
	            return percents[initPos] + (percents[initPos+1] - percents[initPos])*lPerc;
	        }
	    }
	
	    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
	        var t1 = getDistancePerc(percent,bezierData);
	        var u0 = 1;
	        var u1 = 1 - t1;
	        var ptX = Math.round((u1*u1*u1* pt1[0] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[0] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[0] + t1*t1*t1* pt2[0])* 1000) / 1000;
	        var ptY = Math.round((u1*u1*u1* pt1[1] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[1] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[1] + t1*t1*t1* pt2[1])* 1000) / 1000;
	        return [ptX, ptY];
	    }
	
	    function getSegmentArray() {
	
	    }
	
	    var bezier_segment_points = createTypedArray('float32', 8);
	
	    function getNewSegment(pt1,pt2,pt3,pt4,startPerc,endPerc, bezierData){
	
	        startPerc = startPerc < 0 ? 0 : startPerc > 1 ? 1 : startPerc;
	        var t0 = getDistancePerc(startPerc,bezierData);
	        endPerc = endPerc > 1 ? 1 : endPerc;
	        var t1 = getDistancePerc(endPerc,bezierData);
	        var i, len = pt1.length;
	        var u0 = 1 - t0;
	        var u1 = 1 - t1;
	        var u0u0u0 = u0*u0*u0;
	        var t0u0u0_3 = t0*u0*u0*3;
	        var t0t0u0_3 = t0*t0*u0*3;
	        var t0t0t0 = t0*t0*t0;
	        //
	        var u0u0u1 = u0*u0*u1;
	        var t0u0u1_3 = t0*u0*u1 + u0*t0*u1 + u0*u0*t1;
	        var t0t0u1_3 = t0*t0*u1 + u0*t0*t1 + t0*u0*t1;
	        var t0t0t1 = t0*t0*t1;
	        //
	        var u0u1u1 = u0*u1*u1;
	        var t0u1u1_3 = t0*u1*u1 + u0*t1*u1 + u0*u1*t1;
	        var t0t1u1_3 = t0*t1*u1 + u0*t1*t1 + t0*u1*t1;
	        var t0t1t1 = t0*t1*t1;
	        //
	        var u1u1u1 = u1*u1*u1;
	        var t1u1u1_3 = t1*u1*u1 + u1*t1*u1 + u1*u1*t1;
	        var t1t1u1_3 = t1*t1*u1 + u1*t1*t1 + t1*u1*t1;
	        var t1t1t1 = t1*t1*t1;
	        for(i=0;i<len;i+=1){
	            bezier_segment_points[i * 4] = Math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000;
	            bezier_segment_points[i * 4 + 1] = Math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000;
	            bezier_segment_points[i * 4 + 2] = Math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000;
	            bezier_segment_points[i * 4 + 3] = Math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000;
	        }
	
	        return bezier_segment_points;
	    }
	
	    return {
	        getSegmentsLength : getSegmentsLength,
	        getNewSegment : getNewSegment,
	        getPointInSegment : getPointInSegment,
	        buildBezierData : buildBezierData,
	        pointOnLine2D : pointOnLine2D,
	        pointOnLine3D : pointOnLine3D
	    };
	}
	
	var bez = bezFunction();
	function dataFunctionManager(){
	
	    //var tCanvasHelper = createTag('canvas').getContext('2d');
	
	    function completeLayers(layers, comps, fontManager){
	        var layerData;
	        var animArray, lastFrame;
	        var i, len = layers.length;
	        var j, jLen, k, kLen;
	        for(i=0;i<len;i+=1){
	            layerData = layers[i];
	            if(!('ks' in layerData) || layerData.completed){
	                continue;
	            }
	            layerData.completed = true;
	            if(layerData.tt){
	                layers[i-1].td = layerData.tt;
	            }
	            animArray = [];
	            lastFrame = -1;
	            if(layerData.hasMask){
	                var maskProps = layerData.masksProperties;
	                jLen = maskProps.length;
	                for(j=0;j<jLen;j+=1){
	                    if(maskProps[j].pt.k.i){
	                        convertPathsToAbsoluteValues(maskProps[j].pt.k);
	                    }else{
	                        kLen = maskProps[j].pt.k.length;
	                        for(k=0;k<kLen;k+=1){
	                            if(maskProps[j].pt.k[k].s){
	                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
	                            }
	                            if(maskProps[j].pt.k[k].e){
	                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
	                            }
	                        }
	                    }
	                }
	            }
	            if(layerData.ty===0){
	                layerData.layers = findCompLayers(layerData.refId, comps);
	                completeLayers(layerData.layers,comps, fontManager);
	            }else if(layerData.ty === 4){
	                completeShapes(layerData.shapes);
	            }else if(layerData.ty == 5){
	                completeText(layerData, fontManager);
	            }
	        }
	    }
	
	    function findCompLayers(id,comps){
	        var i = 0, len = comps.length;
	        while(i<len){
	            if(comps[i].id === id){
	                if(!comps[i].layers.__used) {
	                    comps[i].layers.__used = true;
	                    return comps[i].layers;
	                }
	                return JSON.parse(JSON.stringify(comps[i].layers));
	            }
	            i += 1;
	        }
	    }
	
	    function completeShapes(arr){
	        var i, len = arr.length;
	        var j, jLen;
	        var hasPaths = false;
	        for(i=len-1;i>=0;i-=1){
	            if(arr[i].ty == 'sh'){
	                if(arr[i].ks.k.i){
	                    convertPathsToAbsoluteValues(arr[i].ks.k);
	                }else{
	                    jLen = arr[i].ks.k.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(arr[i].ks.k[j].s){
	                            convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
	                        }
	                        if(arr[i].ks.k[j].e){
	                            convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
	                        }
	                    }
	                }
	                hasPaths = true;
	            }else if(arr[i].ty == 'gr'){
	                completeShapes(arr[i].it);
	            }
	        }
	        /*if(hasPaths){
	            //mx: distance
	            //ss: sensitivity
	            //dc: decay
	            arr.splice(arr.length-1,0,{
	                "ty": "ms",
	                "mx":20,
	                "ss":10,
	                 "dc":0.001,
	                "maxDist":200
	            });
	        }*/
	    }
	
	    function convertPathsToAbsoluteValues(path){
	        var i, len = path.i.length;
	        for(i=0;i<len;i+=1){
	            path.i[i][0] += path.v[i][0];
	            path.i[i][1] += path.v[i][1];
	            path.o[i][0] += path.v[i][0];
	            path.o[i][1] += path.v[i][1];
	        }
	    }
	
	    function checkVersion(minimum,animVersionString){
	        var animVersion = animVersionString ? animVersionString.split('.') : [100,100,100];
	        if(minimum[0]>animVersion[0]){
	            return true;
	        } else if(animVersion[0] > minimum[0]){
	            return false;
	        }
	        if(minimum[1]>animVersion[1]){
	            return true;
	        } else if(animVersion[1] > minimum[1]){
	            return false;
	        }
	        if(minimum[2]>animVersion[2]){
	            return true;
	        } else if(animVersion[2] > minimum[2]){
	            return false;
	        }
	    }
	
	    var checkText = (function(){
	        var minimumVersion = [4,4,14];
	
	        function updateTextLayer(textLayer){
	            var documentData = textLayer.t.d;
	            textLayer.t.d = {
	                k: [
	                    {
	                        s:documentData,
	                        t:0
	                    }
	                ]
	            };
	        }
	
	        function iterateLayers(layers){
	            var i, len = layers.length;
	            for(i=0;i<len;i+=1){
	                if(layers[i].ty === 5){
	                    updateTextLayer(layers[i]);
	                }
	            }
	        }
	
	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);
	
	                        }
	                    }
	                }
	            }
	        };
	    }());
	
	    var checkChars = (function() {
	        var minimumVersion = [4,7,99];
	        return function (animationData){
	            if(animationData.chars && !checkVersion(minimumVersion,animationData.v)){
	                var i, len = animationData.chars.length, j, jLen, k, kLen;
	                var pathData, paths;
	                for(i = 0; i < len; i += 1) {
	                    if(animationData.chars[i].data && animationData.chars[i].data.shapes) {
	                        paths = animationData.chars[i].data.shapes[0].it;
	                        jLen = paths.length;
	
	                        for(j = 0; j < jLen; j += 1) {
	                            pathData = paths[j].ks.k;
	                            if(!pathData.__converted) {
	                                convertPathsToAbsoluteValues(paths[j].ks.k);
	                                pathData.__converted = true;
	                            }
	                        }
	                    }
	                }
	            }
	        };
	    }());
	
	    var checkColors = (function(){
	        var minimumVersion = [4,1,9];
	
	        function iterateShapes(shapes){
	            var i, len = shapes.length;
	            var j, jLen;
	            for(i=0;i<len;i+=1){
	                if(shapes[i].ty === 'gr'){
	                    iterateShapes(shapes[i].it);
	                }else if(shapes[i].ty === 'fl' || shapes[i].ty === 'st'){
	                    if(shapes[i].c.k && shapes[i].c.k[0].i){
	                        jLen = shapes[i].c.k.length;
	                        for(j=0;j<jLen;j+=1){
	                            if(shapes[i].c.k[j].s){
	                                shapes[i].c.k[j].s[0] /= 255;
	                                shapes[i].c.k[j].s[1] /= 255;
	                                shapes[i].c.k[j].s[2] /= 255;
	                                shapes[i].c.k[j].s[3] /= 255;
	                            }
	                            if(shapes[i].c.k[j].e){
	                                shapes[i].c.k[j].e[0] /= 255;
	                                shapes[i].c.k[j].e[1] /= 255;
	                                shapes[i].c.k[j].e[2] /= 255;
	                                shapes[i].c.k[j].e[3] /= 255;
	                            }
	                        }
	                    } else {
	                        shapes[i].c.k[0] /= 255;
	                        shapes[i].c.k[1] /= 255;
	                        shapes[i].c.k[2] /= 255;
	                        shapes[i].c.k[3] /= 255;
	                    }
	                }
	            }
	        }
	
	        function iterateLayers(layers){
	            var i, len = layers.length;
	            for(i=0;i<len;i+=1){
	                if(layers[i].ty === 4){
	                    iterateShapes(layers[i].shapes);
	                }
	            }
	        }
	
	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);
	
	                        }
	                    }
	                }
	            }
	        };
	    }());
	
	    var checkShapes = (function(){
	        var minimumVersion = [4,4,18];
	
	
	
	        function completeShapes(arr){
	            var i, len = arr.length;
	            var j, jLen;
	            var hasPaths = false;
	            for(i=len-1;i>=0;i-=1){
	                if(arr[i].ty == 'sh'){
	                    if(arr[i].ks.k.i){
	                        arr[i].ks.k.c = arr[i].closed;
	                    }else{
	                        jLen = arr[i].ks.k.length;
	                        for(j=0;j<jLen;j+=1){
	                            if(arr[i].ks.k[j].s){
	                                arr[i].ks.k[j].s[0].c = arr[i].closed;
	                            }
	                            if(arr[i].ks.k[j].e){
	                                arr[i].ks.k[j].e[0].c = arr[i].closed;
	                            }
	                        }
	                    }
	                    hasPaths = true;
	                }else if(arr[i].ty == 'gr'){
	                    completeShapes(arr[i].it);
	                }
	            }
	        }
	
	        function iterateLayers(layers){
	            var layerData;
	            var i, len = layers.length;
	            var j, jLen, k, kLen;
	            for(i=0;i<len;i+=1){
	                layerData = layers[i];
	                if(layerData.hasMask){
	                    var maskProps = layerData.masksProperties;
	                    jLen = maskProps.length;
	                    for(j=0;j<jLen;j+=1){
	                        if(maskProps[j].pt.k.i){
	                            maskProps[j].pt.k.c = maskProps[j].cl;
	                        }else{
	                            kLen = maskProps[j].pt.k.length;
	                            for(k=0;k<kLen;k+=1){
	                                if(maskProps[j].pt.k[k].s){
	                                    maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
	                                }
	                                if(maskProps[j].pt.k[k].e){
	                                    maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
	                                }
	                            }
	                        }
	                    }
	                }
	                if(layerData.ty === 4){
	                    completeShapes(layerData.shapes);
	                }
	            }
	        }
	
	        return function (animationData){
	            if(checkVersion(minimumVersion,animationData.v)){
	                iterateLayers(animationData.layers);
	                if(animationData.assets){
	                    var i, len = animationData.assets.length;
	                    for(i=0;i<len;i+=1){
	                        if(animationData.assets[i].layers){
	                            iterateLayers(animationData.assets[i].layers);
	
	                        }
	                    }
	                }
	            }
	        };
	    }());
	
	    function completeData(animationData, fontManager){
	        if(animationData.__complete){
	            return;
	        }
	        checkColors(animationData);
	        checkText(animationData);
	        checkChars(animationData);
	        checkShapes(animationData);
	        completeLayers(animationData.layers, animationData.assets, fontManager);
	        animationData.__complete = true;
	        //blitAnimation(animationData, animationData.assets, fontManager);
	    }
	
	    function completeText(data, fontManager){
	        if(data.t.a.length === 0 && !('m' in data.t.p)){
	            data.singleShape = true;
	        }
	    }
	
	    var moduleOb = {};
	    moduleOb.completeData = completeData;
	
	    return moduleOb;
	}
	
	var dataManager = dataFunctionManager();
	var FontManager = (function(){
	
	    var maxWaitingTime = 5000;
	    var emptyChar = {
	        w: 0,
	        size:0,
	        shapes:[]
	    };
	    var combinedCharacters = [];
	    //Hindi characters
	    combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366
	    , 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379
	    , 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
	
	    function setUpNode(font, family){
	        var parentNode = createTag('span');
	        parentNode.style.fontFamily    = family;
	        var node = createTag('span');
	        // Characters that vary significantly among different fonts
	        node.innerHTML = 'giItT1WQy@!-/#';
	        // Visible - so we can measure it - but not on the screen
	        parentNode.style.position      = 'absolute';
	        parentNode.style.left          = '-10000px';
	        parentNode.style.top           = '-10000px';
	        // Large font size makes even subtle changes obvious
	        parentNode.style.fontSize      = '300px';
	        // Reset any font properties
	        parentNode.style.fontVariant   = 'normal';
	        parentNode.style.fontStyle     = 'normal';
	        parentNode.style.fontWeight    = 'normal';
	        parentNode.style.letterSpacing = '0';
	        parentNode.appendChild(node);
	        document.body.appendChild(parentNode);
	
	        // Remember width with no applied web font
	        var width = node.offsetWidth;
	        node.style.fontFamily = font + ', '+family;
	        return {node:node, w:width, parent:parentNode};
	    }
	
	    function checkLoadedFonts() {
	        var i, len = this.fonts.length;
	        var node, w;
	        var loadedCount = len;
	        for(i=0;i<len; i+= 1){
	            if(this.fonts[i].loaded){
	                loadedCount -= 1;
	                continue;
	            }
	            if(this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0){
	                this.fonts[i].loaded = true;
	            } else{
	                node = this.fonts[i].monoCase.node;
	                w = this.fonts[i].monoCase.w;
	                if(node.offsetWidth !== w){
	                    loadedCount -= 1;
	                    this.fonts[i].loaded = true;
	                }else{
	                    node = this.fonts[i].sansCase.node;
	                    w = this.fonts[i].sansCase.w;
	                    if(node.offsetWidth !== w){
	                        loadedCount -= 1;
	                        this.fonts[i].loaded = true;
	                    }
	                }
	                if(this.fonts[i].loaded){
	                    this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
	                    this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
	                }
	            }
	        }
	
	        if(loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime){
	            setTimeout(this.checkLoadedFonts.bind(this),20);
	        }else{
	            setTimeout(function(){this.isLoaded = true;}.bind(this),0);
	
	        }
	    }
	
	    function createHelper(def, fontData){
	        var tHelper = createNS('text');
	        tHelper.style.fontSize = '100px';
	        //tHelper.style.fontFamily = fontData.fFamily;
	        tHelper.setAttribute('font-family', fontData.fFamily);
	        tHelper.setAttribute('font-style', fontData.fStyle);
	        tHelper.setAttribute('font-weight', fontData.fWeight);
	        tHelper.textContent = '1';
	        if(fontData.fClass){
	            tHelper.style.fontFamily = 'inherit';
	            tHelper.setAttribute('class', fontData.fClass);
	        } else {
	            tHelper.style.fontFamily = fontData.fFamily;
	        }
	        def.appendChild(tHelper);
	        var tCanvasHelper = createTag('canvas').getContext('2d');
	        tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px '+ fontData.fFamily;
	        //tCanvasHelper.font = ' 100px '+ fontData.fFamily;
	        return tHelper;
	    }
	
	    function addFonts(fontData, defs){
	        if(!fontData){
	            this.isLoaded = true;
	            return;
	        }
	        if(this.chars){
	            this.isLoaded = true;
	            this.fonts = fontData.list;
	            return;
	        }
	
	
	        var fontArr = fontData.list;
	        var i, len = fontArr.length;
	        var _pendingFonts = len;
	        for(i=0; i<len; i+= 1){
	            var shouldLoadFont = true;
	            var loadedSelector;
	            var j;
	            fontArr[i].loaded = false;
	            fontArr[i].monoCase = setUpNode(fontArr[i].fFamily,'monospace');
	            fontArr[i].sansCase = setUpNode(fontArr[i].fFamily,'sans-serif');
	            if(!fontArr[i].fPath) {
	                fontArr[i].loaded = true;
	                _pendingFonts -= 1;
	            }else if(fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3){
	                loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="'+ fontArr[i].fFamily +'"], style[f-origin="3"][f-family="'+ fontArr[i].fFamily +'"]');
	
	                if (loadedSelector.length > 0) {
	                    shouldLoadFont = false;
	                }
	
	                if (shouldLoadFont) {
	                    var s = createTag('style');
	                    s.setAttribute('f-forigin', fontArr[i].fOrigin);
	                    s.setAttribute('f-origin', fontArr[i].origin);
	                    s.setAttribute('f-family', fontArr[i].fFamily);
	                    s.type = "text/css";
	                    s.innerHTML = "@font-face {" + "font-family: "+fontArr[i].fFamily+"; font-style: normal; src: url('"+fontArr[i].fPath+"');}";
	                    defs.appendChild(s);
	                }
	            } else if(fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1){
	                loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
	
	                for (j = 0; j < loadedSelector.length; j++) {
	                    if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
	                        // Font is already loaded
	                        shouldLoadFont = false;
	                    }
	                }
	
	                if (shouldLoadFont) {
	                    var l = createTag('link');
	                    l.setAttribute('f-forigin', fontArr[i].fOrigin);
	                    l.setAttribute('f-origin', fontArr[i].origin);
	                    l.type = "text/css";
	                    l.rel = "stylesheet";
	                    l.href = fontArr[i].fPath;
	                    document.body.appendChild(l);
	                }
	            } else if(fontArr[i].fOrigin === 't' || fontArr[i].origin === 2){
	                loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
	
	                for (j = 0; j < loadedSelector.length; j++) {
	                    if (fontArr[i].fPath === loadedSelector[j].src) {
	                        // Font is already loaded
	                        shouldLoadFont = false;
	                    }
	                }
	
	                if (shouldLoadFont) {
	                    var sc = createTag('link');
	                    sc.setAttribute('f-forigin', fontArr[i].fOrigin);
	                    sc.setAttribute('f-origin', fontArr[i].origin);
	                    sc.setAttribute('rel','stylesheet');
	                    sc.setAttribute('href',fontArr[i].fPath);
	                    defs.appendChild(sc);
	                }
	            }
	            fontArr[i].helper = createHelper(defs,fontArr[i]);
	            fontArr[i].cache = {};
	            this.fonts.push(fontArr[i]);
	        }
	        if (_pendingFonts === 0) {
	            this.isLoaded = true;
	        } else {
	            //On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
	            //Adding this timeout seems to fix it
	           setTimeout(this.checkLoadedFonts.bind(this), 100);
	        }
	    }
	
	    function addChars(chars){
	        if(!chars){
	            return;
	        }
	        if(!this.chars){
	            this.chars = [];
	        }
	        var i, len = chars.length;
	        var j, jLen = this.chars.length, found;
	        for(i=0;i<len;i+=1){
	            j = 0;
	            found = false;
	            while(j<jLen){
	                if(this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch){
	                    found = true;
	                }
	                j += 1;
	            }
	            if(!found){
	                this.chars.push(chars[i]);
	                jLen += 1;
	            }
	        }
	    }
	
	    function getCharData(char, style, font){
	        var i = 0, len = this.chars.length;
	        while( i < len) {
	            if(this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font){
	
	                return this.chars[i];
	            }
	            i+= 1;
	        }
	        if((typeof char === 'string' && char.charCodeAt(0) !== 13 || !char) && console && console.warn) {
	            console.warn('Missing character from exported characters list: ', char, style, font);
	        }
	        return emptyChar;
	    }
	
	    function measureText(char, fontName, size) {
	        var fontData = this.getFontByName(fontName);
	        var index = char.charCodeAt(0);
	        if(!fontData.cache[index + 1]) {
	            var tHelper = fontData.helper;
	            //Canvas version
	            //fontData.cache[index] = tHelper.measureText(char).width / 100;
	            //SVG version
	            //console.log(tHelper.getBBox().width)
	            if (char === ' ') {
	                tHelper.textContent = '|' + char + '|';
	                var doubleSize = tHelper.getComputedTextLength();
	                tHelper.textContent = '||';
	                var singleSize = tHelper.getComputedTextLength();
	                fontData.cache[index + 1] = (doubleSize - singleSize)/100;
	            } else {
	                tHelper.textContent = char;
	                fontData.cache[index + 1] = (tHelper.getComputedTextLength())/100;
	            }
	        }
	        return fontData.cache[index + 1] * size;
	    }
	
	    function getFontByName(name){
	        var i = 0, len = this.fonts.length;
	        while(i<len){
	            if(this.fonts[i].fName === name) {
	                return this.fonts[i];
	            }
	            i += 1;
	        }
	        return this.fonts[0];
	    }
	
	    function getCombinedCharacterCodes() {
	        return combinedCharacters;
	    }
	
	    function loaded() {
	        return this.isLoaded;
	    }
	
	    var Font = function(){
	        this.fonts = [];
	        this.chars = null;
	        this.typekitLoaded = 0;
	        this.isLoaded = false;
	        this.initTime = Date.now();
	    };
	    //TODO: for now I'm adding these methods to the Class and not the prototype. Think of a better way to implement it. 
	    Font.getCombinedCharacterCodes = getCombinedCharacterCodes;
	
	    Font.prototype.addChars = addChars;
	    Font.prototype.addFonts = addFonts;
	    Font.prototype.getCharData = getCharData;
	    Font.prototype.getFontByName = getFontByName;
	    Font.prototype.measureText = measureText;
	    Font.prototype.checkLoadedFonts = checkLoadedFonts;
	    Font.prototype.loaded = loaded;
	
	    return Font;
	
	}());
	var PropertyFactory = (function(){
	
	    var initFrame = initialDefaultFrame;
	    var math_abs = Math.abs;
	
	    function interpolateValue(frameNum, caching) {
	        var offsetTime = this.offsetTime;
	        var newValue;
	        if (this.propType === 'multidimensional') {
	            newValue = createTypedArray('float32', this.pv.length);
	        }
	        var iterationIndex = caching.lastIndex;
	        var i = iterationIndex;
	        var len = this.keyframes.length - 1, flag = true;
	        var keyData, nextKeyData;
	
	        while (flag) {
	            keyData = this.keyframes[i];
	            nextKeyData = this.keyframes[i + 1];
	            if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime){
	                if(keyData.h){
	                    keyData = nextKeyData;
	                }
	                iterationIndex = 0;
	                break;
	            }
	            if ((nextKeyData.t - offsetTime) > frameNum){
	                iterationIndex = i;
	                break;
	            }
	            if (i < len - 1){
	                i += 1;
	            } else {
	                iterationIndex = 0;
	                flag = false;
	            }
	        }
	
	        var k, kLen, perc, jLen, j, fnc;
	        var nextKeyTime = nextKeyData.t - offsetTime;
	        var keyTime = keyData.t - offsetTime;
	        var endValue;
	        if (keyData.to) {
	            if (!keyData.bezierData) {
	                keyData.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
	            }
	            var bezierData = keyData.bezierData;
	            if (frameNum >= nextKeyTime || frameNum < keyTime) {
	                var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
	                kLen = bezierData.points[ind].point.length;
	                for (k = 0; k < kLen; k += 1) {
	                    newValue[k] = bezierData.points[ind].point[k];
	                }
	                // caching._lastKeyframeIndex = -1;
	            } else {
	                if (keyData.__fnct) {
	                    fnc = keyData.__fnct;
	                } else {
	                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
	                    keyData.__fnct = fnc;
	                }
	                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
	                var distanceInLine = bezierData.segmentLength*perc;
	
	                var segmentPerc;
	                var addedLength =  (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastAddedLength : 0;
	                j =  (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastPoint : 0;
	                flag = true;
	                jLen = bezierData.points.length;
	                while (flag) {
	                    addedLength += bezierData.points[j].partialLength;
	                    if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
	                        kLen = bezierData.points[j].point.length;
	                        for (k = 0; k < kLen; k += 1) {
	                            newValue[k] = bezierData.points[j].point[k];
	                        }
	                        break;
	                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
	                        segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
	                        kLen = bezierData.points[j].point.length;
	                        for (k = 0; k < kLen; k += 1) {
	                            newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
	                        }
	                        break;
	                    }
	                    if (j < jLen - 1){
	                        j += 1;
	                    } else {
	                        flag = false;
	                    }
	                }
	                caching._lastPoint = j;
	                caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
	                caching._lastKeyframeIndex = i;
	            }
	        } else {
	            var outX, outY, inX, inY, keyValue;
	            len = keyData.s.length;
	            endValue = nextKeyData.s || keyData.e;
	            if (this.sh && keyData.h !== 1) {
	                if (frameNum >= nextKeyTime) {
	                    newValue[0] = endValue[0];
	                    newValue[1] = endValue[1];
	                    newValue[2] = endValue[2];
	                } else if (frameNum <= keyTime) {
	                    newValue[0] = keyData.s[0];
	                    newValue[1] = keyData.s[1];
	                    newValue[2] = keyData.s[2];
	                } else {
	                    var quatStart = createQuaternion(keyData.s);
	                    var quatEnd = createQuaternion(endValue);
	                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
	                    quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
	                }
	                
	            } else {
	                for(i = 0; i < len; i += 1) {
	                    if (keyData.h !== 1) {
	                        if (frameNum >= nextKeyTime) {
	                            perc = 1;
	                        } else if(frameNum < keyTime) {
	                            perc = 0;
	                        } else {
	                            if(keyData.o.x.constructor === Array) {
	                                if (!keyData.__fnct) {
	                                    keyData.__fnct = [];
	                                }
	                                if (!keyData.__fnct[i]) {
	                                    outX = (typeof keyData.o.x[i] === 'undefined') ? keyData.o.x[0] : keyData.o.x[i];
	                                    outY = (typeof keyData.o.y[i] === 'undefined') ? keyData.o.y[0] : keyData.o.y[i];
	                                    inX = (typeof keyData.i.x[i] === 'undefined') ? keyData.i.x[0] : keyData.i.x[i];
	                                    inY = (typeof keyData.i.y[i] === 'undefined') ? keyData.i.y[0] : keyData.i.y[i];
	                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
	                                    keyData.__fnct[i] = fnc;
	                                } else {
	                                    fnc = keyData.__fnct[i];
	                                }
	                            } else {
	                                if (!keyData.__fnct) {
	                                    outX = keyData.o.x;
	                                    outY = keyData.o.y;
	                                    inX = keyData.i.x;
	                                    inY = keyData.i.y;
	                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
	                                    keyData.__fnct = fnc;
	                                } else {
	                                    fnc = keyData.__fnct;
	                                }
	                            }
	                            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime ));
	                        }
	                    }
	
	                    endValue = nextKeyData.s || keyData.e;
	                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
	
	                    if (len === 1) {
	                        newValue = keyValue;
	                    } else {
	                        newValue[i] = keyValue;
	                    }
	                }
	            }
	        }
	        caching.lastIndex = iterationIndex;
	        return newValue;
	    }
	
	    //based on @Toji's https://github.com/toji/gl-matrix/
	    function slerp(a, b, t) {
	        var out = [];
	        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3]
	
	        var omega, cosom, sinom, scale0, scale1;
	
	        cosom = ax * bx + ay * by + az * bz + aw * bw;
	        if (cosom < 0.0) {
	            cosom = -cosom;
	            bx = -bx;
	            by = -by;
	            bz = -bz;
	            bw = -bw;
	        }
	        if ((1.0 - cosom) > 0.000001) {
	            omega = Math.acos(cosom);
	            sinom = Math.sin(omega);
	            scale0 = Math.sin((1.0 - t) * omega) / sinom;
	            scale1 = Math.sin(t * omega) / sinom;
	        } else {
	            scale0 = 1.0 - t;
	            scale1 = t;
	        }
	        out[0] = scale0 * ax + scale1 * bx;
	        out[1] = scale0 * ay + scale1 * by;
	        out[2] = scale0 * az + scale1 * bz;
	        out[3] = scale0 * aw + scale1 * bw;
	
	        return out;
	    }
	
	    function quaternionToEuler(out, quat) {
	        var qx = quat[0];
	        var qy = quat[1];
	        var qz = quat[2];
	        var qw = quat[3];
	        var heading = Math.atan2(2*qy*qw-2*qx*qz , 1 - 2*qy*qy - 2*qz*qz)
	        var attitude = Math.asin(2*qx*qy + 2*qz*qw) 
	        var bank = Math.atan2(2*qx*qw-2*qy*qz , 1 - 2*qx*qx - 2*qz*qz);
	        out[0] = heading/degToRads;
	        out[1] = attitude/degToRads;
	        out[2] = bank/degToRads;
	    }
	
	    function createQuaternion(values) {
	        var heading = values[0] * degToRads;
	        var attitude = values[1] * degToRads;
	        var bank = values[2] * degToRads;
	        var c1 = Math.cos(heading / 2);
	        var c2 = Math.cos(attitude / 2);
	        var c3 = Math.cos(bank / 2);
	        var s1 = Math.sin(heading / 2);
	        var s2 = Math.sin(attitude / 2);
	        var s3 = Math.sin(bank / 2);
	        var w = c1 * c2 * c3 - s1 * s2 * s3;
	        var x = s1 * s2 * c3 + c1 * c2 * s3;
	        var y = s1 * c2 * c3 + c1 * s2 * s3;
	        var z = c1 * s2 * c3 - s1 * c2 * s3;
	
	        return [x,y,z,w];
	    }
	
	    function getValueAtCurrentTime(){
	        var frameNum = this.comp.renderedFrame - this.offsetTime;
	        var initTime = this.keyframes[0].t - this.offsetTime;
	        var endTime = this.keyframes[this.keyframes.length- 1].t-this.offsetTime;
	        if(!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))){
	            if(this._caching.lastFrame >= frameNum) {
	                this._caching._lastKeyframeIndex = -1;
	                this._caching.lastIndex = 0;
	            }
	
	            var renderResult = this.interpolateValue(frameNum, this._caching);
	            this.pv = renderResult;
	        }
	        this._caching.lastFrame = frameNum;
	        return this.pv;
	    }
	
	    function setVValue(val) {
	        var multipliedValue;
	        if(this.propType === 'unidimensional') {
	            multipliedValue = val * this.mult;
	            if(math_abs(this.v - multipliedValue) > 0.00001) {
	                this.v = multipliedValue;
	                this._mdf = true;
	            }
	        } else {
	            var i = 0, len = this.v.length;
	            while (i < len) {
	                multipliedValue = val[i] * this.mult;
	                if (math_abs(this.v[i] - multipliedValue) > 0.00001) {
	                    this.v[i] = multipliedValue;
	                    this._mdf = true;
	                }
	                i += 1;
	            }
	        }
	    }
	
	    function processEffectsSequence() {
	        if(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
	            return;
	        }        
	        if(this.lock) {
	            this.setVValue(this.pv);
	            return;
	        }
	        this.lock = true;
	        this._mdf = this._isFirstFrame;
	        var multipliedValue;
	        var i, len = this.effectsSequence.length;
	        var finalValue = this.kf ? this.pv : this.data.k;
	        for(i = 0; i < len; i += 1) {
	            finalValue = this.effectsSequence[i](finalValue);
	        }
	        this.setVValue(finalValue);
	        this._isFirstFrame = false;
	        this.lock = false;
	        this.frameId = this.elem.globalData.frameId;
	    }
	
	    function addEffect(effectFunction) {
	        this.effectsSequence.push(effectFunction);
	        this.container.addDynamicProperty(this);
	    }
	
	    function ValueProperty(elem, data, mult, container){
	        this.propType = 'unidimensional';
	        this.mult = mult || 1;
	        this.data = data;
	        this.v = mult ? data.k * mult : data.k;
	        this.pv = data.k;
	        this._mdf = false;
	        this.elem = elem;
	        this.container = container;
	        this.comp = elem.comp;
	        this.k = false;
	        this.kf = false;
	        this.vel = 0;
	        this.effectsSequence = [];
	        this._isFirstFrame = true;
	        this.getValue = processEffectsSequence;
	        this.setVValue = setVValue;
	        this.addEffect = addEffect;
	    }
	
	    function MultiDimensionalProperty(elem, data, mult, container) {
	        this.propType = 'multidimensional';
	        this.mult = mult || 1;
	        this.data = data;
	        this._mdf = false;
	        this.elem = elem;
	        this.container = container;
	        this.comp = elem.comp;
	        this.k = false;
	        this.kf = false;
	        this.frameId = -1;
	        var i, len = data.k.length;
	        this.v = createTypedArray('float32', len);
	        this.pv = createTypedArray('float32', len);
	        var arr = createTypedArray('float32', len);
	        this.vel = createTypedArray('float32', len);
	        for (i = 0; i < len; i += 1) {
	            this.v[i] = data.k[i] * this.mult;
	            this.pv[i] = data.k[i];
	        }
	        this._isFirstFrame = true;
	        this.effectsSequence = [];
	        this.getValue = processEffectsSequence;
	        this.setVValue = setVValue;
	        this.addEffect = addEffect;
	    }
	
	    function KeyframedValueProperty(elem, data, mult, container) {
	        this.propType = 'unidimensional';
	        this.keyframes = data.k;
	        this.offsetTime = elem.data.st;
	        this.frameId = -1;
	        this._caching = {lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1};
	        this.k = true;
	        this.kf = true;
	        this.data = data;
	        this.mult = mult || 1;
	        this.elem = elem;
	        this.container = container;
	        this.comp = elem.comp;
	        this.v = initFrame;
	        this.pv = initFrame;
	        this._isFirstFrame = true;
	        this.getValue = processEffectsSequence;
	        this.setVValue = setVValue;
	        this.interpolateValue = interpolateValue;
	        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
	        this.addEffect = addEffect;
	    }
	
	    function KeyframedMultidimensionalProperty(elem, data, mult, container){
	        this.propType = 'multidimensional';
	        var i, len = data.k.length;
	        var s, e,to,ti;
	        for (i = 0; i < len - 1; i += 1) {
	            if (data.k[i].to && data.k[i].s && data.k[i].e) {
	                s = data.k[i].s;
	                e = data.k[i].e;
	                to = data.k[i].to;
	                ti = data.k[i].ti;
	                if((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],s[0] + to[0],s[1] + to[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],e[0] + ti[0],e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],s[0] + to[0],s[1] + to[1],s[2] + to[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],e[0] + ti[0],e[1] + ti[1],e[2] + ti[2]))){
	                    data.k[i].to = null;
	                    data.k[i].ti = null;
	                }
	                if(s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
	                    if(s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {
	                        data.k[i].to = null;
	                        data.k[i].ti = null;
	                    }
	                }
	            }
	        }
	        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
	        this.keyframes = data.k;
	        this.offsetTime = elem.data.st;
	        this.k = true;
	        this.kf = true;
	        this._isFirstFrame = true;
	        this.mult = mult || 1;
	        this.elem = elem;
	        this.container = container;
	        this.comp = elem.comp;
	        this.getValue = processEffectsSequence;
	        this.setVValue = setVValue;
	        this.interpolateValue = interpolateValue;
	        this.frameId = -1;
	        var arrLen = data.k[0].s.length;
	        this.v = createTypedArray('float32', arrLen);
	        this.pv = createTypedArray('float32', arrLen);
	        for (i = 0; i < arrLen; i += 1) {
	            this.v[i] = initFrame;
	            this.pv[i] = initFrame;
	        }
	        this._caching={lastFrame:initFrame,lastIndex:0,value:createTypedArray('float32', arrLen)};
	        this.addEffect = addEffect;
	    }
	
	    function getProp(elem,data,type, mult, container) {
	        var p;
	        if(!data.k.length){
	            p = new ValueProperty(elem,data, mult, container);
	        }else if(typeof(data.k[0]) === 'number'){
	            p = new MultiDimensionalProperty(elem,data, mult, container);
	        }else{
	            switch(type){
	                case 0:
	                    p = new KeyframedValueProperty(elem,data,mult, container);
	                    break;
	                case 1:
	                    p = new KeyframedMultidimensionalProperty(elem,data,mult, container);
	                    break;
	            }
	        }
	        if(p.effectsSequence.length){
	            container.addDynamicProperty(p);
	        }
	        return p;
	    }
	
	    var ob = {
	        getProp: getProp
	    };
	    return ob;
	}());
	var TransformPropertyFactory = (function() {
	
	    function applyToMatrix(mat) {
	        var _mdf = this._mdf;
	        this.iterateDynamicProperties();
	        this._mdf = this._mdf || _mdf;
	        if (this.a) {
	            mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	        }
	        if (this.s) {
	            mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	        }
	        if (this.sk) {
	            mat.skewFromAxis(-this.sk.v, this.sa.v);
	        }
	        if (this.r) {
	            mat.rotate(-this.r.v);
	        } else {
	            mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	        }
	        if (this.data.p.s) {
	            if (this.data.p.z) {
	                mat.translate(this.px.v, this.py.v, -this.pz.v);
	            } else {
	                mat.translate(this.px.v, this.py.v, 0);
	            }
	        } else {
	            mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
	        }
	    }
	    function processKeys(forceRender){
	        if (this.elem.globalData.frameId === this.frameId) {
	            return;
	        }
	        if(this._isDirty) {
	            this.precalculateMatrix();
	            this._isDirty = false;
	        }
	
	        this.iterateDynamicProperties();
	
	        if (this._mdf || forceRender) {
	            this.v.cloneFromProps(this.pre.props);
	            if (this.appliedTransformations < 1) {
	                this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	            }
	            if(this.appliedTransformations < 2) {
	                this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	            }
	            if (this.sk && this.appliedTransformations < 3) {
	                this.v.skewFromAxis(-this.sk.v, this.sa.v);
	            }
	            if (this.r && this.appliedTransformations < 4) {
	                this.v.rotate(-this.r.v);
	            } else if (!this.r && this.appliedTransformations < 4){
	                this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	            }
	            if (this.autoOriented) {
	                var v1,v2, frameRate = this.elem.globalData.frameRate;
	                if(this.p && this.p.keyframes && this.p.getValueAtTime) {
	                    if (this.p._caching.lastFrame+this.p.offsetTime <= this.p.keyframes[0].t) {
	                        v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate,0);
	                        v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
	                    } else if(this.p._caching.lastFrame+this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
	                        v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / frameRate), 0);
	                        v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.01) / frameRate, 0);
	                    } else {
	                        v1 = this.p.pv;
	                        v2 = this.p.getValueAtTime((this.p._caching.lastFrame+this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
	                    }
	                } else if(this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
	                    v1 = [];
	                    v2 = [];
	                    var px = this.px, py = this.py, frameRate;
	                    if (px._caching.lastFrame+px.offsetTime <= px.keyframes[0].t) {
	                        v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate,0);
	                        v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate,0);
	                        v2[0] = px.getValueAtTime((px.keyframes[0].t) / frameRate,0);
	                        v2[1] = py.getValueAtTime((py.keyframes[0].t) / frameRate,0);
	                    } else if(px._caching.lastFrame+px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
	                        v1[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t / frameRate),0);
	                        v1[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t / frameRate),0);
	                        v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate,0);
	                        v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate,0);
	                    } else {
	                        v1 = [px.pv, py.pv];
	                        v2[0] = px.getValueAtTime((px._caching.lastFrame+px.offsetTime - 0.01) / frameRate,px.offsetTime);
	                        v2[1] = py.getValueAtTime((py._caching.lastFrame+py.offsetTime - 0.01) / frameRate,py.offsetTime);
	                    }
	                }
	                this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
	            }
	            if(this.data.p && this.data.p.s){
	                if(this.data.p.z) {
	                    this.v.translate(this.px.v, this.py.v, -this.pz.v);
	                } else {
	                    this.v.translate(this.px.v, this.py.v, 0);
	                }
	            }else{
	                this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
	            }
	        }
	        this.frameId = this.elem.globalData.frameId;
	    }
	
	    function precalculateMatrix() {
	        if(!this.a.k) {
	            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
	            this.appliedTransformations = 1;
	        } else {
	            return;
	        }
	        if(!this.s.effectsSequence.length) {
	            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
	            this.appliedTransformations = 2;
	        } else {
	            return;
	        }
	        if(this.sk) {
	            if(!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
	                this.pre.skewFromAxis(-this.sk.v, this.sa.v);
	            this.appliedTransformations = 3;
	            } else {
	                return;
	            }
	        }
	        if (this.r) {
	            if(!this.r.effectsSequence.length) {
	                this.pre.rotate(-this.r.v);
	                this.appliedTransformations = 4;
	            } else {
	                return;
	            }
	        } else if(!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
	            this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
	            this.appliedTransformations = 4;
	        }
	    }
	
	    function autoOrient(){
	        //
	        //var prevP = this.getValueAtTime();
	    }
	
	    function addDynamicProperty(prop) {
	        this._addDynamicProperty(prop);
	        this.elem.addDynamicProperty(prop);
	        this._isDirty = true;
	    }
	
	    function TransformProperty(elem,data,container){
	        this.elem = elem;
	        this.frameId = -1;
	        this.propType = 'transform';
	        this.data = data;
	        this.v = new Matrix();
	        //Precalculated matrix with non animated properties
	        this.pre = new Matrix();
	        this.appliedTransformations = 0;
	        this.initDynamicPropertyContainer(container || elem);
	        if(data.p && data.p.s){
	            this.px = PropertyFactory.getProp(elem,data.p.x,0,0,this);
	            this.py = PropertyFactory.getProp(elem,data.p.y,0,0,this);
	            if(data.p.z){
	                this.pz = PropertyFactory.getProp(elem,data.p.z,0,0,this);
	            }
	        }else{
	            this.p = PropertyFactory.getProp(elem,data.p || {k:[0,0,0]},1,0,this);
	        }
	        if(data.rx) {
	            this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
	            this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
	            this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
	            if(data.or.k[0].ti) {
	                var i, len = data.or.k.length;
	                for(i=0;i<len;i+=1) {
	                    data.or.k[i].to = data.or.k[i].ti = null;
	                }
	            }
	            this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
	            //sh Indicates it needs to be capped between -180 and 180
	            this.or.sh = true;
	        } else {
	            this.r = PropertyFactory.getProp(elem, data.r || {k: 0}, 0, degToRads, this);
	        }
	        if(data.sk){
	            this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
	            this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
	        }
	        this.a = PropertyFactory.getProp(elem,data.a || {k:[0,0,0]},1,0,this);
	        this.s = PropertyFactory.getProp(elem,data.s || {k:[100,100,100]},1,0.01,this);
	        // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
	        if(data.o){
	            this.o = PropertyFactory.getProp(elem,data.o,0,0.01,elem);
	        } else {
	            this.o = {_mdf:false,v:1};
	        }
	        this._isDirty = true;
	        if(!this.dynamicProperties.length){
	            this.getValue(true);
	        }
	    }
	
	    TransformProperty.prototype = {
	        applyToMatrix: applyToMatrix,
	        getValue: processKeys,
	        precalculateMatrix: precalculateMatrix,
	        autoOrient: autoOrient
	    }
	
	    extendPrototype([DynamicPropertyContainer], TransformProperty);
	    TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
	    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
	
	    function getTransformProperty(elem,data,container){
	        return new TransformProperty(elem,data,container);
	    }
	
	    return {
	        getTransformProperty: getTransformProperty
	    };
	
	}());
	function ShapePath(){
		this.c = false;
		this._length = 0;
		this._maxLength = 8;
		this.v = createSizedArray(this._maxLength);
		this.o = createSizedArray(this._maxLength);
		this.i = createSizedArray(this._maxLength);
	}
	
	ShapePath.prototype.setPathData = function(closed, len) {
		this.c = closed;
		this.setLength(len);
		var i = 0;
		while(i < len){
			this.v[i] = point_pool.newElement();
			this.o[i] = point_pool.newElement();
			this.i[i] = point_pool.newElement();
			i += 1;
		}
	};
	
	ShapePath.prototype.setLength = function(len) {
		while(this._maxLength < len) {
			this.doubleArrayLength();
		}
		this._length = len;
	};
	
	ShapePath.prototype.doubleArrayLength = function() {
		this.v = this.v.concat(createSizedArray(this._maxLength));
		this.i = this.i.concat(createSizedArray(this._maxLength));
		this.o = this.o.concat(createSizedArray(this._maxLength));
		this._maxLength *= 2;
	};
	
	ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
		var arr;
		this._length = Math.max(this._length, pos + 1);
		if(this._length >= this._maxLength) {
			this.doubleArrayLength();
		}
		switch(type){
			case 'v':
				arr = this.v;
				break;
			case 'i':
				arr = this.i;
				break;
			case 'o':
				arr = this.o;
				break;
		}
		if(!arr[pos] || (arr[pos] && !replace)){
			arr[pos] = point_pool.newElement();
		}
		arr[pos][0] = x;
		arr[pos][1] = y;
	};
	
	ShapePath.prototype.setTripleAt = function(vX,vY,oX,oY,iX,iY,pos, replace) {
		this.setXYAt(vX,vY,'v',pos, replace);
		this.setXYAt(oX,oY,'o',pos, replace);
		this.setXYAt(iX,iY,'i',pos, replace);
	};
	
	ShapePath.prototype.reverse = function() {
		var newPath = new ShapePath();
		newPath.setPathData(this.c, this._length);
		var vertices = this.v, outPoints = this.o, inPoints = this.i;
		var init = 0;
		if (this.c) {
			newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
	        init = 1;
	    }
	    var cnt = this._length - 1;
	    var len = this._length;
	
	    var i;
	    for (i = init; i < len; i += 1) {
	    	newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
	        cnt -= 1;
	    }
	    return newPath;
	};
	var ShapePropertyFactory = (function(){
	
	    var initFrame = -999999;
	
	    function interpolateShape(frameNum, previousValue, caching) {
	        var iterationIndex = caching.lastIndex;
	        var keyPropS,keyPropE,isHold, j, k, jLen, kLen, perc, vertexValue;
	        var kf = this.keyframes;
	        if(frameNum < kf[0].t-this.offsetTime){
	            keyPropS = kf[0].s[0];
	            isHold = true;
	            iterationIndex = 0;
	        }else if(frameNum >= kf[kf.length - 1].t-this.offsetTime){
	            keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
	            /*if(kf[kf.length - 1].s){
	                keyPropS = kf[kf.length - 1].s[0];
	            }else{
	                keyPropS = kf[kf.length - 2].e[0];
	            }*/
	            isHold = true;
	        }else{
	            var i = iterationIndex;
	            var len = kf.length- 1,flag = true,keyData,nextKeyData;
	            while(flag){
	                keyData = kf[i];
	                nextKeyData = kf[i+1];
	                if((nextKeyData.t - this.offsetTime) > frameNum){
	                    break;
	                }
	                if(i < len - 1){
	                    i += 1;
	                }else{
	                    flag = false;
	                }
	            }
	            isHold = keyData.h === 1;
	            iterationIndex = i;
	            if(!isHold){
	                if(frameNum >= nextKeyData.t-this.offsetTime){
	                    perc = 1;
	                }else if(frameNum < keyData.t-this.offsetTime){
	                    perc = 0;
	                }else{
	                    var fnc;
	                    if(keyData.__fnct){
	                        fnc = keyData.__fnct;
	                    }else{
	                        fnc = BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y).get;
	                        keyData.__fnct = fnc;
	                    }
	                    perc = fnc((frameNum-(keyData.t-this.offsetTime))/((nextKeyData.t-this.offsetTime)-(keyData.t-this.offsetTime)));
	                }
	                keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
	            }
	            keyPropS = keyData.s[0];
	        }
	        jLen = previousValue._length;
	        kLen = keyPropS.i[0].length;
	        caching.lastIndex = iterationIndex;
	
	        for(j=0;j<jLen;j+=1){
	            for(k=0;k<kLen;k+=1){
	                vertexValue = isHold ? keyPropS.i[j][k] :  keyPropS.i[j][k]+(keyPropE.i[j][k]-keyPropS.i[j][k])*perc;
	                previousValue.i[j][k] = vertexValue;
	                vertexValue = isHold ? keyPropS.o[j][k] :  keyPropS.o[j][k]+(keyPropE.o[j][k]-keyPropS.o[j][k])*perc;
	                previousValue.o[j][k] = vertexValue;
	                vertexValue = isHold ? keyPropS.v[j][k] :  keyPropS.v[j][k]+(keyPropE.v[j][k]-keyPropS.v[j][k])*perc;
	                previousValue.v[j][k] = vertexValue;
	            }
	        }
	    }
	
	    function interpolateShapeCurrentTime(){
	        var frameNum = this.comp.renderedFrame - this.offsetTime;
	        var initTime = this.keyframes[0].t - this.offsetTime;
	        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
	        var lastFrame = this._caching.lastFrame;
	        if(!(lastFrame !== initFrame && ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime)))){
	            ////
	            this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
	            this.interpolateShape(frameNum, this.pv, this._caching);
	            ////
	        }
	        this._caching.lastFrame = frameNum;
	        return this.pv;
	    }
	
	    function resetShape(){
	        this.paths = this.localShapeCollection;
	    }
	
	    function shapesEqual(shape1, shape2) {
	        if(shape1._length !== shape2._length || shape1.c !== shape2.c){
	            return false;
	        }
	        var i, len = shape1._length;
	        for(i = 0; i < len; i += 1) {
	            if(shape1.v[i][0] !== shape2.v[i][0] 
	            || shape1.v[i][1] !== shape2.v[i][1] 
	            || shape1.o[i][0] !== shape2.o[i][0] 
	            || shape1.o[i][1] !== shape2.o[i][1] 
	            || shape1.i[i][0] !== shape2.i[i][0] 
	            || shape1.i[i][1] !== shape2.i[i][1]) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    function setVValue(newPath) {
	        if(!shapesEqual(this.v, newPath)) {
	            this.v = shape_pool.clone(newPath);
	            this.localShapeCollection.releaseShapes();
	            this.localShapeCollection.addShape(this.v);
	            this._mdf = true;
	            this.paths = this.localShapeCollection;
	        }
	    }
	
	    function processEffectsSequence() {
	        if(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
	            return;
	        }
	        if(this.lock) {
	            this.setVValue(this.pv);
	            return;
	        }
	        this.lock = true;
	        this._mdf = false;
	        var finalValue = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
	        var i, len = this.effectsSequence.length;
	        for(i = 0; i < len; i += 1) {
	            finalValue = this.effectsSequence[i](finalValue);
	        }
	        this.setVValue(finalValue);
	        this.lock = false;
	        this.frameId = this.elem.globalData.frameId;
	    };
	
	    function ShapeProperty(elem, data, type){
	        this.propType = 'shape';
	        this.comp = elem.comp;
	        this.container = elem;
	        this.elem = elem;
	        this.data = data;
	        this.k = false;
	        this.kf = false;
	        this._mdf = false;
	        var pathData = type === 3 ? data.pt.k : data.ks.k;
	        this.v = shape_pool.clone(pathData);
	        this.pv = shape_pool.clone(this.v);
	        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	        this.paths = this.localShapeCollection;
	        this.paths.addShape(this.v);
	        this.reset = resetShape;
	        this.effectsSequence = [];
	    }
	
	    function addEffect(effectFunction) {
	        this.effectsSequence.push(effectFunction);
	        this.container.addDynamicProperty(this);
	    }
	
	    ShapeProperty.prototype.interpolateShape = interpolateShape;
	    ShapeProperty.prototype.getValue = processEffectsSequence;
	    ShapeProperty.prototype.setVValue = setVValue;
	    ShapeProperty.prototype.addEffect = addEffect;
	
	    function KeyframedShapeProperty(elem,data,type){
	        this.propType = 'shape';
	        this.comp = elem.comp;
	        this.elem = elem;
	        this.container = elem;
	        this.offsetTime = elem.data.st;
	        this.keyframes = type === 3 ? data.pt.k : data.ks.k;
	        this.k = true;
	        this.kf = true;
	        var i, len = this.keyframes[0].s[0].i.length;
	        var jLen = this.keyframes[0].s[0].i[0].length;
	        this.v = shape_pool.newElement();
	        this.v.setPathData(this.keyframes[0].s[0].c, len);
	        this.pv = shape_pool.clone(this.v);
	        this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	        this.paths = this.localShapeCollection;
	        this.paths.addShape(this.v);
	        this.lastFrame = initFrame;
	        this.reset = resetShape;
	        this._caching = {lastFrame: initFrame, lastIndex: 0};
	        this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
	    }
	    KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
	    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
	    KeyframedShapeProperty.prototype.setVValue = setVValue;
	    KeyframedShapeProperty.prototype.addEffect = addEffect;
	
	    var EllShapeProperty = (function(){
	
	        var cPoint = roundCorner;
	
	        function EllShapeProperty(elem,data) {
	            /*this.v = {
	                v: createSizedArray(4),
	                i: createSizedArray(4),
	                o: createSizedArray(4),
	                c: true
	            };*/
	            this.v = shape_pool.newElement();
	            this.v.setPathData(true, 4);
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.paths = this.localShapeCollection;
	            this.localShapeCollection.addShape(this.v);
	            this.d = data.d;
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.frameId = -1;
	            this.initDynamicPropertyContainer(elem);
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this);
	            this.s = PropertyFactory.getProp(elem,data.s,1,0,this);
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.k = false;
	                this.convertEllToPath();
	            }
	        };
	
	        EllShapeProperty.prototype = {
	            reset: resetShape,
	            getValue: function (){
	                if(this.elem.globalData.frameId === this.frameId){
	                    return;
	                }
	                this.frameId = this.elem.globalData.frameId;
	                this.iterateDynamicProperties();
	
	                if(this._mdf){
	                    this.convertEllToPath();
	                }
	            },
	            convertEllToPath: function() {
	                var p0 = this.p.v[0], p1 = this.p.v[1], s0 = this.s.v[0]/2, s1 = this.s.v[1]/2;
	                var _cw = this.d !== 3;
	                var _v = this.v;
	                _v.v[0][0] = p0;
	                _v.v[0][1] = p1 - s1;
	                _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
	                _v.v[1][1] = p1;
	                _v.v[2][0] = p0;
	                _v.v[2][1] = p1 + s1;
	                _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
	                _v.v[3][1] = p1;
	                _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
	                _v.i[0][1] = p1 - s1;
	                _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
	                _v.i[1][1] = p1 - s1 * cPoint;
	                _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
	                _v.i[2][1] = p1 + s1;
	                _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
	                _v.i[3][1] = p1 + s1 * cPoint;
	                _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
	                _v.o[0][1] = p1 - s1;
	                _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
	                _v.o[1][1] = p1 + s1 * cPoint;
	                _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
	                _v.o[2][1] = p1 + s1;
	                _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
	                _v.o[3][1] = p1 - s1 * cPoint;
	            }
	        }
	
	        extendPrototype([DynamicPropertyContainer], EllShapeProperty);
	
	        return EllShapeProperty;
	    }());
	
	    var StarShapeProperty = (function() {
	
	        function StarShapeProperty(elem,data) {
	            this.v = shape_pool.newElement();
	            this.v.setPathData(true, 0);
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.data = data;
	            this.frameId = -1;
	            this.d = data.d;
	            this.initDynamicPropertyContainer(elem);
	            if(data.sy === 1){
	                this.ir = PropertyFactory.getProp(elem,data.ir,0,0,this);
	                this.is = PropertyFactory.getProp(elem,data.is,0,0.01,this);
	                this.convertToPath = this.convertStarToPath;
	            } else {
	                this.convertToPath = this.convertPolygonToPath;
	            }
	            this.pt = PropertyFactory.getProp(elem,data.pt,0,0,this);
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this);
	            this.r = PropertyFactory.getProp(elem,data.r,0,degToRads,this);
	            this.or = PropertyFactory.getProp(elem,data.or,0,0,this);
	            this.os = PropertyFactory.getProp(elem,data.os,0,0.01,this);
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.localShapeCollection.addShape(this.v);
	            this.paths = this.localShapeCollection;
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.k = false;
	                this.convertToPath();
	            }
	        };
	
	        StarShapeProperty.prototype = {
	            reset: resetShape,
	            getValue: function() {
	                if(this.elem.globalData.frameId === this.frameId){
	                    return;
	                }
	                this.frameId = this.elem.globalData.frameId;
	                this.iterateDynamicProperties();
	                if(this._mdf){
	                    this.convertToPath();
	                }
	            },
	            convertStarToPath: function() {
	                var numPts = Math.floor(this.pt.v)*2;
	                var angle = Math.PI*2/numPts;
	                /*this.v.v.length = numPts;
	                this.v.i.length = numPts;
	                this.v.o.length = numPts;*/
	                var longFlag = true;
	                var longRad = this.or.v;
	                var shortRad = this.ir.v;
	                var longRound = this.os.v;
	                var shortRound = this.is.v;
	                var longPerimSegment = 2*Math.PI*longRad/(numPts*2);
	                var shortPerimSegment = 2*Math.PI*shortRad/(numPts*2);
	                var i, rad,roundness,perimSegment, currentAng = -Math.PI/ 2;
	                currentAng += this.r.v;
	                var dir = this.data.d === 3 ? -1 : 1;
	                this.v._length = 0;
	                for(i=0;i<numPts;i+=1){
	                    rad = longFlag ? longRad : shortRad;
	                    roundness = longFlag ? longRound : shortRound;
	                    perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
	                    var x = rad * Math.cos(currentAng);
	                    var y = rad * Math.sin(currentAng);
	                    var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
	                    var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
	                    x +=  + this.p.v[0];
	                    y +=  + this.p.v[1];
	                    this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);
	
	                    /*this.v.v[i] = [x,y];
	                    this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
	                    this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
	                    this.v._length = numPts;*/
	                    longFlag = !longFlag;
	                    currentAng += angle*dir;
	                }
	            },
	            convertPolygonToPath: function() {
	                var numPts = Math.floor(this.pt.v);
	                var angle = Math.PI*2/numPts;
	                var rad = this.or.v;
	                var roundness = this.os.v;
	                var perimSegment = 2*Math.PI*rad/(numPts*4);
	                var i, currentAng = -Math.PI/ 2;
	                var dir = this.data.d === 3 ? -1 : 1;
	                currentAng += this.r.v;
	                this.v._length = 0;
	                for(i=0;i<numPts;i+=1){
	                    var x = rad * Math.cos(currentAng);
	                    var y = rad * Math.sin(currentAng);
	                    var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
	                    var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
	                    x +=  + this.p.v[0];
	                    y +=  + this.p.v[1];
	                    this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);
	                    currentAng += angle*dir;
	                }
	                this.paths.length = 0;
	                this.paths[0] = this.v;
	            }
	
	        }
	        extendPrototype([DynamicPropertyContainer], StarShapeProperty);
	
	        return StarShapeProperty;
	    }());
	
	    var RectShapeProperty = (function() {
	
	         function RectShapeProperty(elem,data) {
	            this.v = shape_pool.newElement();
	            this.v.c = true;
	            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
	            this.localShapeCollection.addShape(this.v);
	            this.paths = this.localShapeCollection;
	            this.elem = elem;
	            this.comp = elem.comp;
	            this.frameId = -1;
	            this.d = data.d;
	            this.initDynamicPropertyContainer(elem);
	            this.p = PropertyFactory.getProp(elem,data.p,1,0,this);
	            this.s = PropertyFactory.getProp(elem,data.s,1,0,this);
	            this.r = PropertyFactory.getProp(elem,data.r,0,0,this);
	            if(this.dynamicProperties.length){
	                this.k = true;
	            }else{
	                this.k = false;
	                this.convertRectToPath();
	            }
	        };
	
	        RectShapeProperty.prototype = {
	            convertRectToPath: function (){
	                var p0 = this.p.v[0], p1 = this.p.v[1], v0 = this.s.v[0]/2, v1 = this.s.v[1]/2;
	                var round = bm_min(v0,v1,this.r.v);
	                var cPoint = round*(1-roundCorner);
	                this.v._length = 0;
	
	                if(this.d === 2 || this.d === 1) {
	                    this.v.setTripleAt(p0+v0, p1-v1+round,p0+v0, p1-v1+round,p0+v0,p1-v1+cPoint,0, true);
	                    this.v.setTripleAt(p0+v0, p1+v1-round,p0+v0, p1+v1-cPoint,p0+v0, p1+v1-round,1, true);
	                    if(round!== 0){
	                        this.v.setTripleAt(p0+v0-round, p1+v1,p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,2, true);
	                        this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,p0-v0+round,p1+v1,3, true);
	                        this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,4, true);
	                        this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,p0-v0,p1-v1+round,5, true);
	                        this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,6, true);
	                        this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,p0+v0-round,p1-v1,7, true);
	                    } else {
	                        this.v.setTripleAt(p0-v0,p1+v1,p0-v0+cPoint,p1+v1,p0-v0,p1+v1,2);
	                        this.v.setTripleAt(p0-v0,p1-v1,p0-v0,p1-v1+cPoint,p0-v0,p1-v1,3);
	                    }
	                }else{
	                    this.v.setTripleAt(p0+v0,p1-v1+round,p0+v0,p1-v1+cPoint,p0+v0,p1-v1+round,0, true);
	                    if(round!== 0){
	                        this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,1, true);
	                        this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,p0-v0+round,p1-v1,2, true);
	                        this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,3, true);
	                        this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,p0-v0,p1+v1-round,4, true);
	                        this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,5, true);
	                        this.v.setTripleAt(p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,p0+v0-round,p1+v1,6, true);
	                        this.v.setTripleAt(p0+v0,p1+v1-round,p0+v0,p1+v1-round,p0+v0,p1+v1-cPoint,7, true);
	                    } else {
	                        this.v.setTripleAt(p0-v0,p1-v1,p0-v0+cPoint,p1-v1,p0-v0,p1-v1,1, true);
	                        this.v.setTripleAt(p0-v0,p1+v1,p0-v0,p1+v1-cPoint,p0-v0,p1+v1,2, true);
	                        this.v.setTripleAt(p0+v0,p1+v1,p0+v0-cPoint,p1+v1,p0+v0,p1+v1,3, true);
	
	                    }
	                }
	            },
	            getValue: function(frameNum){
	                if(this.elem.globalData.frameId === this.frameId){
	                    return;
	                }
	                this.frameId = this.elem.globalData.frameId;
	                this.iterateDynamicProperties();
	                if(this._mdf){
	                    this.convertRectToPath();
	                }
	
	            },
	            reset: resetShape
	        }
	        extendPrototype([DynamicPropertyContainer], RectShapeProperty);
	
	        return RectShapeProperty;
	    }());
	
	    function getShapeProp(elem,data,type){
	        var prop;
	        if(type === 3 || type === 4){
	            var dataProp = type === 3 ? data.pt : data.ks;
	            var keys = dataProp.k;
	            if(keys.length){
	                prop = new KeyframedShapeProperty(elem, data, type);
	            }else{
	                prop = new ShapeProperty(elem, data, type);
	            }
	        }else if(type === 5){
	            prop = new RectShapeProperty(elem, data);
	        }else if(type === 6){
	            prop = new EllShapeProperty(elem, data);
	        }else if(type === 7){
	            prop = new StarShapeProperty(elem, data);
	        }
	        if(prop.k){
	            elem.addDynamicProperty(prop);
	        }
	        return prop;
	    }
	
	    function getConstructorFunction() {
	        return ShapeProperty;
	    }
	
	    function getKeyframedConstructorFunction() {
	        return KeyframedShapeProperty;
	    }
	
	    var ob = {};
	    ob.getShapeProp = getShapeProp;
	    ob.getConstructorFunction = getConstructorFunction;
	    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
	    return ob;
	}());
	var ShapeModifiers = (function(){
	    var ob = {};
	    var modifiers = {};
	    ob.registerModifier = registerModifier;
	    ob.getModifier = getModifier;
	
	    function registerModifier(nm,factory){
	        if(!modifiers[nm]){
	            modifiers[nm] = factory;
	        }
	    }
	
	    function getModifier(nm,elem, data){
	        return new modifiers[nm](elem, data);
	    }
	
	    return ob;
	}());
	
	function ShapeModifier(){}
	ShapeModifier.prototype.initModifierProperties = function(){};
	ShapeModifier.prototype.addShapeToModifier = function(){};
	ShapeModifier.prototype.addShape = function(data){
	    if(!this.closed){
	        var shapeData = {shape:data.sh, data: data, localShapeCollection:shapeCollection_pool.newShapeCollection()};
	        this.shapes.push(shapeData);
	        this.addShapeToModifier(shapeData);
	        if(this._isAnimated) {
	            data.setAsAnimated();
	        }
	    }
	};
	ShapeModifier.prototype.init = function(elem,data){
	    this.shapes = [];
	    this.elem = elem;
	    this.initDynamicPropertyContainer(elem);
	    this.initModifierProperties(elem,data);
	    this.frameId = initialDefaultFrame;
	    this.closed = false;
	    this.k = false;
	    if(this.dynamicProperties.length){
	        this.k = true;
	    }else{
	        this.getValue(true);
	    }
	};
	ShapeModifier.prototype.processKeys = function(){
	    if(this.elem.globalData.frameId === this.frameId){
	        return;
	    }
	    this.frameId = this.elem.globalData.frameId;
	    this.iterateDynamicProperties();
	};
	
	extendPrototype([DynamicPropertyContainer], ShapeModifier);
	function TrimModifier(){
	}
	extendPrototype([ShapeModifier], TrimModifier);
	TrimModifier.prototype.initModifierProperties = function(elem, data) {
	    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
	    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
	    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
	    this.sValue = 0;
	    this.eValue = 0;
	    this.getValue = this.processKeys;
	    this.m = data.m;
	    this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
	};
	
	TrimModifier.prototype.addShapeToModifier = function(shapeData){
	    shapeData.pathsData = [];
	};
	
	TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
	    var segments = [];
	    if (e <= 1) {
	        segments.push({
	            s: s,
	            e: e
	        });
	    } else if (s >= 1) {
	        segments.push({
	            s: s - 1,
	            e: e - 1
	        });
	    } else {
	        segments.push({
	            s: s,
	            e: 1
	        });
	        segments.push({
	            s: 0,
	            e: e - 1
	        });
	    }
	    var shapeSegments = [];
	    var i, len = segments.length, segmentOb;
	    for (i = 0; i < len; i += 1) {
	        segmentOb = segments[i];
	        if (segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength) {
	            
	        } else {
	            var shapeS, shapeE;
	            if (segmentOb.s * totalModifierLength <= addedLength) {
	                shapeS = 0;
	            } else {
	                shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
	            }
	            if(segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
	                shapeE = 1;
	            } else {
	                shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
	            }
	            shapeSegments.push([shapeS, shapeE]);
	        }
	    }
	    if (!shapeSegments.length) {
	        shapeSegments.push([0, 0]);
	    }
	    return shapeSegments;
	};
	
	TrimModifier.prototype.releasePathsData = function(pathsData) {
	    var i, len = pathsData.length;
	    for (i = 0; i < len; i += 1) {
	        segments_length_pool.release(pathsData[i]);
	    }
	    pathsData.length = 0;
	    return pathsData;
	};
	
	TrimModifier.prototype.processShapes = function(_isFirstFrame) {
	    var s, e;
	    if (this._mdf || _isFirstFrame) {
	        var o = (this.o.v % 360) / 360;
	        if (o < 0) {
	            o += 1;
	        }
	        s = (this.s.v > 1 ? 1 : this.s.v < 0 ? 0 : this.s.v) + o;
	        e = (this.e.v > 1 ? 1 : this.e.v < 0 ? 0 : this.e.v) + o;
	        if (s === e) {
	
	        }
	        if (s > e) {
	            var _s = s;
	            s = e;
	            e = _s;
	        }
	        s = Math.round(s * 10000) * 0.0001;
	        e = Math.round(e * 10000) * 0.0001;
	        this.sValue = s;
	        this.eValue = e;
	    } else {
	        s = this.sValue;
	        e = this.eValue;
	    }
	    var shapePaths;
	    var i, len = this.shapes.length, j, jLen;
	    var pathsData, pathData, totalShapeLength, totalModifierLength = 0;
	
	    if (e === s) {
	        for (i = 0; i < len; i += 1) {
	            this.shapes[i].localShapeCollection.releaseShapes();
	            this.shapes[i].shape._mdf = true;
	            this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
	        }
	    } else if (!((e === 1 && s === 0) || (e===0 && s === 1))){
	        var segments = [], shapeData, localShapeCollection;
	        for (i = 0; i < len; i += 1) {
	            shapeData = this.shapes[i];
	            // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
	            if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
	                shapeData.shape.paths = shapeData.localShapeCollection;
	            } else {
	                shapePaths = shapeData.shape.paths;
	                jLen = shapePaths._length;
	                totalShapeLength = 0;
	                if (!shapeData.shape._mdf && shapeData.pathsData.length) {
	                    totalShapeLength = shapeData.totalShapeLength;
	                } else {
	                    pathsData = this.releasePathsData(shapeData.pathsData);
	                    for (j = 0; j < jLen; j += 1) {
	                        pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
	                        pathsData.push(pathData);
	                        totalShapeLength += pathData.totalLength;
	                    }
	                    shapeData.totalShapeLength = totalShapeLength;
	                    shapeData.pathsData = pathsData;
	                }
	
	                totalModifierLength += totalShapeLength;
	                shapeData.shape._mdf = true;
	            }
	        }
	        var shapeS = s, shapeE = e, addedLength = 0, edges;
	        for (i = len - 1; i >= 0; i -= 1) {
	            shapeData = this.shapes[i];
	            if (shapeData.shape._mdf) {
	                localShapeCollection = shapeData.localShapeCollection;
	                localShapeCollection.releaseShapes();
	                //if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
	                if (this.m === 2 && len > 1) {
	                    edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
	                    addedLength += shapeData.totalShapeLength;
	                } else {
	                    edges = [[shapeS, shapeE]];
	                }
	                jLen = edges.length;
	                for (j = 0; j < jLen; j += 1) {
	                    shapeS = edges[j][0];
	                    shapeE = edges[j][1];
	                    segments.length = 0;
	                    if (shapeE <= 1) {
	                        segments.push({
	                            s:shapeData.totalShapeLength * shapeS,
	                            e:shapeData.totalShapeLength * shapeE
	                        });
	                    } else if (shapeS >= 1) {
	                        segments.push({
	                            s:shapeData.totalShapeLength * (shapeS - 1),
	                            e:shapeData.totalShapeLength * (shapeE - 1)
	                        });
	                    } else {
	                        segments.push({
	                            s:shapeData.totalShapeLength * shapeS,
	                            e:shapeData.totalShapeLength
	                        });
	                        segments.push({
	                            s:0,
	                            e:shapeData.totalShapeLength * (shapeE - 1)
	                        });
	                    }
	                    var newShapesData = this.addShapes(shapeData,segments[0]);
	                    if (segments[0].s !== segments[0].e) {
	                        if (segments.length > 1) {
	                            var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
	                            if (lastShapeInCollection.c) {
	                                var lastShape = newShapesData.pop();
	                                this.addPaths(newShapesData, localShapeCollection);
	                                newShapesData = this.addShapes(shapeData, segments[1], lastShape);
	                            } else {
	                                this.addPaths(newShapesData, localShapeCollection);
	                                newShapesData = this.addShapes(shapeData, segments[1]);
	                            }
	                        } 
	                        this.addPaths(newShapesData, localShapeCollection);
	                    }
	                    
	                }
	                shapeData.shape.paths = localShapeCollection;
	            }
	        }
	    } else if (this._mdf) {
	        for (i = 0; i < len; i += 1) {
	            //Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
	            //Don't remove this even if it's losing cached info.
	            this.shapes[i].pathsData.length = 0;
	            this.shapes[i].shape._mdf = true;
	        }
	    }
	};
	
	TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
	    var i, len = newPaths.length;
	    for (i = 0; i < len; i += 1) {
	        localShapeCollection.addShape(newPaths[i]);
	    }
	};
	
	TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
	    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
	    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
	    if(newShape){
	        shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
	    }
	    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
	};
	
	TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
	    shapePath.setXYAt(points[1], points[5], 'o', pos);
	    shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
	    if(newShape){
	        shapePath.setXYAt(points[0], points[4], 'v', pos);
	    }
	    shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
	};
	
	TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
	    var pathsData = shapeData.pathsData;
	    var shapePaths = shapeData.shape.paths.shapes;
	    var i, len = shapeData.shape.paths._length, j, jLen;
	    var addedLength = 0;
	    var currentLengthData,segmentCount;
	    var lengths;
	    var segment;
	    var shapes = [];
	    var initPos;
	    var newShape = true;
	    if (!shapePath) {
	        shapePath = shape_pool.newElement();
	        segmentCount = 0;
	        initPos = 0;
	    } else {
	        segmentCount = shapePath._length;
	        initPos = shapePath._length;
	    }
	    shapes.push(shapePath);
	    for (i = 0; i < len; i += 1) {
	        lengths = pathsData[i].lengths;
	        shapePath.c = shapePaths[i].c;
	        jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
	        for (j = 1; j < jLen; j +=1) {
	            currentLengthData = lengths[j-1];
	            if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
	                addedLength += currentLengthData.addedLength;
	                shapePath.c = false;
	            } else if(addedLength > shapeSegment.e) {
	                shapePath.c = false;
	                break;
	            } else {
	                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
	                    this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
	                    newShape = false;
	                } else {
	                    segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength)/currentLengthData.addedLength,(shapeSegment.e - addedLength)/currentLengthData.addedLength, lengths[j-1]);
	                    this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
	                    // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
	                    newShape = false;
	                    shapePath.c = false;
	                }
	                addedLength += currentLengthData.addedLength;
	                segmentCount += 1;
	            }
	        }
	        if (shapePaths[i].c && lengths.length) {
	            currentLengthData = lengths[j - 1];
	            if (addedLength <= shapeSegment.e) {
	                var segmentLength = lengths[j - 1].addedLength;
	                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
	                    this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
	                    newShape = false;
	                } else {
	                    segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
	                    this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
	                    // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
	                    newShape = false;
	                    shapePath.c = false;
	                }
	            } else {
	                shapePath.c = false;
	            }
	            addedLength += currentLengthData.addedLength;
	            segmentCount += 1;
	        }
	        if (shapePath._length) {
	            shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
	            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1],'o', shapePath._length - 1);
	        }
	        if (addedLength > shapeSegment.e) {
	            break;
	        }
	        if (i < len - 1) {
	            shapePath = shape_pool.newElement();
	            newShape = true;
	            shapes.push(shapePath);
	            segmentCount = 0;
	        }
	    }
	    return shapes;
	};
	
	
	ShapeModifiers.registerModifier('tm', TrimModifier);
	function RoundCornersModifier(){}
	extendPrototype([ShapeModifier],RoundCornersModifier);
	RoundCornersModifier.prototype.initModifierProperties = function(elem,data){
	    this.getValue = this.processKeys;
	    this.rd = PropertyFactory.getProp(elem,data.r,0,null,this);
	    this._isAnimated = !!this.rd.effectsSequence.length;
	};
	
	RoundCornersModifier.prototype.processPath = function(path, round){
	    var cloned_path = shape_pool.newElement();
	    cloned_path.c = path.c;
	    var i, len = path._length;
	    var currentV,currentI,currentO,closerV, newV,newO,newI,distance,newPosPerc,index = 0;
	    var vX,vY,oX,oY,iX,iY;
	    for(i=0;i<len;i+=1){
	        currentV = path.v[i];
	        currentO = path.o[i];
	        currentI = path.i[i];
	        if(currentV[0]===currentO[0] && currentV[1]===currentO[1] && currentV[0]===currentI[0] && currentV[1]===currentI[1]){
	            if((i===0 || i === len - 1) && !path.c){
	                cloned_path.setTripleAt(currentV[0],currentV[1],currentO[0],currentO[1],currentI[0],currentI[1],index);
	                /*cloned_path.v[index] = currentV;
	                cloned_path.o[index] = currentO;
	                cloned_path.i[index] = currentI;*/
	                index += 1;
	            } else {
	                if(i===0){
	                    closerV = path.v[len-1];
	                } else {
	                    closerV = path.v[i-1];
	                }
	                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
	                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
	                vX = iX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
	                vY = iY = currentV[1]-(currentV[1]-closerV[1])*newPosPerc;
	                oX = vX-(vX-currentV[0])*roundCorner;
	                oY = vY-(vY-currentV[1])*roundCorner;
	                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);
	                index += 1;
	
	                if(i === len - 1){
	                    closerV = path.v[0];
	                } else {
	                    closerV = path.v[i+1];
	                }
	                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
	                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
	                vX = oX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
	                vY = oY = currentV[1]+(closerV[1]-currentV[1])*newPosPerc;
	                iX = vX-(vX-currentV[0])*roundCorner;
	                iY = vY-(vY-currentV[1])*roundCorner;
	                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);
	                index += 1;
	            }
	        } else {
	            cloned_path.setTripleAt(path.v[i][0],path.v[i][1],path.o[i][0],path.o[i][1],path.i[i][0],path.i[i][1],index);
	            index += 1;
	        }
	    }
	    return cloned_path;
	};
	
	RoundCornersModifier.prototype.processShapes = function(_isFirstFrame){
	    var shapePaths;
	    var i, len = this.shapes.length;
	    var j, jLen;
	    var rd = this.rd.v;
	
	    if(rd !== 0){
	        var shapeData, newPaths, localShapeCollection;
	        for(i=0;i<len;i+=1){
	            shapeData = this.shapes[i];
	            newPaths = shapeData.shape.paths;
	            localShapeCollection = shapeData.localShapeCollection;
	            if(!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)){
	                localShapeCollection.releaseShapes();
	                shapeData.shape._mdf = true;
	                shapePaths = shapeData.shape.paths.shapes;
	                jLen = shapeData.shape.paths._length;
	                for(j=0;j<jLen;j+=1){
	                    localShapeCollection.addShape(this.processPath(shapePaths[j],rd));
	                }
	            }
	            shapeData.shape.paths = shapeData.localShapeCollection;
	        }
	
	    }
	    if(!this.dynamicProperties.length){
	        this._mdf = false;
	    }
	};
	
	ShapeModifiers.registerModifier('rd',RoundCornersModifier);
	function RepeaterModifier(){}
	extendPrototype([ShapeModifier], RepeaterModifier);
	
	RepeaterModifier.prototype.initModifierProperties = function(elem,data){
	    this.getValue = this.processKeys;
	    this.c = PropertyFactory.getProp(elem,data.c,0,null,this);
	    this.o = PropertyFactory.getProp(elem,data.o,0,null,this);
	    this.tr = TransformPropertyFactory.getTransformProperty(elem,data.tr,this);
	    this.so = PropertyFactory.getProp(elem,data.tr.so,0,0.01,this);
	    this.eo = PropertyFactory.getProp(elem,data.tr.eo,0,0.01,this);
	    this.data = data;
	    if(!this.dynamicProperties.length){
	        this.getValue(true);
	    }
	    this._isAnimated = !!this.dynamicProperties.length;
	    this.pMatrix = new Matrix();
	    this.rMatrix = new Matrix();
	    this.sMatrix = new Matrix();
	    this.tMatrix = new Matrix();
	    this.matrix = new Matrix();
	};
	
	RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv){
	    var dir = inv ? -1 : 1;
	    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
	    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
	    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
	    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	    rMatrix.rotate(-transform.r.v * dir * perc);
	    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
	    sMatrix.scale(inv ? 1/scaleX : scaleX, inv ? 1/scaleY : scaleY);
	    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
	};
	
	RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {
	    this.elem = elem;
	    this.arr = arr;
	    this.pos = pos;
	    this.elemsData = elemsData;
	    this._currentCopies = 0;
	    this._elements = [];
	    this._groups = [];
	    this.frameId = -1;
	    this.initDynamicPropertyContainer(elem);
	    this.initModifierProperties(elem,arr[pos]);
	    var cont = 0;
	    while(pos>0){
	        pos -= 1;
	        //this._elements.unshift(arr.splice(pos,1)[0]);
	        this._elements.unshift(arr[pos]);
	        cont += 1;
	    }
	    if(this.dynamicProperties.length){
	        this.k = true;
	    }else{
	        this.getValue(true);
	    }
	};
	
	RepeaterModifier.prototype.resetElements = function(elements){
	    var i, len = elements.length;
	    for(i = 0; i < len; i += 1) {
	        elements[i]._processed = false;
	        if(elements[i].ty === 'gr'){
	            this.resetElements(elements[i].it);
	        }
	    }
	};
	
	RepeaterModifier.prototype.cloneElements = function(elements){
	    var i, len = elements.length;
	    var newElements = JSON.parse(JSON.stringify(elements));
	    this.resetElements(newElements);
	    return newElements;
	};
	
	RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
	    var i, len = elements.length;
	    for(i = 0; i < len; i += 1) {
	        elements[i]._render = renderFlag;
	        if(elements[i].ty === 'gr') {
	            this.changeGroupRender(elements[i].it, renderFlag);
	        }
	    }
	};
	
	RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
	    var items, itemsTransform, i, dir, cont;
	    if(this._mdf || _isFirstFrame){
	        var copies = Math.ceil(this.c.v);
	        if(this._groups.length < copies){
	            while(this._groups.length < copies){
	                var group = {
	                    it:this.cloneElements(this._elements),
	                    ty:'gr'
	                };
	                group.it.push({"a":{"a":0,"ix":1,"k":[0,0]},"nm":"Transform","o":{"a":0,"ix":7,"k":100},"p":{"a":0,"ix":2,"k":[0,0]},"r":{"a":1,"ix":6,"k":[{s:0,e:0,t:0},{s:0,e:0,t:1}]},"s":{"a":0,"ix":3,"k":[100,100]},"sa":{"a":0,"ix":5,"k":0},"sk":{"a":0,"ix":4,"k":0},"ty":"tr"});
	                
	                this.arr.splice(0,0,group);
	                this._groups.splice(0,0,group);
	                this._currentCopies += 1;
	            }
	            this.elem.reloadShapes();
	        }
	        cont = 0;
	        var renderFlag;
	        for(i = 0; i  <= this._groups.length - 1; i += 1){
	            renderFlag = cont < copies;
	            this._groups[i]._render = renderFlag;
	            this.changeGroupRender(this._groups[i].it, renderFlag);
	            cont += 1;
	        }
	        
	        this._currentCopies = copies;
	        ////
	
	        var offset = this.o.v;
	        var offsetModulo = offset%1;
	        var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
	        var k;
	        var tMat = this.tr.v.props;
	        var pProps = this.pMatrix.props;
	        var rProps = this.rMatrix.props;
	        var sProps = this.sMatrix.props;
	        this.pMatrix.reset();
	        this.rMatrix.reset();
	        this.sMatrix.reset();
	        this.tMatrix.reset();
	        this.matrix.reset();
	        var iteration = 0;
	
	        if(offset > 0) {
	            while(iteration<roundOffset){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	                iteration += 1;
	            }
	            if(offsetModulo){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
	                iteration += offsetModulo;
	            }
	        } else if(offset < 0) {
	            while(iteration>roundOffset){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
	                iteration -= 1;
	            }
	            if(offsetModulo){
	                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, - offsetModulo, true);
	                iteration -= offsetModulo;
	            }
	        }
	        i = this.data.m === 1 ? 0 : this._currentCopies - 1;
	        dir = this.data.m === 1 ? 1 : -1;
	        cont = this._currentCopies;
	        var j, jLen;
	        while(cont){
	            items = this.elemsData[i].it;
	            itemsTransform = items[items.length - 1].transform.mProps.v.props;
	            jLen = itemsTransform.length;
	            items[items.length - 1].transform.mProps._mdf = true;
	            items[items.length - 1].transform.op._mdf = true;
	            items[items.length - 1].transform.op.v = this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
	            if(iteration !== 0){
	                if((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)){
	                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
	                }
	                this.matrix.transform(rProps[0],rProps[1],rProps[2],rProps[3],rProps[4],rProps[5],rProps[6],rProps[7],rProps[8],rProps[9],rProps[10],rProps[11],rProps[12],rProps[13],rProps[14],rProps[15]);
	                this.matrix.transform(sProps[0],sProps[1],sProps[2],sProps[3],sProps[4],sProps[5],sProps[6],sProps[7],sProps[8],sProps[9],sProps[10],sProps[11],sProps[12],sProps[13],sProps[14],sProps[15]);
	                this.matrix.transform(pProps[0],pProps[1],pProps[2],pProps[3],pProps[4],pProps[5],pProps[6],pProps[7],pProps[8],pProps[9],pProps[10],pProps[11],pProps[12],pProps[13],pProps[14],pProps[15]);
	                
	                for(j=0;j<jLen;j+=1) {
	                    itemsTransform[j] = this.matrix.props[j];
	                }
	                this.matrix.reset();
	            } else {
	                this.matrix.reset();
	                for(j=0;j<jLen;j+=1) {
	                    itemsTransform[j] = this.matrix.props[j];
	                }
	            }
	            iteration += 1;
	            cont -= 1;
	            i += dir;
	        }
	    } else {
	        cont = this._currentCopies;
	        i = 0;
	        dir = 1;
	        while(cont){
	            items = this.elemsData[i].it;
	            itemsTransform = items[items.length - 1].transform.mProps.v.props;
	            items[items.length - 1].transform.mProps._mdf = false;
	            items[items.length - 1].transform.op._mdf = false;
	            cont -= 1;
	            i += dir;
	        }
	    }
	};
	
	RepeaterModifier.prototype.addShape = function(){};
	
	ShapeModifiers.registerModifier('rp',RepeaterModifier);
	function ShapeCollection(){
		this._length = 0;
		this._maxLength = 4;
		this.shapes = createSizedArray(this._maxLength);
	}
	
	ShapeCollection.prototype.addShape = function(shapeData){
		if(this._length === this._maxLength){
			this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
			this._maxLength *= 2;
		}
		this.shapes[this._length] = shapeData;
		this._length += 1;
	};
	
	ShapeCollection.prototype.releaseShapes = function(){
		var i;
		for(i = 0; i < this._length; i += 1) {
			shape_pool.release(this.shapes[i]);
		}
		this._length = 0;
	};
	function DashProperty(elem, data, renderer, container) {
	    this.elem = elem;
	    this.frameId = -1;
	    this.dataProps = createSizedArray(data.length);
	    this.renderer = renderer;
	    this.k = false;
	    this.dashStr = '';
	    this.dashArray = createTypedArray('float32',  data.length ? data.length - 1 : 0);
	    this.dashoffset = createTypedArray('float32',  1);
	    this.initDynamicPropertyContainer(container);
	    var i, len = data.length || 0, prop;
	    for(i = 0; i < len; i += 1) {
	        prop = PropertyFactory.getProp(elem,data[i].v,0, 0, this);
	        this.k = prop.k || this.k;
	        this.dataProps[i] = {n:data[i].n,p:prop};
	    }
	    if(!this.k){
	        this.getValue(true);
	    }
	    this._isAnimated = this.k;
	}
	
	DashProperty.prototype.getValue = function(forceRender) {
	    if(this.elem.globalData.frameId === this.frameId && !forceRender){
	        return;
	    }
	    this.frameId = this.elem.globalData.frameId;
	    this.iterateDynamicProperties();
	    this._mdf = this._mdf || forceRender;
	    if (this._mdf) {
	        var i = 0, len = this.dataProps.length;
	        if(this.renderer === 'svg') {
	            this.dashStr = '';
	        }
	        for(i=0;i<len;i+=1){
	            if(this.dataProps[i].n != 'o'){
	                if(this.renderer === 'svg') {
	                    this.dashStr += ' ' + this.dataProps[i].p.v;
	                }else{
	                    this.dashArray[i] = this.dataProps[i].p.v;
	                }
	            }else{
	                this.dashoffset[0] = this.dataProps[i].p.v;
	            }
	        }
	    }
	};
	extendPrototype([DynamicPropertyContainer], DashProperty);
	function GradientProperty(elem,data,container){
	    this.data = data;
	    this.c = createTypedArray('uint8c', data.p*4);
	    var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p*4) : data.k.k.length - data.p*4;
	    this.o = createTypedArray('float32', cLength);
	    this._cmdf = false;
	    this._omdf = false;
	    this._collapsable = this.checkCollapsable();
	    this._hasOpacity = cLength;
	    this.initDynamicPropertyContainer(container);
	    this.prop = PropertyFactory.getProp(elem,data.k,1,null,this);
	    this.k = this.prop.k;
	    this.getValue(true);
	}
	
	GradientProperty.prototype.comparePoints = function(values, points) {
	    var i = 0, len = this.o.length/2, diff;
	    while(i < len) {
	        diff = Math.abs(values[i*4] - values[points*4 + i*2]);
	        if(diff > 0.01){
	            return false;
	        }
	        i += 1;
	    }
	    return true;
	};
	
	GradientProperty.prototype.checkCollapsable = function() {
	    if (this.o.length/2 !== this.c.length/4) {
	        return false;
	    }
	    if (this.data.k.k[0].s) {
	        var i = 0, len = this.data.k.k.length;
	        while (i < len) {
	            if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
	                return false;
	            }
	            i += 1;
	        }
	    } else if(!this.comparePoints(this.data.k.k, this.data.p)) {
	        return false;
	    }
	    return true;
	};
	
	GradientProperty.prototype.getValue = function(forceRender){
	    this.prop.getValue();
	    this._mdf = false;
	    this._cmdf = false;
	    this._omdf = false;
	    if(this.prop._mdf || forceRender){
	        var i, len = this.data.p*4;
	        var mult, val;
	        for(i=0;i<len;i+=1){
	            mult = i%4 === 0 ? 100 : 255;
	            val = Math.round(this.prop.v[i]*mult);
	            if(this.c[i] !== val){
	                this.c[i] = val;
	                this._cmdf = !forceRender;
	            }
	        }
	        if(this.o.length){
	            len = this.prop.v.length;
	            for(i=this.data.p*4;i<len;i+=1){
	                mult = i%2 === 0 ? 100 : 1;
	                val = i%2 === 0 ?  Math.round(this.prop.v[i]*100):this.prop.v[i];
	                if(this.o[i-this.data.p*4] !== val){
	                    this.o[i-this.data.p*4] = val;
	                    this._omdf = !forceRender;
	                }
	            }
	        }
	        this._mdf = !forceRender;
	    }
	};
	
	extendPrototype([DynamicPropertyContainer], GradientProperty);
	var buildShapeString = function(pathNodes, length, closed, mat) {
		if(length === 0) {
	            return '';
	        }
	        var _o = pathNodes.o;
	        var _i = pathNodes.i;
	        var _v = pathNodes.v;
	        var i, shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
	        for(i = 1; i < length; i += 1) {
	            shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
	        }
	        if (closed && length) {
	            shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
	            shapeString += 'z';
	        }
	        return shapeString;
	}
	var ImagePreloader = (function(){
	
	    var proxyImage = (function(){
	        var canvas = createTag('canvas');
	        canvas.width = 1;
	        canvas.height = 1;
	        var ctx = canvas.getContext('2d');
	        ctx.fillStyle = '#FF0000';
	        ctx.fillRect(0, 0, 1, 1);
	        return canvas;
	    }())
	
	    function imageLoaded(){
	        this.loadedAssets += 1;
	        if(this.loadedAssets === this.totalImages){
	            if(this.imagesLoadedCb) {
	                this.imagesLoadedCb(null);
	            }
	        }
	    }
	
	    function getAssetsPath(assetData, assetsPath, original_path) {
	        var path = '';
	        if (assetData.e) {
	            path = assetData.p;
	        } else if(assetsPath) {
	            var imagePath = assetData.p;
	            if (imagePath.indexOf('images/') !== -1) {
	                imagePath = imagePath.split('/')[1];
	            }
	            path = assetsPath + imagePath;
	        } else {
	            path = original_path;
	            path += assetData.u ? assetData.u : '';
	            path += assetData.p;
	        }
	        return path;
	    }
	
	    function createImageData(assetData) {
	        var path = getAssetsPath(assetData, this.assetsPath, this.path);
	        var img = createTag('img');
	        img.crossOrigin = 'anonymous';
	        img.addEventListener('load', this._imageLoaded.bind(this), false);
	        img.addEventListener('error', function() {
	            ob.img = proxyImage;
	            this._imageLoaded();
	        }.bind(this), false);
	        img.src = path;
	        var ob = {
	            img: img,
	            assetData: assetData
	        }
	        return ob;
	    }
	
	    function loadAssets(assets, cb){
	        this.imagesLoadedCb = cb;
	        var i, len = assets.length;
	        for (i = 0; i < len; i += 1) {
	            if(!assets[i].layers){
	                this.totalImages += 1;
	                this.images.push(this._createImageData(assets[i]));
	            }
	        }
	    }
	
	    function setPath(path){
	        this.path = path || '';
	    }
	
	    function setAssetsPath(path){
	        this.assetsPath = path || '';
	    }
	
	    function getImage(assetData) {
	        var i = 0, len = this.images.length;
	        while (i < len) {
	            if (this.images[i].assetData === assetData) {
	                return this.images[i].img;
	            }
	            i += 1;
	        }
	    }
	
	    function destroy() {
	        this.imagesLoadedCb = null;
	        this.images.length = 0;
	    }
	
	    function loaded() {
	        return this.totalImages === this.loadedAssets;
	    }
	
	    return function ImagePreloader(){
	        this.loadAssets = loadAssets;
	        this.setAssetsPath = setAssetsPath;
	        this.setPath = setPath;
	        this.loaded = loaded;
	        this.destroy = destroy;
	        this.getImage = getImage;
	        this._createImageData = createImageData;
	        this._imageLoaded = imageLoaded;
	        this.assetsPath = '';
	        this.path = '';
	        this.totalImages = 0;
	        this.loadedAssets = 0;
	        this.imagesLoadedCb = null;
	        this.images = [];
	    };
	}());
	var featureSupport = (function(){
		var ob = {
			maskType: true
		};
		if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
		   ob.maskType = false;
		}
		return ob;
	}());
	var filtersFactory = (function(){
		var ob = {};
		ob.createFilter = createFilter;
		ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
	
		function createFilter(filId){
	        	var fil = createNS('filter');
	        	fil.setAttribute('id',filId);
	                fil.setAttribute('filterUnits','objectBoundingBox');
	                fil.setAttribute('x','0%');
	                fil.setAttribute('y','0%');
	                fil.setAttribute('width','100%');
	                fil.setAttribute('height','100%');
	                return fil;
		}
	
		function createAlphaToLuminanceFilter(){
	                var feColorMatrix = createNS('feColorMatrix');
	                feColorMatrix.setAttribute('type','matrix');
	                feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	                feColorMatrix.setAttribute('values','0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
	                return feColorMatrix;
		}
	
		return ob;
	}());
	var assetLoader = (function(){
	
		function formatResponse(xhr) {
			if(xhr.response && typeof xhr.response === 'object') {
				return xhr.response;
			} else if(xhr.response && typeof xhr.response === 'string') {
				return JSON.parse(xhr.response);
			} else if(xhr.responseText) {
				return JSON.parse(xhr.responseText);
			}
		}
	
		function loadAsset(path, callback, errorCallback) {
			var response;
			var xhr = new XMLHttpRequest();
			xhr.open('GET', path, true);
			// set responseType after calling open or IE will break.
			try {
			    // This crashes on Android WebView prior to KitKat
			    xhr.responseType = "json";
			} catch (err) {}
		    xhr.send();
		    xhr.onreadystatechange = function () {
		        if (xhr.readyState == 4) {
		            if(xhr.status == 200){
		            	response = formatResponse(xhr);
		            	callback(response);
		            }else{
		                try{
		            		response = formatResponse(xhr);
		            		callback(response);
		                }catch(err){
		                	if(errorCallback) {
		                		errorCallback(err);
		                	}
		                }
		            }
		        }
		    };
		}
		return {
			load: loadAsset
		}
	}())
	
	function TextAnimatorProperty(textData, renderType, elem){
	    this._isFirstFrame = true;
		this._hasMaskedPath = false;
		this._frameId = -1;
		this._textData = textData;
		this._renderType = renderType;
	    this._elem = elem;
		this._animatorsData = createSizedArray(this._textData.a.length);
		this._pathData = {};
		this._moreOptions = {
			alignment: {}
		};
		this.renderedLetters = [];
	    this.lettersChangedFlag = false;
	    this.initDynamicPropertyContainer(elem);
	
	}
	
	TextAnimatorProperty.prototype.searchProperties = function(){
	    var i, len = this._textData.a.length, animatorProps;
	    var getProp = PropertyFactory.getProp;
	    for(i=0;i<len;i+=1){
	        animatorProps = this._textData.a[i];
	        this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
	    }
	    if(this._textData.p && 'm' in this._textData.p){
	        this._pathData = {
	            f: getProp(this._elem,this._textData.p.f,0,0,this),
	            l: getProp(this._elem,this._textData.p.l,0,0,this),
	            r: this._textData.p.r,
	            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
	        };
	        this._hasMaskedPath = true;
	    } else {
	        this._hasMaskedPath = false;
	    }
	    this._moreOptions.alignment = getProp(this._elem,this._textData.m.a,1,0,this);
	};
	
	TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag){
	    this.lettersChangedFlag = lettersChangedFlag;
	    if(!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
	        return;
	    }
	    this._isFirstFrame = false;
	    var alignment = this._moreOptions.alignment.v;
	    var animators = this._animatorsData;
	    var textData = this._textData;
	    var matrixHelper = this.mHelper;
	    var renderType = this._renderType;
	    var renderedLettersCount = this.renderedLetters.length;
	    var data = this.data;
	    var xPos,yPos;
	    var i, len;
	    var letters = documentData.l, pathInfo, currentLength, currentPoint, segmentLength, flag, pointInd, segmentInd, prevPoint, points, segments, partialLength, totalLength, perc, tanAngle, mask;
	    if(this._hasMaskedPath) {
	        mask = this._pathData.m;
	        if(!this._pathData.n || this._pathData._mdf){
	            var paths = mask.v;
	            if(this._pathData.r){
	                paths = paths.reverse();
	            }
	            // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
	            pathInfo = {
	                tLength: 0,
	                segments: []
	            };
	            len = paths._length - 1;
	            var bezierData;
	            totalLength = 0;
	            for (i = 0; i < len; i += 1) {
	                bezierData = bez.buildBezierData(paths.v[i]
	                    , paths.v[i + 1]
	                    , [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]]
	                    , [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
	                pathInfo.tLength += bezierData.segmentLength;
	                pathInfo.segments.push(bezierData);
	                totalLength += bezierData.segmentLength;
	            }
	            i = len;
	            if (mask.v.c) {
	                bezierData = bez.buildBezierData(paths.v[i]
	                    , paths.v[0]
	                    , [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]]
	                    , [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
	                pathInfo.tLength += bezierData.segmentLength;
	                pathInfo.segments.push(bezierData);
	                totalLength += bezierData.segmentLength;
	            }
	            this._pathData.pi = pathInfo;
	        }
	        pathInfo = this._pathData.pi;
	
	        currentLength = this._pathData.f.v;
	        segmentInd = 0;
	        pointInd = 1;
	        segmentLength = 0;
	        flag = true;
	        segments = pathInfo.segments;
	        if (currentLength < 0 && mask.v.c) {
	            if (pathInfo.tLength < Math.abs(currentLength)) {
	                currentLength = -Math.abs(currentLength) % pathInfo.tLength;
	            }
	            segmentInd = segments.length - 1;
	            points = segments[segmentInd].points;
	            pointInd = points.length - 1;
	            while (currentLength < 0) {
	                currentLength += points[pointInd].partialLength;
	                pointInd -= 1;
	                if (pointInd < 0) {
	                    segmentInd -= 1;
	                    points = segments[segmentInd].points;
	                    pointInd = points.length - 1;
	                }
	            }
	
	        }
	        points = segments[segmentInd].points;
	        prevPoint = points[pointInd - 1];
	        currentPoint = points[pointInd];
	        partialLength = currentPoint.partialLength;
	    }
	
	
	    len = letters.length;
	    xPos = 0;
	    yPos = 0;
	    var yOff = documentData.finalSize * 1.2 * 0.714;
	    var firstLine = true;
	    var animatorProps, animatorSelector;
	    var j, jLen;
	    var letterValue;
	
	    jLen = animators.length;
	    var lastLetter;
	
	    var mult, ind = -1, offf, xPathPos, yPathPos;
	    var initPathPos = currentLength,initSegmentInd = segmentInd, initPointInd = pointInd, currentLine = -1;
	    var elemOpacity;
	    var sc,sw,fc,k;
	    var lineLength = 0;
	    var letterSw, letterSc, letterFc, letterM = '', letterP = this.defaultPropsArray, letterO;
	
	    //
	    if(documentData.j === 2 || documentData.j === 1) {
	        var animatorJustifyOffset = 0;
	        var animatorFirstCharOffset = 0;
	        var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
	        var lastIndex = 0;
	        var isNewLine = true;
	
	        for (i = 0; i < len; i += 1) {
	            if (letters[i].n) {
	                if(animatorJustifyOffset) {
	                    animatorJustifyOffset += animatorFirstCharOffset;
	                }
	                while (lastIndex < i) {
	                    letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
	                    lastIndex += 1;
	                }
	                animatorJustifyOffset = 0;
	                isNewLine = true;
	            } else {
	                for (j = 0; j < jLen; j += 1) {
	                    animatorProps = animators[j].a;
	                    if (animatorProps.t.propType) {
	                        if (isNewLine && documentData.j === 2) {
	                            animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
	                        }
	                        animatorSelector = animators[j].s;
	                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
	                        if (mult.length) {
	                            animatorJustifyOffset += animatorProps.t.v*mult[0] * justifyOffsetMult;
	                        } else {
	                            animatorJustifyOffset += animatorProps.t.v*mult * justifyOffsetMult;
	                        }
	                    }
	                }
	                isNewLine = false;
	            }
	        }
	        if(animatorJustifyOffset) {
	            animatorJustifyOffset += animatorFirstCharOffset;
	        }
	        while(lastIndex < i) {
	            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
	            lastIndex += 1;
	        }
	    }
	    //
	
	    for( i = 0; i < len; i += 1) {
	
	        matrixHelper.reset();
	        elemOpacity = 1;
	        if(letters[i].n) {
	            xPos = 0;
	            yPos += documentData.yOffset;
	            yPos += firstLine ? 1 : 0;
	            currentLength = initPathPos ;
	            firstLine = false;
	            lineLength = 0;
	            if(this._hasMaskedPath) {
	                segmentInd = initSegmentInd;
	                pointInd = initPointInd;
	                points = segments[segmentInd].points;
	                prevPoint = points[pointInd - 1];
	                currentPoint = points[pointInd];
	                partialLength = currentPoint.partialLength;
	                segmentLength = 0;
	            }
	            letterO = letterSw = letterFc = letterM = '';
	            letterP = this.defaultPropsArray;
	        }else{
	            if(this._hasMaskedPath) {
	                if(currentLine !== letters[i].line){
	                    switch(documentData.j){
	                        case 1:
	                            currentLength += totalLength - documentData.lineWidths[letters[i].line];
	                            break;
	                        case 2:
	                            currentLength += (totalLength - documentData.lineWidths[letters[i].line])/2;
	                            break;
	                    }
	                    currentLine = letters[i].line;
	                }
	                if (ind !== letters[i].ind) {
	                    if (letters[ind]) {
	                        currentLength += letters[ind].extra;
	                    }
	                    currentLength += letters[i].an / 2;
	                    ind = letters[i].ind;
	                }
	                currentLength += alignment[0] * letters[i].an / 200;
	                var animatorOffset = 0;
	                for (j = 0; j < jLen; j += 1) {
	                    animatorProps = animators[j].a;
	                    if (animatorProps.p.propType) {
	                        animatorSelector = animators[j].s;
	                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                        if(mult.length){
	                            animatorOffset += animatorProps.p.v[0] * mult[0];
	                        } else{
	                            animatorOffset += animatorProps.p.v[0] * mult;
	                        }
	
	                    }
	                    if (animatorProps.a.propType) {
	                        animatorSelector = animators[j].s;
	                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                        if(mult.length){
	                            animatorOffset += animatorProps.a.v[0] * mult[0];
	                        } else{
	                            animatorOffset += animatorProps.a.v[0] * mult;
	                        }
	
	                    }
	                }
	                flag = true;
	                while (flag) {
	                    if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
	                        perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
	                        xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
	                        yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
	                        matrixHelper.translate(-alignment[0]*letters[i].an/200, -(alignment[1] * yOff / 100));
	                        flag = false;
	                    } else if (points) {
	                        segmentLength += currentPoint.partialLength;
	                        pointInd += 1;
	                        if (pointInd >= points.length) {
	                            pointInd = 0;
	                            segmentInd += 1;
	                            if (!segments[segmentInd]) {
	                                if (mask.v.c) {
	                                    pointInd = 0;
	                                    segmentInd = 0;
	                                    points = segments[segmentInd].points;
	                                } else {
	                                    segmentLength -= currentPoint.partialLength;
	                                    points = null;
	                                }
	                            } else {
	                                points = segments[segmentInd].points;
	                            }
	                        }
	                        if (points) {
	                            prevPoint = currentPoint;
	                            currentPoint = points[pointInd];
	                            partialLength = currentPoint.partialLength;
	                        }
	                    }
	                }
	                offf = letters[i].an / 2 - letters[i].add;
	                matrixHelper.translate(-offf, 0, 0);
	            } else {
	                offf = letters[i].an/2 - letters[i].add;
	                matrixHelper.translate(-offf,0,0);
	
	                // Grouping alignment
	                matrixHelper.translate(-alignment[0]*letters[i].an/200, -alignment[1]*yOff/100, 0);
	            }
	
	            lineLength += letters[i].l/2;
	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;
	                if (animatorProps.t.propType) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                    //This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
	                    if(xPos !== 0 || documentData.j !== 0) {
	                        if(this._hasMaskedPath) {
	                            if(mult.length) {
	                                currentLength += animatorProps.t.v*mult[0];
	                            } else {
	                                currentLength += animatorProps.t.v*mult;
	                            }
	                        }else{
	                            if(mult.length) {
	                                xPos += animatorProps.t.v*mult[0];
	                            } else {
	                                xPos += animatorProps.t.v*mult;
	                            }
	                        }
	                    }
	                }
	            }
	            lineLength += letters[i].l/2;
	            if(documentData.strokeWidthAnim) {
	                sw = documentData.sw || 0;
	            }
	            if(documentData.strokeColorAnim) {
	                if(documentData.sc){
	                    sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
	                }else{
	                    sc = [0,0,0];
	                }
	            }
	            if(documentData.fillColorAnim && documentData.fc) {
	                fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
	            }
	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;
	                if (animatorProps.a.propType) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	
	                    if(mult.length){
	                        matrixHelper.translate(-animatorProps.a.v[0]*mult[0], -animatorProps.a.v[1]*mult[1], animatorProps.a.v[2]*mult[2]);
	                    } else {
	                        matrixHelper.translate(-animatorProps.a.v[0]*mult, -animatorProps.a.v[1]*mult, animatorProps.a.v[2]*mult);
	                    }
	                }
	            }
	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;
	                if (animatorProps.s.propType) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                    if(mult.length){
	                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult[0]),1+((animatorProps.s.v[1]-1)*mult[1]),1);
	                    } else {
	                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult),1+((animatorProps.s.v[1]-1)*mult),1);
	                    }
	                }
	            }
	            for(j=0;j<jLen;j+=1) {
	                animatorProps = animators[j].a;
	                animatorSelector = animators[j].s;
	                mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                if (animatorProps.sk.propType) {
	                    if(mult.length) {
	                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
	                    } else {
	                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
	                    }
	                }
	                if (animatorProps.r.propType) {
	                    if(mult.length) {
	                        matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
	                    } else {
	                        matrixHelper.rotateZ(-animatorProps.r.v * mult);
	                    }
	                }
	                if (animatorProps.ry.propType) {
	
	                    if(mult.length) {
	                        matrixHelper.rotateY(animatorProps.ry.v*mult[1]);
	                    }else{
	                        matrixHelper.rotateY(animatorProps.ry.v*mult);
	                    }
	                }
	                if (animatorProps.rx.propType) {
	                    if(mult.length) {
	                        matrixHelper.rotateX(animatorProps.rx.v*mult[0]);
	                    } else {
	                        matrixHelper.rotateX(animatorProps.rx.v*mult);
	                    }
	                }
	                if (animatorProps.o.propType) {
	                    if(mult.length) {
	                        elemOpacity += ((animatorProps.o.v)*mult[0] - elemOpacity)*mult[0];
	                    } else {
	                        elemOpacity += ((animatorProps.o.v)*mult - elemOpacity)*mult;
	                    }
	                }
	                if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
	                    if(mult.length) {
	                        sw += animatorProps.sw.v*mult[0];
	                    } else {
	                        sw += animatorProps.sw.v*mult;
	                    }
	                }
	                if (documentData.strokeColorAnim && animatorProps.sc.propType) {
	                    for(k=0;k<3;k+=1){
	                        if(mult.length) {
	                            sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult[0];
	                        } else {
	                            sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult;
	                        }
	                    }
	                }
	                if (documentData.fillColorAnim && documentData.fc) {
	                    if(animatorProps.fc.propType){
	                        for(k=0;k<3;k+=1){
	                            if(mult.length) {
	                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult[0];
	                            } else {
	                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult;
	                            }
	                        }
	                    }
	                    if(animatorProps.fh.propType){
	                        if(mult.length) {
	                            fc = addHueToRGB(fc,animatorProps.fh.v*mult[0]);
	                        } else {
	                            fc = addHueToRGB(fc,animatorProps.fh.v*mult);
	                        }
	                    }
	                    if(animatorProps.fs.propType){
	                        if(mult.length) {
	                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult[0]);
	                        } else {
	                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult);
	                        }
	                    }
	                    if(animatorProps.fb.propType){
	                        if(mult.length) {
	                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult[0]);
	                        } else {
	                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult);
	                        }
	                    }
	                }
	            }
	
	            for(j=0;j<jLen;j+=1){
	                animatorProps = animators[j].a;
	
	                if (animatorProps.p.propType) {
	                    animatorSelector = animators[j].s;
	                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
	                    if(this._hasMaskedPath) {
	                        if(mult.length) {
	                            matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
	                        } else {
	                            matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	                        }
	                    }else{
	                        if(mult.length) {
	                            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
	                        } else {
	                            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
	                        
	                        }
	                    }
	                }
	            }
	            if(documentData.strokeWidthAnim){
	                letterSw = sw < 0 ? 0 : sw;
	            }
	            if(documentData.strokeColorAnim){
	                letterSc = 'rgb('+Math.round(sc[0]*255)+','+Math.round(sc[1]*255)+','+Math.round(sc[2]*255)+')';
	            }
	            if(documentData.fillColorAnim && documentData.fc){
	                letterFc = 'rgb('+Math.round(fc[0]*255)+','+Math.round(fc[1]*255)+','+Math.round(fc[2]*255)+')';
	            }
	
	            if(this._hasMaskedPath) {
	                matrixHelper.translate(0,-documentData.ls);
	
	                matrixHelper.translate(0, alignment[1]*yOff/100 + yPos,0);
	                if (textData.p.p) {
	                    tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
	                    var rot = Math.atan(tanAngle) * 180 / Math.PI;
	                    if (currentPoint.point[0] < prevPoint.point[0]) {
	                        rot += 180;
	                    }
	                    matrixHelper.rotate(-rot * Math.PI / 180);
	                }
	                matrixHelper.translate(xPathPos, yPathPos, 0);
	                currentLength -= alignment[0]*letters[i].an/200;
	                if(letters[i+1] && ind !== letters[i+1].ind){
	                    currentLength += letters[i].an / 2;
	                    currentLength += documentData.tr/1000*documentData.finalSize;
	                }
	            }else{
	
	                matrixHelper.translate(xPos,yPos,0);
	
	                if(documentData.ps){
	                    //matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
	                    matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
	                }
	                switch(documentData.j){
	                    case 1:
	                        matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]),0,0);
	                        break;
	                    case 2:
	                        matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line])/2,0,0);
	                        break;
	                }
	                matrixHelper.translate(0,-documentData.ls);
	                matrixHelper.translate(offf,0,0);
	                matrixHelper.translate(alignment[0]*letters[i].an/200,alignment[1]*yOff/100,0);
	                xPos += letters[i].l + documentData.tr/1000*documentData.finalSize;
	            }
	            if(renderType === 'html'){
	                letterM = matrixHelper.toCSS();
	            }else if(renderType === 'svg'){
	                letterM = matrixHelper.to2dCSS();
	            }else{
	                letterP = [matrixHelper.props[0],matrixHelper.props[1],matrixHelper.props[2],matrixHelper.props[3],matrixHelper.props[4],matrixHelper.props[5],matrixHelper.props[6],matrixHelper.props[7],matrixHelper.props[8],matrixHelper.props[9],matrixHelper.props[10],matrixHelper.props[11],matrixHelper.props[12],matrixHelper.props[13],matrixHelper.props[14],matrixHelper.props[15]];
	            }
	            letterO = elemOpacity;
	        }
	
	        if(renderedLettersCount <= i) {
	            letterValue = new LetterProps(letterO,letterSw,letterSc,letterFc,letterM,letterP);
	            this.renderedLetters.push(letterValue);
	            renderedLettersCount += 1;
	            this.lettersChangedFlag = true;
	        } else {
	            letterValue = this.renderedLetters[i];
	            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
	        }
	    }
	};
	
	TextAnimatorProperty.prototype.getValue = function(){
		if(this._elem.globalData.frameId === this._frameId){
	        return;
	    }
	    this._frameId = this._elem.globalData.frameId;
	    this.iterateDynamicProperties();
	};
	
	TextAnimatorProperty.prototype.mHelper = new Matrix();
	TextAnimatorProperty.prototype.defaultPropsArray = [];
	extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
	function TextAnimatorDataProperty(elem, animatorProps, container) {
		var defaultData = {propType:false};
		var getProp = PropertyFactory.getProp;
		var textAnimator_animatables = animatorProps.a;
		this.a = {
			r: textAnimator_animatables.r ? getProp(elem, textAnimator_animatables.r, 0, degToRads, container) : defaultData,
			rx: textAnimator_animatables.rx ? getProp(elem, textAnimator_animatables.rx, 0, degToRads, container) : defaultData,
			ry: textAnimator_animatables.ry ? getProp(elem, textAnimator_animatables.ry, 0, degToRads, container) : defaultData,
			sk: textAnimator_animatables.sk ? getProp(elem, textAnimator_animatables.sk, 0, degToRads, container) : defaultData,
			sa: textAnimator_animatables.sa ? getProp(elem, textAnimator_animatables.sa, 0, degToRads, container) : defaultData,
			s: textAnimator_animatables.s ? getProp(elem, textAnimator_animatables.s, 1, 0.01, container) : defaultData,
			a: textAnimator_animatables.a ? getProp(elem, textAnimator_animatables.a, 1, 0, container) : defaultData,
			o: textAnimator_animatables.o ? getProp(elem, textAnimator_animatables.o, 0, 0.01, container) : defaultData,
			p: textAnimator_animatables.p ? getProp(elem,textAnimator_animatables.p, 1, 0, container) : defaultData,
			sw: textAnimator_animatables.sw ? getProp(elem, textAnimator_animatables.sw, 0, 0, container) : defaultData,
			sc: textAnimator_animatables.sc ? getProp(elem, textAnimator_animatables.sc, 1, 0, container) : defaultData,
			fc: textAnimator_animatables.fc ? getProp(elem, textAnimator_animatables.fc, 1, 0, container) : defaultData,
			fh: textAnimator_animatables.fh ? getProp(elem, textAnimator_animatables.fh, 0, 0, container) : defaultData,
			fs: textAnimator_animatables.fs ? getProp(elem, textAnimator_animatables.fs, 0, 0.01, container) : defaultData,
			fb: textAnimator_animatables.fb ? getProp(elem, textAnimator_animatables.fb, 0, 0.01, container) : defaultData,
			t: textAnimator_animatables.t ? getProp(elem, textAnimator_animatables.t, 0, 0, container) : defaultData
		};
	
		this.s = TextSelectorProp.getTextSelectorProp(elem,animatorProps.s, container);
	    this.s.t = animatorProps.s.t;
	}
	function LetterProps(o, sw, sc, fc, m, p){
	    this.o = o;
	    this.sw = sw;
	    this.sc = sc;
	    this.fc = fc;
	    this.m = m;
	    this.p = p;
	    this._mdf = {
	    	o: true,
	    	sw: !!sw,
	    	sc: !!sc,
	    	fc: !!fc,
	    	m: true,
	    	p: true
	    };
	}
	
	LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
		this._mdf.o = false;
		this._mdf.sw = false;
		this._mdf.sc = false;
		this._mdf.fc = false;
		this._mdf.m = false;
		this._mdf.p = false;
		var updated = false;
	
		if(this.o !== o) {
			this.o = o;
			this._mdf.o = true;
			updated = true;
		}
		if(this.sw !== sw) {
			this.sw = sw;
			this._mdf.sw = true;
			updated = true;
		}
		if(this.sc !== sc) {
			this.sc = sc;
			this._mdf.sc = true;
			updated = true;
		}
		if(this.fc !== fc) {
			this.fc = fc;
			this._mdf.fc = true;
			updated = true;
		}
		if(this.m !== m) {
			this.m = m;
			this._mdf.m = true;
			updated = true;
		}
		if(p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
			this.p = p;
			this._mdf.p = true;
			updated = true;
		}
		return updated;
	};
	function TextProperty(elem, data){
		this._frameId = initialDefaultFrame;
		this.pv = '';
		this.v = '';
		this.kf = false;
		this._isFirstFrame = true;
		this._mdf = false;
	    this.data = data;
		this.elem = elem;
	    this.comp = this.elem.comp;
		this.keysIndex = 0;
	    this.canResize = false;
	    this.minimumFontSize = 1;
	    this.effectsSequence = [];
		this.currentData = {
			ascent: 0,
	        boxWidth: this.defaultBoxWidth,
	        f: '',
	        fStyle: '',
	        fWeight: '',
	        fc: '',
	        j: '',
	        justifyOffset: '',
	        l: [],
	        lh: 0,
	        lineWidths: [],
	        ls: '',
	        of: '',
	        s: '',
	        sc: '',
	        sw: 0,
	        t: 0,
	        tr: 0,
	        sz:0,
	        ps:null,
	        fillColorAnim: false,
	        strokeColorAnim: false,
	        strokeWidthAnim: false,
	        yOffset: 0,
	        finalSize:0,
	        finalText:[],
	        finalLineHeight: 0,
	        __complete: false
	
		};
	    this.copyData(this.currentData, this.data.d.k[0].s);
	
	    if(!this.searchProperty()) {
	        this.completeTextData(this.currentData);
	    }
	}
	
	TextProperty.prototype.defaultBoxWidth = [0,0];
	
	TextProperty.prototype.copyData = function(obj, data) {
	    for(var s in data) {
	        if(data.hasOwnProperty(s)) {
	            obj[s] = data[s];
	        }
	    }
	    return obj;
	}
	
	TextProperty.prototype.setCurrentData = function(data){
	    if(!data.__complete) {
	        this.completeTextData(data);
	    }
	    this.currentData = data;
	    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
	    this._mdf = true;
	};
	
	TextProperty.prototype.searchProperty = function() {
	    return this.searchKeyframes();
	};
	
	TextProperty.prototype.searchKeyframes = function() {
	    this.kf = this.data.d.k.length > 1;
	    if(this.kf) {
	        this.addEffect(this.getKeyframeValue.bind(this));
	    }
	    return this.kf;
	}
	
	TextProperty.prototype.addEffect = function(effectFunction) {
		this.effectsSequence.push(effectFunction);
	    this.elem.addDynamicProperty(this);
	};
	
	TextProperty.prototype.getValue = function(_finalValue) {
	    if((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
	        return;
	    }
	    this.currentData.t = this.data.d.k[this.keysIndex].s.t;
	    var currentValue = this.currentData;
	    var currentIndex = this.keysIndex;
	    if(this.lock) {
	        this.setCurrentData(this.currentData);
	        return;
	    }
	    this.lock = true;
	    this._mdf = false;
	    var multipliedValue;
	    var i, len = this.effectsSequence.length;
	    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
	    for(i = 0; i < len; i += 1) {
	        //Checking if index changed to prevent creating a new object every time the expression updates.
	        if(currentIndex !== this.keysIndex) {
	            finalValue = this.effectsSequence[i](finalValue, finalValue.t);
	        } else {
	            finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
	        }
	    }
	    if(currentValue !== finalValue) {
	        this.setCurrentData(finalValue);
	    }
	    this.pv = this.v = this.currentData;
	    this.lock = false;
	    this.frameId = this.elem.globalData.frameId;
	}
	
	TextProperty.prototype.getKeyframeValue = function() {
	    var textKeys = this.data.d.k, textDocumentData;
	    var frameNum = this.elem.comp.renderedFrame;
	    var i = 0, len = textKeys.length;
	    while(i <= len - 1) {
	        textDocumentData = textKeys[i].s;
	        if(i === len - 1 || textKeys[i+1].t > frameNum){
	            break;
	        }
	        i += 1;
	    }
	    if(this.keysIndex !== i) {
	        this.keysIndex = i;
	    }
	    return this.data.d.k[this.keysIndex].s;
	};
	
	TextProperty.prototype.buildFinalText = function(text) {
	    var combinedCharacters = FontManager.getCombinedCharacterCodes();
	    var charactersArray = [];
	    var i = 0, len = text.length;
	    while (i < len) {
	        if (combinedCharacters.indexOf(text.charCodeAt(i)) !== -1) {
	            charactersArray[charactersArray.length - 1] += text.charAt(i);
	        } else {
	            charactersArray.push(text.charAt(i));
	        }
	        i += 1;
	    }
	    return charactersArray;
	}
	
	TextProperty.prototype.completeTextData = function(documentData) {
	    documentData.__complete = true;
	    var fontManager = this.elem.globalData.fontManager;
	    var data = this.data;
	    var letters = [];
	    var i, len;
	    var newLineFlag, index = 0, val;
	    var anchorGrouping = data.m.g;
	    var currentSize = 0, currentPos = 0, currentLine = 0, lineWidths = [];
	    var lineWidth = 0;
	    var maxLineWidth = 0;
	    var j, jLen;
	    var fontData = fontManager.getFontByName(documentData.f);
	    var charData, cLength = 0;
	    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];
	
	    var fWeight = 'normal', fStyle = 'normal';
	    len = styles.length;
	    var styleName;
	    for(i=0;i<len;i+=1){
	        styleName = styles[i].toLowerCase();
	        switch(styleName) {
	            case 'italic':
	            fStyle = 'italic';
	            break;
	            case 'bold':
	            fWeight = '700';
	            break;
	            case 'black':
	            fWeight = '900';
	            break;
	            case 'medium':
	            fWeight = '500';
	            break;
	            case 'regular':
	            case 'normal':
	            fWeight = '400';
	            break;
	            case 'light':
	            case 'thin':
	            fWeight = '200';
	            break;
	        }
	    }
	    documentData.fWeight = fontData.fWeight || fWeight;
	    documentData.fStyle = fStyle;
	    documentData.finalSize = documentData.s;
	    documentData.finalText = this.buildFinalText(documentData.t);
	    len = documentData.finalText.length;
	    documentData.finalLineHeight = documentData.lh;
	    var trackingOffset = documentData.tr/1000*documentData.finalSize;
	    var charCode;
	    if(documentData.sz){
	        var flag = true;
	        var boxWidth = documentData.sz[0];
	        var boxHeight = documentData.sz[1];
	        var currentHeight, finalText;
	        while(flag) {
	            finalText = this.buildFinalText(documentData.t);
	            currentHeight = 0;
	            lineWidth = 0;
	            len = finalText.length;
	            trackingOffset = documentData.tr/1000*documentData.finalSize;
	            var lastSpaceIndex = -1;
	            for(i=0;i<len;i+=1){
	                charCode = finalText[i].charCodeAt(0);
	                newLineFlag = false;
	                if(finalText[i] === ' '){
	                    lastSpaceIndex = i;
	                }else if(charCode === 13 || charCode === 3){
	                    lineWidth = 0;
	                    newLineFlag = true;
	                    currentHeight += documentData.finalLineHeight || documentData.finalSize*1.2;
	                }
	                if(fontManager.chars){
	                    charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
	                    cLength = newLineFlag ? 0 : charData.w*documentData.finalSize/100;
	                }else{
	                    //tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
	                    cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
	                }
	                if(lineWidth + cLength > boxWidth && finalText[i] !== ' '){
	                    if(lastSpaceIndex === -1){
	                        len += 1;
	                    } else {
	                        i = lastSpaceIndex;
	                    }
	                    currentHeight += documentData.finalLineHeight || documentData.finalSize*1.2;
	                    finalText.splice(i, lastSpaceIndex === i ? 1 : 0,"\r");
	                    //finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
	                    lastSpaceIndex = -1;
	                    lineWidth = 0;
	                }else {
	                    lineWidth += cLength;
	                    lineWidth += trackingOffset;
	                }
	            }
	            currentHeight += fontData.ascent*documentData.finalSize/100;
	            if(this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
	                documentData.finalSize -= 1;
	                documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
	            } else {
	                documentData.finalText = finalText;
	                len = documentData.finalText.length;
	                flag = false;
	            }
	        }
	
	    }
	    lineWidth = - trackingOffset;
	    cLength = 0;
	    var uncollapsedSpaces = 0;
	    var currentChar;
	    for (i = 0;i < len ;i += 1) {
	        newLineFlag = false;
	        currentChar = documentData.finalText[i];
	        charCode = currentChar.charCodeAt(0);
	        if (currentChar === ' '){
	            val = '\u00A0';
	        } else if (charCode === 13 || charCode === 3) {
	            uncollapsedSpaces = 0;
	            lineWidths.push(lineWidth);
	            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	            lineWidth = - 2 * trackingOffset;
	            val = '';
	            newLineFlag = true;
	            currentLine += 1;
	        }else{
	            val = documentData.finalText[i];
	        }
	        if(fontManager.chars){
	            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
	            cLength = newLineFlag ? 0 : charData.w*documentData.finalSize/100;
	        }else{
	            //var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
	            //tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
	            cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
	        }
	
	        //
	        if(currentChar === ' '){
	            uncollapsedSpaces += cLength + trackingOffset;
	        } else {
	            lineWidth += cLength + trackingOffset + uncollapsedSpaces;
	            uncollapsedSpaces = 0;
	        }
	        letters.push({l:cLength,an:cLength,add:currentSize,n:newLineFlag, anIndexes:[], val: val, line: currentLine, animatorJustifyOffset: 0});
	        if(anchorGrouping == 2){
	            currentSize += cLength;
	            if(val === '' || val === '\u00A0' || i === len - 1){
	                if(val === '' || val === '\u00A0'){
	                    currentSize -= cLength;
	                }
	                while(currentPos<=i){
	                    letters[currentPos].an = currentSize;
	                    letters[currentPos].ind = index;
	                    letters[currentPos].extra = cLength;
	                    currentPos += 1;
	                }
	                index += 1;
	                currentSize = 0;
	            }
	        }else if(anchorGrouping == 3){
	            currentSize += cLength;
	            if(val === '' || i === len - 1){
	                if(val === ''){
	                    currentSize -= cLength;
	                }
	                while(currentPos<=i){
	                    letters[currentPos].an = currentSize;
	                    letters[currentPos].ind = index;
	                    letters[currentPos].extra = cLength;
	                    currentPos += 1;
	                }
	                currentSize = 0;
	                index += 1;
	            }
	        }else{
	            letters[index].ind = index;
	            letters[index].extra = 0;
	            index += 1;
	        }
	    }
	    documentData.l = letters;
	    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
	    lineWidths.push(lineWidth);
	    if(documentData.sz){
	        documentData.boxWidth = documentData.sz[0];
	        documentData.justifyOffset = 0;
	    }else{
	        documentData.boxWidth = maxLineWidth;
	        switch(documentData.j){
	            case 1:
	                documentData.justifyOffset = - documentData.boxWidth;
	                break;
	            case 2:
	                documentData.justifyOffset = - documentData.boxWidth/2;
	                break;
	            default:
	                documentData.justifyOffset = 0;
	        }
	    }
	    documentData.lineWidths = lineWidths;
	
	    var animators = data.a, animatorData, letterData;
	    jLen = animators.length;
	    var based, ind, indexes = [];
	    for(j=0;j<jLen;j+=1){
	        animatorData = animators[j];
	        if(animatorData.a.sc){
	            documentData.strokeColorAnim = true;
	        }
	        if(animatorData.a.sw){
	            documentData.strokeWidthAnim = true;
	        }
	        if(animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb){
	            documentData.fillColorAnim = true;
	        }
	        ind = 0;
	        based = animatorData.s.b;
	        for(i=0;i<len;i+=1){
	            letterData = letters[i];
	            letterData.anIndexes[j] = ind;
	            if((based == 1 && letterData.val !== '') || (based == 2 && letterData.val !== '' && letterData.val !== '\u00A0') || (based == 3 && (letterData.n || letterData.val == '\u00A0' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))){
	                if(animatorData.s.rn === 1){
	                    indexes.push(ind);
	                }
	                ind += 1;
	            }
	        }
	        data.a[j].s.totalChars = ind;
	        var currentInd = -1, newInd;
	        if(animatorData.s.rn === 1){
	            for(i = 0; i < len; i += 1){
	                letterData = letters[i];
	                if(currentInd != letterData.anIndexes[j]){
	                    currentInd = letterData.anIndexes[j];
	                    newInd = indexes.splice(Math.floor(Math.random()*indexes.length),1)[0];
	                }
	                letterData.anIndexes[j] = newInd;
	            }
	        }
	    }
	    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize*1.2;
	    documentData.ls = documentData.ls || 0;
	    documentData.ascent = fontData.ascent*documentData.finalSize/100;
	};
	
	TextProperty.prototype.updateDocumentData = function(newData, index) {
		index = index === undefined ? this.keysIndex : index;
	    var dData = this.copyData({}, this.data.d.k[index].s);
	    dData = this.copyData(dData, newData);
	    this.data.d.k[index].s = dData;
	    this.recalculate(index);
	    this.elem.addDynamicProperty(this);
	};
	
	TextProperty.prototype.recalculate = function(index) {
	    var dData = this.data.d.k[index].s;
	    dData.__complete = false;
	    this.keysIndex = 0;
	    this._isFirstFrame = true;
	    this.getValue(dData);
	}
	
	TextProperty.prototype.canResizeFont = function(_canResize) {
	    this.canResize = _canResize;
	    this.recalculate(this.keysIndex);
	    this.elem.addDynamicProperty(this);
	};
	
	TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
	    this.minimumFontSize = Math.floor(_fontValue) || 1;
	    this.recalculate(this.keysIndex);
	    this.elem.addDynamicProperty(this);
	};
	
	var TextSelectorProp = (function(){
	    var max = Math.max;
	    var min = Math.min;
	    var floor = Math.floor;
	
	    function TextSelectorProp(elem,data){
	        this._currentTextLength = -1;
	        this.k = false;
	        this.data = data;
	        this.elem = elem;
	        this.comp = elem.comp;
	        this.finalS = 0;
	        this.finalE = 0;
	        this.initDynamicPropertyContainer(elem);
	        this.s = PropertyFactory.getProp(elem,data.s || {k:0},0,0,this);
	        if('e' in data){
	            this.e = PropertyFactory.getProp(elem,data.e,0,0,this);
	        }else{
	            this.e = {v:100};
	        }
	        this.o = PropertyFactory.getProp(elem,data.o || {k:0},0,0,this);
	        this.xe = PropertyFactory.getProp(elem,data.xe || {k:0},0,0,this);
	        this.ne = PropertyFactory.getProp(elem,data.ne || {k:0},0,0,this);
	        this.a = PropertyFactory.getProp(elem,data.a,0,0.01,this);
	        if(!this.dynamicProperties.length){
	            this.getValue();
	        }
	    }
	
	    TextSelectorProp.prototype = {
	        getMult: function(ind) {
	            if(this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
	                this.getValue();
	            }
	            //var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
	            var easer = BezierFactory.getBezierEasing(this.ne.v/100,0,1-this.xe.v/100,1).get;
	            var mult = 0;
	            var s = this.finalS;
	            var e = this.finalE;
	            var type = this.data.sh;
	            if(type == 2){
	                if(e === s){
	                    mult = ind >= e ? 1 : 0;
	                }else{
	                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                }
	                mult = easer(mult);
	            }else if(type == 3){
	                if(e === s){
	                    mult = ind >= e ? 0 : 1;
	                }else{
	                    mult = 1 - max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                }
	
	                mult = easer(mult);
	            }else if(type == 4){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));
	                    if(mult<0.5){
	                        mult *= 2;
	                    }else{
	                        mult = 1 - 2*(mult-0.5);
	                    }
	                }
	                mult = easer(mult);
	            }else if(type == 5){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    var tot = e - s;
	                    /*ind += 0.5;
	                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind;*/
	                    ind = min(max(0,ind+0.5-s),e-s);
	                    var x = -tot/2+ind;
	                    var a = tot/2;
	                    mult = Math.sqrt(1 - (x*x)/(a*a));
	                }
	                mult = easer(mult);
	            }else if(type == 6){
	                if(e === s){
	                    mult = 0;
	                }else{
	                    ind = min(max(0,ind+0.5-s),e-s);
	                    mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind)/(e-s)))))/2;
	                    /*
	                     ind = Math.min(Math.max(s,ind),e-1);
	                     mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind-s)/(e-1-s)))))/2;
	                     mult = Math.max(mult,(1/(e-1-s))/(e-1-s));*/
	                }
	                mult = easer(mult);
	            }else {
	                if(ind >= floor(s)){
	                    if(ind-s < 0){
	                        mult = 1 - (s - ind);
	                    }else{
	                        mult = max(0,min(e-ind,1));
	                    }
	                }
	                mult = easer(mult);
	            }
	            return mult*this.a.v;
	        },
	        getValue: function(newCharsFlag) {
	            this.iterateDynamicProperties();
	            this._mdf = newCharsFlag || this._mdf;
	            this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
	            if(newCharsFlag && this.data.r === 2) {
	                this.e.v = this._currentTextLength;
	            }
	            var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
	            var o = this.o.v/divisor;
	            var s = this.s.v/divisor + o;
	            var e = (this.e.v/divisor) + o;
	            if(s>e){
	                var _s = s;
	                s = e;
	                e = _s;
	            }
	            this.finalS = s;
	            this.finalE = e;
	        }
	    }
	    extendPrototype([DynamicPropertyContainer], TextSelectorProp);
	
	    function getTextSelectorProp(elem, data,arr) {
	        return new TextSelectorProp(elem, data, arr);
	    }
	
	    return {
	        getTextSelectorProp: getTextSelectorProp
	    };
	}());
	
	    
	var pool_factory = (function() {
		return function(initialLength, _create, _release, _clone) {
	
			var _length = 0;
			var _maxLength = initialLength;
			var pool = createSizedArray(_maxLength);
	
			var ob = {
				newElement: newElement,
				release: release
			};
	
			function newElement(){
				var element;
				if(_length){
					_length -= 1;
					element = pool[_length];
				} else {
					element = _create();
				}
				return element;
			}
	
			function release(element) {
				if(_length === _maxLength) {
					pool = pooling.double(pool);
					_maxLength = _maxLength*2;
				}
				if (_release) {
					_release(element);
				}
				pool[_length] = element;
				_length += 1;
			}
	
			function clone() {
				var clonedElement = newElement();
				return _clone(clonedElement);
			}
	
			return ob;
		};
	}());
	
	var pooling = (function(){
	
		function double(arr){
			return arr.concat(createSizedArray(arr.length));
		}
	
		return {
			double: double
		};
	}());
	var point_pool = (function(){
	
		function create() {
			return createTypedArray('float32', 2);
		}
		return pool_factory(8, create);
	}());
	var shape_pool = (function(){
	
		function create() {
			return new ShapePath();
		}
	
		function release(shapePath) {
			var len = shapePath._length, i;
			for(i = 0; i < len; i += 1) {
				point_pool.release(shapePath.v[i]);
				point_pool.release(shapePath.i[i]);
				point_pool.release(shapePath.o[i]);
				shapePath.v[i] = null;
				shapePath.i[i] = null;
				shapePath.o[i] = null;
			}
			shapePath._length = 0;
			shapePath.c = false;
		}
	
		function clone(shape) {
			var cloned = factory.newElement();
			var i, len = shape._length === undefined ? shape.v.length : shape._length;
			cloned.setLength(len);
			cloned.c = shape.c;
			var pt;
			
			for(i = 0; i < len; i += 1) {
				cloned.setTripleAt(shape.v[i][0],shape.v[i][1],shape.o[i][0],shape.o[i][1],shape.i[i][0],shape.i[i][1], i);
			}
			return cloned;
		}
	
		var factory = pool_factory(4, create, release);
		factory.clone = clone;
	
		return factory;
	}());
	var shapeCollection_pool = (function(){
		var ob = {
			newShapeCollection: newShapeCollection,
			release: release
		};
	
		var _length = 0;
		var _maxLength = 4;
		var pool = createSizedArray(_maxLength);
	
		function newShapeCollection(){
			var shapeCollection;
			if(_length){
				_length -= 1;
				shapeCollection = pool[_length];
			} else {
				shapeCollection = new ShapeCollection();
			}
			return shapeCollection;
		}
	
		function release(shapeCollection) {
			var i, len = shapeCollection._length;
			for(i = 0; i < len; i += 1) {
				shape_pool.release(shapeCollection.shapes[i]);
			}
			shapeCollection._length = 0;
	
			if(_length === _maxLength) {
				pool = pooling.double(pool);
				_maxLength = _maxLength*2;
			}
			pool[_length] = shapeCollection;
			_length += 1;
		}
	
		return ob;
	}());
	var segments_length_pool = (function(){
	
		function create() {
			return {
				lengths: [],
				totalLength: 0
			};
		}
	
		function release(element) {
			var i, len = element.lengths.length;
			for(i=0;i<len;i+=1) {
				bezier_length_pool.release(element.lengths[i]);
			}
			element.lengths.length = 0;
		}
	
		return pool_factory(8, create, release);
	}());
	var bezier_length_pool = (function(){
	
		function create() {
			return {
	            addedLength: 0,
	            percents: createTypedArray('float32', defaultCurveSegments),
	            lengths: createTypedArray('float32', defaultCurveSegments),
	        };
		}
		return pool_factory(8, create);
	}());
	function BaseRenderer(){}
	BaseRenderer.prototype.checkLayers = function(num){
	    var i, len = this.layers.length, data;
	    this.completeLayers = true;
	    for (i = len - 1; i >= 0; i--) {
	        if (!this.elements[i]) {
	            data = this.layers[i];
	            if(data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st))
	            {
	                this.buildItem(i);
	            }
	        }
	        this.completeLayers = this.elements[i] ? this.completeLayers:false;
	    }
	    this.checkPendingElements();
	};
	
	BaseRenderer.prototype.createItem = function(layer){
	    switch(layer.ty){
	        case 2:
	            return this.createImage(layer);
	        case 0:
	            return this.createComp(layer);
	        case 1:
	            return this.createSolid(layer);
	        case 3:
	            return this.createNull(layer);
	        case 4:
	            return this.createShape(layer);
	        case 5:
	            return this.createText(layer);
	        case 13:
	            return this.createCamera(layer);
	    }
	    return this.createNull(layer);
	};
	
	BaseRenderer.prototype.createCamera = function(){
	    throw new Error('You\'re using a 3d camera. Try the html renderer.');
	};
	
	BaseRenderer.prototype.buildAllItems = function(){
	    var i, len = this.layers.length;
	    for(i=0;i<len;i+=1){
	        this.buildItem(i);
	    }
	    this.checkPendingElements();
	};
	
	BaseRenderer.prototype.includeLayers = function(newLayers){
	    this.completeLayers = false;
	    var i, len = newLayers.length;
	    var j, jLen = this.layers.length;
	    for(i=0;i<len;i+=1){
	        j = 0;
	        while(j<jLen){
	            if(this.layers[j].id == newLayers[i].id){
	                this.layers[j] = newLayers[i];
	                break;
	            }
	            j += 1;
	        }
	    }
	};
	
	BaseRenderer.prototype.setProjectInterface = function(pInterface){
	    this.globalData.projectInterface = pInterface;
	};
	
	BaseRenderer.prototype.initItems = function(){
	    if(!this.globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	};
	BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
	    var elements = this.elements;
	    var layers = this.layers;
	    var i=0, len = layers.length;
	    while (i < len) {
	        if (layers[i].ind == parentName) {
	            if (!elements[i] || elements[i] === true) {
	                this.buildItem(i);
	                this.addPendingElement(element);
	            } else {
	                hierarchy.push(elements[i]);
	                elements[i].setAsParent();
	                if(layers[i].parent !== undefined) {
	                    this.buildElementParenting(element, layers[i].parent, hierarchy);
	                } else {
	                    element.setHierarchy(hierarchy);
	                }
	            }
	        }
	        i += 1;
	    }
	};
	
	BaseRenderer.prototype.addPendingElement = function(element){
	    this.pendingElements.push(element);
	};
	
	BaseRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i]);
	            comp.initExpressions();
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};
	
	BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
	    this.globalData.fontManager = new FontManager();
	    this.globalData.fontManager.addChars(animData.chars);
	    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
	    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
	    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
	    this.globalData.imageLoader = this.animationItem.imagePreloader;
	    this.globalData.frameId = 0;
	    this.globalData.frameRate = animData.fr;
	    this.globalData.nm = animData.nm;
	    this.globalData.compSize = {
	        w: animData.w,
	        h: animData.h
	    }
	}
	function SVGRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.layers = null;
	    this.renderedFrame = -1;
	    this.svgElement = createNS('svg');
	    var ariaLabel = '';
	    if (config && config.title) {
	        var titleElement = createNS('title');
	        var titleId = createElementID();
	        titleElement.setAttribute('id', titleId);
	        titleElement.textContent = config.title;
	        this.svgElement.appendChild(titleElement);
	        ariaLabel += titleId;
	    }
	    if (config && config.description) {
	        var descElement = createNS('desc');
	        var descId = createElementID();
	        descElement.setAttribute('id', descId);
	        descElement.textContent = config.description;
	        this.svgElement.appendChild(descElement);
	        ariaLabel += ' ' + descId;
	    }
	    if (ariaLabel) {
	        this.svgElement.setAttribute('aria-labelledby', ariaLabel)
	    }
	    var defs = createNS( 'defs');
	    this.svgElement.appendChild(defs);
	    var maskElement = createNS('g');
	    this.svgElement.appendChild(maskElement);
	    this.layerElement = maskElement;
	    this.renderConfig = {
	        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
	        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
	        progressiveLoad: (config && config.progressiveLoad) || false,
	        hideOnTransparent: (config && config.hideOnTransparent === false) ? false : true,
	        viewBoxOnly: (config && config.viewBoxOnly) || false,
	        viewBoxSize: (config && config.viewBoxSize) || false,
	        className: (config && config.className) || ''
	    };
	
	    this.globalData = {
	        _mdf: false,
	        frameNum: -1,
	        defs: defs,
	        renderConfig: this.renderConfig
	    };
	    this.elements = [];
	    this.pendingElements = [];
	    this.destroyed = false;
	    this.rendererType = 'svg';
	
	}
	
	extendPrototype([BaseRenderer],SVGRenderer);
	
	SVGRenderer.prototype.createNull = function (data) {
	    return new NullElement(data,this.globalData,this);
	};
	
	SVGRenderer.prototype.createShape = function (data) {
	    return new SVGShapeElement(data,this.globalData,this);
	};
	
	SVGRenderer.prototype.createText = function (data) {
	    return new SVGTextElement(data,this.globalData,this);
	
	};
	
	SVGRenderer.prototype.createImage = function (data) {
	    return new IImageElement(data,this.globalData,this);
	};
	
	SVGRenderer.prototype.createComp = function (data) {
	    return new SVGCompElement(data,this.globalData,this);
	
	};
	
	SVGRenderer.prototype.createSolid = function (data) {
	    return new ISolidElement(data,this.globalData,this);
	};
	
	SVGRenderer.prototype.configAnimation = function(animData){
	    this.svgElement.setAttribute('xmlns','http://www.w3.org/2000/svg');
	    if(this.renderConfig.viewBoxSize) {
	        this.svgElement.setAttribute('viewBox',this.renderConfig.viewBoxSize);
	    } else {
	        this.svgElement.setAttribute('viewBox','0 0 '+animData.w+' '+animData.h);
	    }
	
	    if(!this.renderConfig.viewBoxOnly) {
	        this.svgElement.setAttribute('width',animData.w);
	        this.svgElement.setAttribute('height',animData.h);
	        this.svgElement.style.width = '100%';
	        this.svgElement.style.height = '100%';
	        this.svgElement.style.transform = 'translate3d(0,0,0)';
	    }
	    if(this.renderConfig.className) {
	        this.svgElement.setAttribute('class', this.renderConfig.className);
	    }
	    this.svgElement.setAttribute('preserveAspectRatio',this.renderConfig.preserveAspectRatio);
	    //this.layerElement.style.transform = 'translate3d(0,0,0)';
	    //this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
	    this.animationItem.wrapper.appendChild(this.svgElement);
	    //Mask animation
	    var defs = this.globalData.defs;
	
	    this.setupGlobalData(animData, defs);
	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	    this.data = animData;
	
	    var maskElement = createNS( 'clipPath');
	    var rect = createNS('rect');
	    rect.setAttribute('width',animData.w);
	    rect.setAttribute('height',animData.h);
	    rect.setAttribute('x',0);
	    rect.setAttribute('y',0);
	    var maskId = createElementID();
	    maskElement.setAttribute('id', maskId);
	    maskElement.appendChild(rect);
	    this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#"+maskId+")");
	
	    defs.appendChild(maskElement);
	    this.layers = animData.layers;
	    this.elements = createSizedArray(animData.layers.length);
	};
	
	
	SVGRenderer.prototype.destroy = function () {
	    this.animationItem.wrapper.innerHTML = '';
	    this.layerElement = null;
	    this.globalData.defs = null;
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = 0; i < len; i++) {
	        if(this.elements[i]){
	            this.elements[i].destroy();
	        }
	    }
	    this.elements.length = 0;
	    this.destroyed = true;
	    this.animationItem = null;
	};
	
	SVGRenderer.prototype.updateContainerSize = function () {
	};
	
	SVGRenderer.prototype.buildItem  = function(pos){
	    var elements = this.elements;
	    if(elements[pos] || this.layers[pos].ty == 99){
	        return;
	    }
	    elements[pos] = true;
	    var element = this.createItem(this.layers[pos]);
	
	    elements[pos] = element;
	    if(expressionsPlugin){
	        if(this.layers[pos].ty === 0){
	            this.globalData.projectInterface.registerComposition(element);
	        }
	        element.initExpressions();
	    }
	    this.appendElementInPos(element,pos);
	    if(this.layers[pos].tt){
	        if(!this.elements[pos - 1] || this.elements[pos - 1] === true){
	            this.buildItem(pos - 1);
	            this.addPendingElement(element);
	        } else {
	            element.setMatte(elements[pos - 1].layerId);
	        }
	    }
	};
	
	SVGRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	        if(element.data.tt){
	            var i = 0, len = this.elements.length;
	            while(i<len){
	                if(this.elements[i] === element){
	                    element.setMatte(this.elements[i - 1].layerId);
	                    break;
	                }
	                i += 1;
	            }
	        }
	    }
	};
	
	SVGRenderer.prototype.renderFrame = function(num){
	    if(this.renderedFrame === num || this.destroyed){
	        return;
	    }
	    if(num === null){
	        num = this.renderedFrame;
	    }else{
	        this.renderedFrame = num;
	    }
	    // console.log('-------');
	    // console.log('FRAME ',num);
	    this.globalData.frameNum = num;
	    this.globalData.frameId += 1;
	    this.globalData.projectInterface.currentFrame = num;
	    this.globalData._mdf = false;
	    var i, len = this.layers.length;
	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }
	    for (i = len - 1; i >= 0; i--) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(num - this.layers[i].st);
	        }
	    }
	    if(this.globalData._mdf) {
	        for (i = 0; i < len; i += 1) {
	            if(this.completeLayers || this.elements[i]){
	                this.elements[i].renderFrame();
	            }
	        }
	    }
	};
	
	SVGRenderer.prototype.appendElementInPos = function(element, pos){
	    var newElement = element.getBaseElement();
	    if(!newElement){
	        return;
	    }
	    var i = 0;
	    var nextElement;
	    while(i<pos){
	        if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement()){
	            nextElement = this.elements[i].getBaseElement();
	        }
	        i += 1;
	    }
	    if(nextElement){
	        this.layerElement.insertBefore(newElement, nextElement);
	    } else {
	        this.layerElement.appendChild(newElement);
	    }
	};
	
	SVGRenderer.prototype.hide = function(){
	    this.layerElement.style.display = 'none';
	};
	
	SVGRenderer.prototype.show = function(){
	    this.layerElement.style.display = 'block';
	};
	
	function CanvasRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.renderConfig = {
	        clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
	        context: (config && config.context) || null,
	        progressiveLoad: (config && config.progressiveLoad) || false,
	        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
	        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
	        className: (config && config.className) || ''
	    };
	    this.renderConfig.dpr = (config && config.dpr) || 1;
	    if (this.animationItem.wrapper) {
	        this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
	    }
	    this.renderedFrame = -1;
	    this.globalData = {
	        frameNum: -1,
	        _mdf: false,
	        renderConfig: this.renderConfig,
	        currentGlobalAlpha: -1
	    };
	    this.contextData = new CVContextData();
	    this.elements = [];
	    this.pendingElements = [];
	    this.transformMat = new Matrix();
	    this.completeLayers = false;
	    this.rendererType = 'canvas';
	}
	extendPrototype([BaseRenderer],CanvasRenderer);
	
	CanvasRenderer.prototype.createShape = function (data) {
	    return new CVShapeElement(data, this.globalData, this);
	};
	
	CanvasRenderer.prototype.createText = function (data) {
	    return new CVTextElement(data, this.globalData, this);
	};
	
	CanvasRenderer.prototype.createImage = function (data) {
	    return new CVImageElement(data, this.globalData, this);
	};
	
	CanvasRenderer.prototype.createComp = function (data) {
	    return new CVCompElement(data, this.globalData, this);
	};
	
	CanvasRenderer.prototype.createSolid = function (data) {
	    return new CVSolidElement(data, this.globalData, this);
	};
	
	CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;
	
	CanvasRenderer.prototype.ctxTransform = function(props){
	    if(props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0){
	        return;
	    }
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.transform(props[0],props[1],props[4],props[5],props[12],props[13]);
	        return;
	    }
	    this.transformMat.cloneFromProps(props);
	    var cProps = this.contextData.cTr.props;
	    this.transformMat.transform(cProps[0],cProps[1],cProps[2],cProps[3],cProps[4],cProps[5],cProps[6],cProps[7],cProps[8],cProps[9],cProps[10],cProps[11],cProps[12],cProps[13],cProps[14],cProps[15]);
	    //this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
	    this.contextData.cTr.cloneFromProps(this.transformMat.props);
	    var trProps = this.contextData.cTr.props;
	    this.canvasContext.setTransform(trProps[0],trProps[1],trProps[4],trProps[5],trProps[12],trProps[13]);
	};
	
	CanvasRenderer.prototype.ctxOpacity = function(op){
	    /*if(op === 1){
	        return;
	    }*/
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
	        this.globalData.currentGlobalAlpha = this.contextData.cO;
	        return;
	    }
	    this.contextData.cO *= op < 0 ? 0 : op;
	    if(this.globalData.currentGlobalAlpha !== this.contextData.cO) {
	        this.canvasContext.globalAlpha = this.contextData.cO;
	        this.globalData.currentGlobalAlpha = this.contextData.cO;
	    }
	};
	
	CanvasRenderer.prototype.reset = function(){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.restore();
	        return;
	    }
	    this.contextData.reset();
	};
	
	CanvasRenderer.prototype.save = function(actionFlag){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.save();
	        return;
	    }
	    if(actionFlag){
	        this.canvasContext.save();
	    }
	    var props = this.contextData.cTr.props;
	    if(this.contextData._length <= this.contextData.cArrPos) {
	        this.contextData.duplicate();
	    }
	    var i, arr = this.contextData.saved[this.contextData.cArrPos];
	    for (i = 0; i < 16; i += 1) {
	        arr[i] = props[i];
	    }
	    this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
	    this.contextData.cArrPos += 1;
	};
	
	CanvasRenderer.prototype.restore = function(actionFlag){
	    if(!this.renderConfig.clearCanvas){
	        this.canvasContext.restore();
	        return;
	    }
	    if(actionFlag){
	        this.canvasContext.restore();
	        this.globalData.blendMode = 'source-over';
	    }
	    this.contextData.cArrPos -= 1;
	    var popped = this.contextData.saved[this.contextData.cArrPos];
	    var i,arr = this.contextData.cTr.props;
	    for(i=0;i<16;i+=1){
	        arr[i] = popped[i];
	    }
	    this.canvasContext.setTransform(popped[0],popped[1],popped[4],popped[5],popped[12],popped[13]);
	    popped = this.contextData.savedOp[this.contextData.cArrPos];
	    this.contextData.cO = popped;
	    if(this.globalData.currentGlobalAlpha !== popped) {
	        this.canvasContext.globalAlpha = popped;
	        this.globalData.currentGlobalAlpha = popped;
	    }
	};
	
	CanvasRenderer.prototype.configAnimation = function(animData){
	    if(this.animationItem.wrapper){
	        this.animationItem.container = createTag('canvas');
	        this.animationItem.container.style.width = '100%';
	        this.animationItem.container.style.height = '100%';
	        //this.animationItem.container.style.transform = 'translate3d(0,0,0)';
	        //this.animationItem.container.style.webkitTransform = 'translate3d(0,0,0)';
	        this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style['-webkit-transform'] = "0px 0px 0px";
	        this.animationItem.wrapper.appendChild(this.animationItem.container);
	        this.canvasContext = this.animationItem.container.getContext('2d');
	        if(this.renderConfig.className) {
	            this.animationItem.container.setAttribute('class', this.renderConfig.className);
	        }
	    }else{
	        this.canvasContext = this.renderConfig.context;
	    }
	    this.data = animData;
	    this.layers = animData.layers;
	    this.transformCanvas = {
	        w: animData.w,
	        h:animData.h,
	        sx:0,
	        sy:0,
	        tx:0,
	        ty:0
	    };
	    this.setupGlobalData(animData, document.body);
	    this.globalData.canvasContext = this.canvasContext;
	    this.globalData.renderer = this;
	    this.globalData.isDashed = false;
	    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
	    this.globalData.transformCanvas = this.transformCanvas;
	    this.elements = createSizedArray(animData.layers.length);
	
	    this.updateContainerSize();
	};
	
	CanvasRenderer.prototype.updateContainerSize = function () {
	    this.reset();
	    var elementWidth,elementHeight;
	    if(this.animationItem.wrapper && this.animationItem.container){
	        elementWidth = this.animationItem.wrapper.offsetWidth;
	        elementHeight = this.animationItem.wrapper.offsetHeight;
	        this.animationItem.container.setAttribute('width',elementWidth * this.renderConfig.dpr );
	        this.animationItem.container.setAttribute('height',elementHeight * this.renderConfig.dpr);
	    }else{
	        elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
	        elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
	    }
	    var elementRel,animationRel;
	    if(this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1){
	        var par = this.renderConfig.preserveAspectRatio.split(' ');
	        var fillType = par[1] || 'meet';
	        var pos = par[0] || 'xMidYMid';
	        var xPos = pos.substr(0,4);
	        var yPos = pos.substr(4);
	        elementRel = elementWidth/elementHeight;
	        animationRel = this.transformCanvas.w/this.transformCanvas.h;
	        if(animationRel>elementRel && fillType === 'meet' || animationRel<elementRel && fillType === 'slice'){
	            this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	            this.transformCanvas.sy = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	        }else{
	            this.transformCanvas.sx = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
	            this.transformCanvas.sy = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
	        }
	
	        if(xPos === 'xMid' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
	            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))/2*this.renderConfig.dpr;
	        } else if(xPos === 'xMax' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
	            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))*this.renderConfig.dpr;
	        } else {
	            this.transformCanvas.tx = 0;
	        }
	        if(yPos === 'YMid' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
	            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w))/2)*this.renderConfig.dpr;
	        } else if(yPos === 'YMax' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
	            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w)))*this.renderConfig.dpr;
	        } else {
	            this.transformCanvas.ty = 0;
	        }
	
	    }else if(this.renderConfig.preserveAspectRatio == 'none'){
	        this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
	        this.transformCanvas.sy = elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);
	        this.transformCanvas.tx = 0;
	        this.transformCanvas.ty = 0;
	    }else{
	        this.transformCanvas.sx = this.renderConfig.dpr;
	        this.transformCanvas.sy = this.renderConfig.dpr;
	        this.transformCanvas.tx = 0;
	        this.transformCanvas.ty = 0;
	    }
	    this.transformCanvas.props = [this.transformCanvas.sx,0,0,0,0,this.transformCanvas.sy,0,0,0,0,1,0,this.transformCanvas.tx,this.transformCanvas.ty,0,1];
	    /*var i, len = this.elements.length;
	    for(i=0;i<len;i+=1){
	        if(this.elements[i] && this.elements[i].data.ty === 0){
	            this.elements[i].resize(this.globalData.transformCanvas);
	        }
	    }*/
	    this.ctxTransform(this.transformCanvas.props);
	    this.canvasContext.beginPath();
	    this.canvasContext.rect(0,0,this.transformCanvas.w,this.transformCanvas.h);
	    this.canvasContext.closePath();
	    this.canvasContext.clip();
	
	    this.renderFrame(this.renderedFrame, true);
	};
	
	CanvasRenderer.prototype.destroy = function () {
	    if(this.renderConfig.clearCanvas) {
	        this.animationItem.wrapper.innerHTML = '';
	    }
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = len - 1; i >= 0; i-=1) {
	        if(this.elements[i]) {
	            this.elements[i].destroy();
	        }
	    }
	    this.elements.length = 0;
	    this.globalData.canvasContext = null;
	    this.animationItem.container = null;
	    this.destroyed = true;
	};
	
	CanvasRenderer.prototype.renderFrame = function(num, forceRender){
	    if((this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender) || this.destroyed || num === -1){
	        return;
	    }
	    this.renderedFrame = num;
	    this.globalData.frameNum = num - this.animationItem._isFirstFrame;
	    this.globalData.frameId += 1;
	    this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
	    this.globalData.projectInterface.currentFrame = num;
	
	     // console.log('--------');
	     // console.log('NEW: ',num);
	    var i, len = this.layers.length;
	    if(!this.completeLayers){
	        this.checkLayers(num);
	    }
	
	    for (i = 0; i < len; i++) {
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(num - this.layers[i].st);
	        }
	    }
	    if(this.globalData._mdf) {
	        if(this.renderConfig.clearCanvas === true){
	            this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
	        }else{
	            this.save();
	        }
	        for (i = len - 1; i >= 0; i-=1) {
	            if(this.completeLayers || this.elements[i]){
	                this.elements[i].renderFrame();
	            }
	        }
	        if(this.renderConfig.clearCanvas !== true){
	            this.restore();
	        }
	    }
	};
	
	CanvasRenderer.prototype.buildItem = function(pos){
	    var elements = this.elements;
	    if(elements[pos] || this.layers[pos].ty == 99){
	        return;
	    }
	    var element = this.createItem(this.layers[pos], this,this.globalData);
	    elements[pos] = element;
	    element.initExpressions();
	    /*if(this.layers[pos].ty === 0){
	        element.resize(this.globalData.transformCanvas);
	    }*/
	};
	
	CanvasRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	    }
	};
	
	CanvasRenderer.prototype.hide = function(){
	    this.animationItem.container.style.display = 'none';
	};
	
	CanvasRenderer.prototype.show = function(){
	    this.animationItem.container.style.display = 'block';
	};
	
	function HybridRenderer(animationItem, config){
	    this.animationItem = animationItem;
	    this.layers = null;
	    this.renderedFrame = -1;
	    this.renderConfig = {
	        className: (config && config.className) || '',
	        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
	        hideOnTransparent: (config && config.hideOnTransparent === false) ? false : true
	    };
	    this.globalData = {
	        _mdf: false,
	        frameNum: -1,
	        renderConfig: this.renderConfig
	    };
	    this.pendingElements = [];
	    this.elements = [];
	    this.threeDElements = [];
	    this.destroyed = false;
	    this.camera = null;
	    this.supports3d = true;
	    this.rendererType = 'html';
	
	}
	
	extendPrototype([BaseRenderer],HybridRenderer);
	
	HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;
	
	HybridRenderer.prototype.checkPendingElements  = function(){
	    while(this.pendingElements.length){
	        var element = this.pendingElements.pop();
	        element.checkParenting();
	    }
	};
	
	HybridRenderer.prototype.appendElementInPos = function(element, pos){
	    var newDOMElement = element.getBaseElement();
	    if(!newDOMElement){
	        return;
	    }
	    var layer = this.layers[pos];
	    if(!layer.ddd || !this.supports3d){
	        if(this.threeDElements) {
	            this.addTo3dContainer(newDOMElement,pos);
	        } else {
	            var i = 0;
	            var nextDOMElement, nextLayer, tmpDOMElement;
	            while(i<pos){
	                if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement){
	                    nextLayer = this.elements[i];
	                    tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
	                    nextDOMElement = tmpDOMElement || nextDOMElement;
	                }
	                i += 1;
	            }
	            if(nextDOMElement){
	                if(!layer.ddd || !this.supports3d){
	                    this.layerElement.insertBefore(newDOMElement, nextDOMElement);
	                }
	            } else {
	                if(!layer.ddd || !this.supports3d){
	                    this.layerElement.appendChild(newDOMElement);
	                }
	            }
	        }
	        
	    } else {
	        this.addTo3dContainer(newDOMElement,pos);
	    }
	};
	
	HybridRenderer.prototype.createShape = function (data) {
	    if(!this.supports3d){
	        return new SVGShapeElement(data, this.globalData, this);
	    }
	    return new HShapeElement(data, this.globalData, this);
	};
	
	HybridRenderer.prototype.createText = function (data) {
	    if(!this.supports3d){
	        return new SVGTextElement(data, this.globalData, this);
	    }
	    return new HTextElement(data, this.globalData, this);
	};
	
	HybridRenderer.prototype.createCamera = function (data) {
	    this.camera = new HCameraElement(data, this.globalData, this);
	    return this.camera;
	};
	
	HybridRenderer.prototype.createImage = function (data) {
	    if(!this.supports3d){
	        return new IImageElement(data, this.globalData, this);
	    }
	    return new HImageElement(data, this.globalData, this);
	};
	
	HybridRenderer.prototype.createComp = function (data) {
	    if(!this.supports3d){
	        return new SVGCompElement(data, this.globalData, this);
	    }
	    return new HCompElement(data, this.globalData, this);
	
	};
	
	HybridRenderer.prototype.createSolid = function (data) {
	    if(!this.supports3d){
	        return new ISolidElement(data, this.globalData, this);
	    }
	    return new HSolidElement(data, this.globalData, this);
	};
	
	HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;
	
	HybridRenderer.prototype.getThreeDContainerByPos = function(pos){
	    var i = 0, len = this.threeDElements.length;
	    while(i<len) {
	        if(this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
	            return this.threeDElements[i].perspectiveElem;
	        }
	        i += 1;
	    }
	};
	
	HybridRenderer.prototype.createThreeDContainer = function(pos, type){
	    var perspectiveElem = createTag('div');
	    styleDiv(perspectiveElem);
	    var container = createTag('div');
	    styleDiv(container);
	    if(type === '3d') {
	        perspectiveElem.style.width = this.globalData.compSize.w+'px';
	        perspectiveElem.style.height = this.globalData.compSize.h+'px';
	        perspectiveElem.style.transformOrigin = perspectiveElem.style.mozTransformOrigin = perspectiveElem.style.webkitTransformOrigin = "50% 50%";
	        container.style.transform = container.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	    }
	    
	    perspectiveElem.appendChild(container);
	    //this.resizerElem.appendChild(perspectiveElem);
	    var threeDContainerData = {
	        container:container,
	        perspectiveElem:perspectiveElem,
	        startPos: pos,
	        endPos: pos,
	        type: type
	    };
	    this.threeDElements.push(threeDContainerData);
	    return threeDContainerData;
	};
	
	HybridRenderer.prototype.build3dContainers = function(){
	    var i, len = this.layers.length;
	    var lastThreeDContainerData;
	    var currentContainer = '';
	    for(i=0;i<len;i+=1){
	        if(this.layers[i].ddd && this.layers[i].ty !== 3){
	            if(currentContainer !== '3d'){
	                currentContainer = '3d';
	                lastThreeDContainerData = this.createThreeDContainer(i,'3d');
	            }
	            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);
	        } else {
	            if(currentContainer !== '2d'){
	                currentContainer = '2d';
	                lastThreeDContainerData = this.createThreeDContainer(i,'2d');
	            }
	            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);
	        }
	    }
	    len = this.threeDElements.length;
	    for(i = len - 1; i >= 0; i --) {
	        this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
	    }
	};
	
	HybridRenderer.prototype.addTo3dContainer = function(elem,pos){
	    var i = 0, len = this.threeDElements.length;
	    while(i<len){
	        if(pos <= this.threeDElements[i].endPos){
	            var j = this.threeDElements[i].startPos;
	            var nextElement;
	            while(j<pos){
	                if(this.elements[j] && this.elements[j].getBaseElement){
	                    nextElement = this.elements[j].getBaseElement();
	                }
	                j += 1;
	            }
	            if(nextElement){
	                this.threeDElements[i].container.insertBefore(elem, nextElement);
	            } else {
	                this.threeDElements[i].container.appendChild(elem);
	            }
	            break;
	        }
	        i += 1;
	    }
	};
	
	HybridRenderer.prototype.configAnimation = function(animData){
	    var resizerElem = createTag('div');
	    var wrapper = this.animationItem.wrapper;
	    resizerElem.style.width = animData.w+'px';
	    resizerElem.style.height = animData.h+'px';
	    this.resizerElem = resizerElem;
	    styleDiv(resizerElem);
	    resizerElem.style.transformStyle = resizerElem.style.webkitTransformStyle = resizerElem.style.mozTransformStyle = "flat";
	    if(this.renderConfig.className) {
	      resizerElem.setAttribute('class', this.renderConfig.className);
	    }
	    wrapper.appendChild(resizerElem);
	
	    resizerElem.style.overflow = 'hidden';
	    var svg = createNS('svg');
	    svg.setAttribute('width','1');
	    svg.setAttribute('height','1');
	    styleDiv(svg);
	    this.resizerElem.appendChild(svg);
	    var defs = createNS('defs');
	    svg.appendChild(defs);
	    this.data = animData;
	    //Mask animation
	    this.setupGlobalData(animData, svg);
	    this.globalData.defs = defs;
	    this.layers = animData.layers;
	    this.layerElement = this.resizerElem;
	    this.build3dContainers();
	    this.updateContainerSize();
	};
	
	HybridRenderer.prototype.destroy = function () {
	    this.animationItem.wrapper.innerHTML = '';
	    this.animationItem.container = null;
	    this.globalData.defs = null;
	    var i, len = this.layers ? this.layers.length : 0;
	    for (i = 0; i < len; i++) {
	        this.elements[i].destroy();
	    }
	    this.elements.length = 0;
	    this.destroyed = true;
	    this.animationItem = null;
	};
	
	HybridRenderer.prototype.updateContainerSize = function () {
	    var elementWidth = this.animationItem.wrapper.offsetWidth;
	    var elementHeight = this.animationItem.wrapper.offsetHeight;
	    var elementRel = elementWidth/elementHeight;
	    var animationRel = this.globalData.compSize.w/this.globalData.compSize.h;
	    var sx,sy,tx,ty;
	    if(animationRel>elementRel){
	        sx = elementWidth/(this.globalData.compSize.w);
	        sy = elementWidth/(this.globalData.compSize.w);
	        tx = 0;
	        ty = ((elementHeight-this.globalData.compSize.h*(elementWidth/this.globalData.compSize.w))/2);
	    }else{
	        sx = elementHeight/(this.globalData.compSize.h);
	        sy = elementHeight/(this.globalData.compSize.h);
	        tx = (elementWidth-this.globalData.compSize.w*(elementHeight/this.globalData.compSize.h))/2;
	        ty = 0;
	    }
	    this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,'+sy+',0,0,0,0,1,0,'+tx+','+ty+',0,1)';
	};
	
	HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
	
	HybridRenderer.prototype.hide = function(){
	    this.resizerElem.style.display = 'none';
	};
	
	HybridRenderer.prototype.show = function(){
	    this.resizerElem.style.display = 'block';
	};
	
	HybridRenderer.prototype.initItems = function(){
	    this.buildAllItems();
	    if(this.camera){
	        this.camera.setup();
	    } else {
	        var cWidth = this.globalData.compSize.w;
	        var cHeight = this.globalData.compSize.h;
	        var i, len = this.threeDElements.length;
	        for(i=0;i<len;i+=1){
	            this.threeDElements[i].perspectiveElem.style.perspective = this.threeDElements[i].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(cWidth,2) + Math.pow(cHeight,2)) + 'px';
	        }
	    }
	};
	
	HybridRenderer.prototype.searchExtraCompositions = function(assets){
	    var i, len = assets.length;
	    var floatingContainer = createTag('div');
	    for(i=0;i<len;i+=1){
	        if(assets[i].xt){
	            var comp = this.createComp(assets[i],floatingContainer,this.globalData.comp,null);
	            comp.initExpressions();
	            this.globalData.projectInterface.registerComposition(comp);
	        }
	    }
	};
	
	function MaskElement(data,element,globalData) {
	    this.data = data;
	    this.element = element;
	    this.globalData = globalData;
	    this.storedData = [];
	    this.masksProperties = this.data.masksProperties || [];
	    this.maskElement = null;
	    var defs = this.globalData.defs;
	    var i, len = this.masksProperties ? this.masksProperties.length : 0;
	    this.viewData = createSizedArray(len);
	    this.solidPath = '';
	
	
	    var path, properties = this.masksProperties;
	    var count = 0;
	    var currentMasks = [];
	    var j, jLen;
	    var layerId = createElementID();
	    var rect, expansor, feMorph,x;
	    var maskType = 'clipPath', maskRef = 'clip-path';
	    for (i = 0; i < len; i++) {
	        if((properties[i].mode !== 'a' && properties[i].mode !== 'n')|| properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x){
	            maskType = 'mask';
	            maskRef = 'mask';
	        }
	
	        if((properties[i].mode == 's' || properties[i].mode == 'i') && count === 0){
	            rect = createNS( 'rect');
	            rect.setAttribute('fill', '#ffffff');
	            rect.setAttribute('width', this.element.comp.data.w || 0);
	            rect.setAttribute('height', this.element.comp.data.h || 0);
	            currentMasks.push(rect);
	        } else {
	            rect = null;
	        }
	
	        path = createNS( 'path');
	        if(properties[i].mode == 'n') {
	            // TODO move this to a factory or to a constructor
	            this.viewData[i] = {
	                op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),
	                prop: ShapePropertyFactory.getShapeProp(this.element,properties[i],3),
	                elem: path,
	                lastPath: ''
	            };
	            defs.appendChild(path);
	            continue;
	        }
	        count += 1;
	
	        path.setAttribute('fill', properties[i].mode === 's' ? '#000000':'#ffffff');
	        path.setAttribute('clip-rule','nonzero');
	        var filterID;
	
	        if (properties[i].x.k !== 0) {
	            maskType = 'mask';
	            maskRef = 'mask';
	            x = PropertyFactory.getProp(this.element,properties[i].x,0,null,this.element);
	            filterID = createElementID();
	            expansor = createNS('filter');
	            expansor.setAttribute('id',filterID);
	            feMorph = createNS('feMorphology');
	            feMorph.setAttribute('operator','erode');
	            feMorph.setAttribute('in','SourceGraphic');
	            feMorph.setAttribute('radius','0');
	            expansor.appendChild(feMorph);
	            defs.appendChild(expansor);
	            path.setAttribute('stroke', properties[i].mode === 's' ? '#000000':'#ffffff');
	        } else {
	            feMorph = null;
	            x = null;
	        }
	
	        // TODO move this to a factory or to a constructor
	        this.storedData[i] = {
	             elem: path,
	             x: x,
	             expan: feMorph,
	            lastPath: '',
	            lastOperator:'',
	            filterId:filterID,
	            lastRadius:0
	        };
	        if(properties[i].mode == 'i'){
	            jLen = currentMasks.length;
	            var g = createNS('g');
	            for(j=0;j<jLen;j+=1){
	                g.appendChild(currentMasks[j]);
	            }
	            var mask = createNS('mask');
	            mask.setAttribute('mask-type','alpha');
	            mask.setAttribute('id',layerId+'_'+count);
	            mask.appendChild(path);
	            defs.appendChild(mask);
	            g.setAttribute('mask','url(' + locationHref + '#'+layerId+'_'+count+')');
	
	            currentMasks.length = 0;
	            currentMasks.push(g);
	        }else{
	            currentMasks.push(path);
	        }
	        if(properties[i].inv && !this.solidPath){
	            this.solidPath = this.createLayerSolidPath();
	        }
	        // TODO move this to a factory or to a constructor
	        this.viewData[i] = {
	            elem: path,
	            lastPath: '',
	            op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),
	            prop:ShapePropertyFactory.getShapeProp(this.element,properties[i],3),
	            invRect: rect
	        };
	        if(!this.viewData[i].prop.k){
	            this.drawPath(properties[i],this.viewData[i].prop.v,this.viewData[i]);
	        }
	    }
	
	    this.maskElement = createNS( maskType);
	
	    len = currentMasks.length;
	    for(i=0;i<len;i+=1){
	        this.maskElement.appendChild(currentMasks[i]);
	    }
	
	    if(count > 0){
	        this.maskElement.setAttribute('id', layerId);
	        this.element.maskedElement.setAttribute(maskRef, "url(" + locationHref + "#" + layerId + ")");
	        defs.appendChild(this.maskElement);
	    }
	    if (this.viewData.length) {
	        this.element.addRenderableComponent(this);
	    }
	
	}
	
	MaskElement.prototype.getMaskProperty = function(pos){
	    return this.viewData[pos].prop;
	};
	
	MaskElement.prototype.renderFrame = function (isFirstFrame) {
	    var finalMat = this.element.finalTransform.mat;
	    var i, len = this.masksProperties.length;
	    for (i = 0; i < len; i++) {
	        if(this.viewData[i].prop._mdf || isFirstFrame){
	            this.drawPath(this.masksProperties[i],this.viewData[i].prop.v,this.viewData[i]);
	        }
	        if(this.viewData[i].op._mdf || isFirstFrame){
	            this.viewData[i].elem.setAttribute('fill-opacity',this.viewData[i].op.v);
	        }
	        if(this.masksProperties[i].mode !== 'n'){
	            if(this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)){
	                this.viewData[i].invRect.setAttribute('x', -finalMat.props[12]);
	                this.viewData[i].invRect.setAttribute('y', -finalMat.props[13]);
	            }
	            if(this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)){
	                var feMorph = this.storedData[i].expan;
	                if(this.storedData[i].x.v < 0){
	                    if(this.storedData[i].lastOperator !== 'erode'){
	                        this.storedData[i].lastOperator = 'erode';
	                        this.storedData[i].elem.setAttribute('filter','url(' + locationHref + '#'+this.storedData[i].filterId+')');
	                    }
	                    feMorph.setAttribute('radius',-this.storedData[i].x.v);
	                }else{
	                    if(this.storedData[i].lastOperator !== 'dilate'){
	                        this.storedData[i].lastOperator = 'dilate';
	                        this.storedData[i].elem.setAttribute('filter',null);
	                    }
	                    this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v*2);
	
	                }
	            }
	        }
	    }
	};
	
	MaskElement.prototype.getMaskelement = function () {
	    return this.maskElement;
	};
	
	MaskElement.prototype.createLayerSolidPath = function(){
	    var path = 'M0,0 ';
	    path += ' h' + this.globalData.compSize.w ;
	    path += ' v' + this.globalData.compSize.h ;
	    path += ' h-' + this.globalData.compSize.w ;
	    path += ' v-' + this.globalData.compSize.h + ' ';
	    return path;
	};
	
	MaskElement.prototype.drawPath = function(pathData,pathNodes,viewData){
	    var pathString = " M"+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	    var i, len;
	    len = pathNodes._length;
	    for(i=1;i<len;i+=1){
	        //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
	        pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
	    }
	        //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	    if(pathNodes.c && len > 1){
	        pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
	    }
	    //pathNodes.__renderedString = pathString;
	
	    if(viewData.lastPath !== pathString){
	        var pathShapeValue = '';
	        if(viewData.elem){
	            if(pathNodes.c){
	                pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
	            }
	            viewData.elem.setAttribute('d',pathShapeValue);
	        }
	        viewData.lastPath = pathString;
	    }
	};
	
	MaskElement.prototype.destroy = function(){
	    this.element = null;
	    this.globalData = null;
	    this.maskElement = null;
	    this.data = null;
	    this.masksProperties = null;
	};
	
	/**
	 * @file 
	 * Handles AE's layer parenting property.
	 *
	 */
	
	function HierarchyElement(){}
	
	HierarchyElement.prototype = {
		/**
	     * @function 
	     * Initializes hierarchy properties
	     *
	     */
		initHierarchy: function() {
			//element's parent list
		    this.hierarchy = [];
		    //if element is parent of another layer _isParent will be true
		    this._isParent = false;
		    this.checkParenting();
		},
		/**
	     * @function 
	     * Sets layer's hierarchy.
	     * @param {array} hierarch
	     * layer's parent list
	     *
	     */ 
		setHierarchy: function(hierarchy){
		    this.hierarchy = hierarchy;
		},
		/**
	     * @function 
	     * Sets layer as parent.
	     *
	     */ 
		setAsParent: function() {
		    this._isParent = true;
		},
		/**
	     * @function 
	     * Searches layer's parenting chain
	     *
	     */ 
		checkParenting: function(){
		    if (this.data.parent !== undefined){
		        this.comp.buildElementParenting(this, this.data.parent, []);
		    }
		}
	};
	/**
	 * @file 
	 * Handles element's layer frame update.
	 * Checks layer in point and out point
	 *
	 */
	
	function FrameElement(){}
	
	FrameElement.prototype = {
	    /**
	     * @function 
	     * Initializes frame related properties.
	     *
	     */
	    initFrame: function(){
	        //set to true when inpoint is rendered
	        this._isFirstFrame = false;
	        //list of animated properties
	        this.dynamicProperties = [];
	        // If layer has been modified in current tick this will be true
	        this._mdf = false;
	    },
	    /**
	     * @function 
	     * Calculates all dynamic values
	     *
	     * @param {number} num
	     * current frame number in Layer's time
	     * @param {boolean} isVisible
	     * if layers is currently in range
	     * 
	     */
	    prepareProperties: function(num, isVisible) {
	        var i, len = this.dynamicProperties.length;
	        for (i = 0;i < len; i += 1) {
	            if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {
	                this.dynamicProperties[i].getValue();
	                if (this.dynamicProperties[i]._mdf) {
	                    this.globalData._mdf = true;
	                    this._mdf = true;
	                }
	            }
	        }
	    },
	    addDynamicProperty: function(prop) {
	        if(this.dynamicProperties.indexOf(prop) === -1) {
	            this.dynamicProperties.push(prop);
	        }
	    }
	};
	function TransformElement(){}
	
	TransformElement.prototype = {
	    initTransform: function() {
	        this.finalTransform = {
	            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {o:0},
	            _matMdf: false,
	            _opMdf: false,
	            mat: new Matrix()
	        };
	        if (this.data.ao) {
	            this.finalTransform.mProp.autoOriented = true;
	        }
	
	        //TODO: check TYPE 11: Guided elements
	        if (this.data.ty !== 11) {
	            //this.createElements();
	        }
	    },
	    renderTransform: function() {
	
	        this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
	        this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
	
	        if (this.hierarchy) {
	            var mat;
	            var finalMat = this.finalTransform.mat;
	            var i = 0, len = this.hierarchy.length;
	            //Checking if any of the transformation matrices in the hierarchy chain has changed.
	            if (!this.finalTransform._matMdf) {
	                while (i < len) {
	                    if (this.hierarchy[i].finalTransform.mProp._mdf) {
	                        this.finalTransform._matMdf = true;
	                        break;
	                    }
	                    i += 1;
	                }
	            }
	            
	            if (this.finalTransform._matMdf) {
	                mat = this.finalTransform.mProp.v.props;
	                finalMat.cloneFromProps(mat);
	                for (i = 0; i < len; i += 1) {
	                    mat = this.hierarchy[i].finalTransform.mProp.v.props;
	                    finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
	                }
	            }
	        }
	    },
	    globalToLocal: function(pt) {
	        var transforms = [];
	        transforms.push(this.finalTransform);
	        var flag = true;
	        var comp = this.comp;
	        while (flag) {
	            if (comp.finalTransform) {
	                if (comp.data.hasMask) {
	                    transforms.splice(0, 0, comp.finalTransform);
	                }
	                comp = comp.comp;
	            } else {
	                flag = false;
	            }
	        }
	        var i, len = transforms.length,ptNew;
	        for (i = 0; i < len; i += 1) {
	            ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
	            //ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
	            pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
	        }
	        return pt;
	    },
	    mHelper: new Matrix()
	};
	function RenderableElement(){
	
	}
	
	RenderableElement.prototype = {
	    initRenderable: function() {
	        //layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
	        this.isInRange = false;
	        //layer's display state
	        this.hidden = false;
	        // If layer's transparency equals 0, it can be hidden
	        this.isTransparent = false;
	        //list of animated components
	        this.renderableComponents = [];
	    },
	    addRenderableComponent: function(component) {
	        if(this.renderableComponents.indexOf(component) === -1) {
	            this.renderableComponents.push(component);
	        }
	    },
	    removeRenderableComponent: function(component) {
	        if(this.renderableComponents.indexOf(component) !== -1) {
	            this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
	        }
	    },
	    prepareRenderableFrame: function(num) {
	        this.checkLayerLimits(num);
	    },
	    checkTransparency: function(){
	        if(this.finalTransform.mProp.o.v <= 0) {
	            if(!this.isTransparent && this.globalData.renderConfig.hideOnTransparent){
	                this.isTransparent = true;
	                this.hide();
	            }
	        } else if(this.isTransparent) {
	            this.isTransparent = false;
	            this.show();
	        }
	    },
	    /**
	     * @function 
	     * Initializes frame related properties.
	     *
	     * @param {number} num
	     * current frame number in Layer's time
	     * 
	     */
	    checkLayerLimits: function(num) {
	        if(this.data.ip - this.data.st <= num && this.data.op - this.data.st > num)
	        {
	            if(this.isInRange !== true){
	                this.globalData._mdf = true;
	                this._mdf = true;
	                this.isInRange = true;
	                this.show();
	            }
	        } else {
	            if(this.isInRange !== false){
	                this.globalData._mdf = true;
	                this.isInRange = false;
	                this.hide();
	            }
	        }
	    },
	    renderRenderable: function() {
	        var i, len = this.renderableComponents.length;
	        for(i = 0; i < len; i += 1) {
	            this.renderableComponents[i].renderFrame(this._isFirstFrame);
	        }
	        /*this.maskManager.renderFrame(this.finalTransform.mat);
	        this.renderableEffectsManager.renderFrame(this._isFirstFrame);*/
	    },
	    sourceRectAtTime: function(){
	        return {
	            top:0,
	            left:0,
	            width:100,
	            height:100
	        };
	    },
	    getLayerSize: function(){
	        if(this.data.ty === 5){
	            return {w:this.data.textData.width,h:this.data.textData.height};
	        }else{
	            return {w:this.data.width,h:this.data.height};
	        }
	    }
	};
	function RenderableDOMElement() {}
	
	(function(){
	    var _prototype = {
	        initElement: function(data,globalData,comp) {
	            this.initFrame();
	            this.initBaseData(data, globalData, comp);
	            this.initTransform(data, globalData, comp);
	            this.initHierarchy();
	            this.initRenderable();
	            this.initRendererElement();
	            this.createContainerElements();
	            this.createRenderableComponents();
	            this.createContent();
	            this.hide();
	        },
	        hide: function(){
	            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
	                var elem = this.baseElement || this.layerElement;
	                elem.style.display = 'none';
	                this.hidden = true;
	            }
	        },
	        show: function(){
	            if (this.isInRange && !this.isTransparent){
	                if (!this.data.hd) {
	                    var elem = this.baseElement || this.layerElement;
	                    elem.style.display = 'block';
	                }
	                this.hidden = false;
	                this._isFirstFrame = true;
	            }
	        },
	        renderFrame: function() {
	            //If it is exported as hidden (data.hd === true) no need to render
	            //If it is not visible no need to render
	            if (this.data.hd || this.hidden) {
	                return;
	            }
	            this.renderTransform();
	            this.renderRenderable();
	            this.renderElement();
	            this.renderInnerContent();
	            if (this._isFirstFrame) {
	                this._isFirstFrame = false;
	            }
	        },
	        renderInnerContent: function() {},
	        prepareFrame: function(num) {
	            this._mdf = false;
	            this.prepareRenderableFrame(num);
	            this.prepareProperties(num, this.isInRange);
	            this.checkTransparency();
	        },
	        destroy: function(){
	            this.innerElem =  null;
	            this.destroyBaseElement();
	        }
	    };
	    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
	}());
	function ProcessedElement(element, position) {
		this.elem = element;
		this.pos = position;
	}
	function SVGStyleData(data, level) {
		this.data = data;
		this.type = data.ty;
		this.d = '';
		this.lvl = level;
		this._mdf = false;
		this.closed = data.hd === true;
		this.pElem = createNS('path');
		this.msElem = null;
	}
	
	SVGStyleData.prototype.reset = function() {
		this.d = '';
		this._mdf = false;
	};
	function SVGShapeData(transformers, level, shape) {
	    this.caches = [];
	    this.styles = [];
	    this.transformers = transformers;
	    this.lStr = '';
	    this.sh = shape;
	    this.lvl = level;
	    //TODO find if there are some cases where _isAnimated can be false. 
	    // For now, since shapes add up with other shapes. They have to be calculated every time.
	    // One way of finding out is checking if all styles associated to this shape depend only of this shape
	    this._isAnimated = !!shape.k;
	    // TODO: commenting this for now since all shapes are animated
	    var i = 0, len = transformers.length;
	    while(i < len) {
	    	if(transformers[i].mProps.dynamicProperties.length) {
	    		this._isAnimated = true;
	    		break;
	    	}
	    	i += 1;
	    }
	}
	
	SVGShapeData.prototype.setAsAnimated = function() {
	    this._isAnimated = true;
	}
	function SVGTransformData(mProps, op, container) {
		this.transform = {
			mProps: mProps,
			op: op,
			container: container
		};
		this.elements = [];
	    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
	}
	function SVGStrokeStyleData(elem, data, styleOb){
		this.initDynamicPropertyContainer(elem);
		this.getValue = this.iterateDynamicProperties;
		this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);
		this.w = PropertyFactory.getProp(elem,data.w,0,null,this);
		this.d = new DashProperty(elem,data.d||{},'svg',this);
		this.c = PropertyFactory.getProp(elem,data.c,1,255,this);
		this.style = styleOb;
	    this._isAnimated = !!this._isAnimated;
	}
	
	extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
	function SVGFillStyleData(elem, data, styleOb){
		this.initDynamicPropertyContainer(elem);
		this.getValue = this.iterateDynamicProperties;
		this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);
		this.c = PropertyFactory.getProp(elem,data.c,1,255,this);
		this.style = styleOb;
	}
	
	extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
	function SVGGradientFillStyleData(elem, data, styleOb){
	    this.initDynamicPropertyContainer(elem);
	    this.getValue = this.iterateDynamicProperties;
	    this.initGradientData(elem, data, styleOb);
	}
	
	SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb){
	    this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);
	    this.s = PropertyFactory.getProp(elem,data.s,1,null,this);
	    this.e = PropertyFactory.getProp(elem,data.e,1,null,this);
	    this.h = PropertyFactory.getProp(elem,data.h||{k:0},0,0.01,this);
	    this.a = PropertyFactory.getProp(elem,data.a||{k:0},0,degToRads,this);
	    this.g = new GradientProperty(elem,data.g,this);
	    this.style = styleOb;
	    this.stops = [];
	    this.setGradientData(styleOb.pElem, data);
	    this.setGradientOpacity(data, styleOb);
	    this._isAnimated = !!this._isAnimated;
	
	};
	
	SVGGradientFillStyleData.prototype.setGradientData = function(pathElement,data){
	
	    var gradientId = createElementID();
	    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
	    gfill.setAttribute('id',gradientId);
	    gfill.setAttribute('spreadMethod','pad');
	    gfill.setAttribute('gradientUnits','userSpaceOnUse');
	    var stops = [];
	    var stop, j, jLen;
	    jLen = data.g.p*4;
	    for(j=0;j<jLen;j+=4){
	        stop = createNS('stop');
	        gfill.appendChild(stop);
	        stops.push(stop);
	    }
	    pathElement.setAttribute( data.ty === 'gf' ? 'fill':'stroke','url(' + locationHref + '#'+gradientId+')');
	    
	    this.gf = gfill;
	    this.cst = stops;
	};
	
	SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb){
	    if(this.g._hasOpacity && !this.g._collapsable){
	        var stop, j, jLen;
	        var mask = createNS("mask");
	        var maskElement = createNS( 'path');
	        mask.appendChild(maskElement);
	        var opacityId = createElementID();
	        var maskId = createElementID();
	        mask.setAttribute('id',maskId);
	        var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
	        opFill.setAttribute('id',opacityId);
	        opFill.setAttribute('spreadMethod','pad');
	        opFill.setAttribute('gradientUnits','userSpaceOnUse');
	        jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
	        var stops = this.stops;
	        for(j=data.g.p*4;j<jLen;j+=2){
	            stop = createNS('stop');
	            stop.setAttribute('stop-color','rgb(255,255,255)');
	            opFill.appendChild(stop);
	            stops.push(stop);
	        }
	        maskElement.setAttribute( data.ty === 'gf' ? 'fill':'stroke','url(' + locationHref + '#'+opacityId+')');
	        this.of = opFill;
	        this.ms = mask;
	        this.ost = stops;
	        this.maskId = maskId;
	        styleOb.msElem = maskElement;
	    }
	};
	
	extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
	function SVGGradientStrokeStyleData(elem, data, styleOb){
		this.initDynamicPropertyContainer(elem);
		this.getValue = this.iterateDynamicProperties;
		this.w = PropertyFactory.getProp(elem,data.w,0,null,this);
		this.d = new DashProperty(elem,data.d||{},'svg',this);
	    this.initGradientData(elem, data, styleOb);
	    this._isAnimated = !!this._isAnimated;
	}
	
	extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
	function ShapeGroupData() {
		this.it = [];
	    this.prevViewData = [];
	    this.gr = createNS('g');
	}
	var SVGElementsRenderer = (function() {
		var _identityMatrix = new Matrix();
		var _matrixHelper = new Matrix();
	
		var ob = {
			createRenderFunction: createRenderFunction
		}
	
		function createRenderFunction(data) {
		    var ty = data.ty;
		    switch(data.ty) {
		        case 'fl':
		        return renderFill;
		        case 'gf':
		        return renderGradient;
		        case 'gs':
		        return renderGradientStroke;
		        case 'st':
		        return renderStroke;
		        case 'sh':
		        case 'el':
		        case 'rc':
		        case 'sr':
		        return renderPath;
		        case 'tr':
		        return renderContentTransform;
		    }
		}
	
		function renderContentTransform(styleData, itemData, isFirstFrame) {
		    if(isFirstFrame || itemData.transform.op._mdf){
		        itemData.transform.container.setAttribute('opacity',itemData.transform.op.v);
		    }
		    if(isFirstFrame || itemData.transform.mProps._mdf){
		        itemData.transform.container.setAttribute('transform',itemData.transform.mProps.v.to2dCSS());
		    }
		}
	
		function renderPath(styleData, itemData, isFirstFrame) {
		    var j, jLen,pathStringTransformed,redraw,pathNodes,l, lLen = itemData.styles.length;
		    var lvl = itemData.lvl;
		    var paths, mat, props, iterations, k;
		    for(l=0;l<lLen;l+=1){
		        redraw = itemData.sh._mdf || isFirstFrame;
		        if(itemData.styles[l].lvl < lvl){
		            mat = _matrixHelper.reset();
		            iterations = lvl - itemData.styles[l].lvl;
		            k = itemData.transformers.length-1;
		            while(!redraw && iterations > 0) {
		                redraw = itemData.transformers[k].mProps._mdf || redraw;
		                iterations --;
		                k --;
		            }
		            if(redraw) {
		                iterations = lvl - itemData.styles[l].lvl;
		                k = itemData.transformers.length-1;
		                while(iterations > 0) {
		                    props = itemData.transformers[k].mProps.v.props;
		                    mat.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
		                    iterations --;
		                    k --;
		                }
		            }
		        } else {
		            mat = _identityMatrix;
		        }
		        paths = itemData.sh.paths;
		        jLen = paths._length;
		        if(redraw){
		            pathStringTransformed = '';
		            for(j=0;j<jLen;j+=1){
		                pathNodes = paths.shapes[j];
		                if(pathNodes && pathNodes._length){
		                    pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
		                }
		            }
		            itemData.caches[l] = pathStringTransformed;
		        } else {
		            pathStringTransformed = itemData.caches[l];
		        }
		        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
		        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
		    }
		}
	
		function renderFill (styleData,itemData, isFirstFrame){
		    var styleElem = itemData.style;
	
		    if(itemData.c._mdf || isFirstFrame){
		        styleElem.pElem.setAttribute('fill','rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')');
		    }
		    if(itemData.o._mdf || isFirstFrame){
		        styleElem.pElem.setAttribute('fill-opacity',itemData.o.v);
		    }
		};
	
		function renderGradientStroke (styleData, itemData, isFirstFrame) {
		    renderGradient(styleData, itemData, isFirstFrame);
		    renderStroke(styleData, itemData, isFirstFrame);
		}
	
		function renderGradient(styleData, itemData, isFirstFrame) {
		    var gfill = itemData.gf;
		    var hasOpacity = itemData.g._hasOpacity;
		    var pt1 = itemData.s.v, pt2 = itemData.e.v;
	
		    if (itemData.o._mdf || isFirstFrame) {
		        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
		        itemData.style.pElem.setAttribute(attr, itemData.o.v);
		    }
		    if (itemData.s._mdf || isFirstFrame) {
		        var attr1 = styleData.t === 1 ? 'x1' : 'cx';
		        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
		        gfill.setAttribute(attr1, pt1[0]);
		        gfill.setAttribute(attr2, pt1[1]);
		        if (hasOpacity && !itemData.g._collapsable) {
		            itemData.of.setAttribute(attr1, pt1[0]);
		            itemData.of.setAttribute(attr2, pt1[1]);
		        }
		    }
		    var stops, i, len, stop;
		    if (itemData.g._cmdf || isFirstFrame) {
		        stops = itemData.cst;
		        var cValues = itemData.g.c;
		        len = stops.length;
		        for (i = 0; i < len; i += 1){
		            stop = stops[i];
		            stop.setAttribute('offset', cValues[i * 4] + '%');
		            stop.setAttribute('stop-color','rgb('+ cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ','+cValues[i * 4 + 3] + ')');
		        }
		    }
		    if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
		        var oValues = itemData.g.o;
		        if(itemData.g._collapsable) {
		            stops = itemData.cst;
		        } else {
		            stops = itemData.ost;
		        }
		        len = stops.length;
		        for (i = 0; i < len; i += 1) {
		            stop = stops[i];
		            if(!itemData.g._collapsable) {
		                stop.setAttribute('offset', oValues[i * 2] + '%');
		            }
		            stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
		        }
		    }
		    if (styleData.t === 1) {
		        if (itemData.e._mdf  || isFirstFrame) {
		            gfill.setAttribute('x2', pt2[0]);
		            gfill.setAttribute('y2', pt2[1]);
		            if (hasOpacity && !itemData.g._collapsable) {
		                itemData.of.setAttribute('x2', pt2[0]);
		                itemData.of.setAttribute('y2', pt2[1]);
		            }
		        }
		    } else {
		        var rad;
		        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
		            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
		            gfill.setAttribute('r', rad);
		            if(hasOpacity && !itemData.g._collapsable){
		                itemData.of.setAttribute('r', rad);
		            }
		        }
		        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
		            if (!rad) {
		                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
		            }
		            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
	
		            var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99: itemData.h.v;
		            var dist = rad * percent;
		            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
		            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
		            gfill.setAttribute('fx', x);
		            gfill.setAttribute('fy', y);
		            if (hasOpacity && !itemData.g._collapsable) {
		                itemData.of.setAttribute('fx', x);
		                itemData.of.setAttribute('fy', y);
		            }
		        }
		        //gfill.setAttribute('fy','200');
		    }
		};
	
		function renderStroke(styleData, itemData, isFirstFrame) {
		    var styleElem = itemData.style;
		    var d = itemData.d;
		    if (d && (d._mdf || isFirstFrame) && d.dashStr) {
		        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
		        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
		    }
		    if(itemData.c && (itemData.c._mdf || isFirstFrame)){
		        styleElem.pElem.setAttribute('stroke','rgb(' + bm_floor(itemData.c.v[0]) + ',' + bm_floor(itemData.c.v[1]) + ',' + bm_floor(itemData.c.v[2]) + ')');
		    }
		    if(itemData.o._mdf || isFirstFrame){
		        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
		    }
		    if(itemData.w._mdf || isFirstFrame){
		        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
		        if(styleElem.msElem){
		            styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
		        }
		    }
		};
	
		return ob;
	}())
	function ShapeTransformManager() {
		this.sequences = {};
		this.sequenceList = [];
	    this.transform_key_count = 0;
	}
	
	ShapeTransformManager.prototype = {
		addTransformSequence: function(transforms) {
			var i, len = transforms.length;
			var key = '_';
			for(i = 0; i < len; i += 1) {
				key += transforms[i].transform.key + '_';
			}
			var sequence = this.sequences[key];
			if(!sequence) {
				sequence = {
					transforms: [].concat(transforms),
					finalTransform: new Matrix(),
					_mdf: false
				};
				this.sequences[key] = sequence;
				this.sequenceList.push(sequence);
			}
			return sequence;
		},
		processSequence: function(sequence, isFirstFrame) {
			var i = 0, len = sequence.transforms.length, _mdf = isFirstFrame;
			while (i < len && !isFirstFrame) {
				if (sequence.transforms[i].transform.mProps._mdf) {
					_mdf = true;
					break;
				}
				i += 1
			}
			if (_mdf) {
				var props;
				sequence.finalTransform.reset();
				for (i = len - 1; i >= 0; i -= 1) {
			        props = sequence.transforms[i].transform.mProps.v.props;
			        sequence.finalTransform.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
				}
			}
			sequence._mdf = _mdf;
			
		},
		processSequences: function(isFirstFrame) {
			var i, len = this.sequenceList.length;
			for (i = 0; i < len; i += 1) {
				this.processSequence(this.sequenceList[i], isFirstFrame);
			}
	
		},
		getNewKey: function() {
			return '_' + this.transform_key_count++;
		}
	}
	function CVShapeData(element, data, styles, transformsManager) {
	    this.styledShapes = [];
	    this.tr = [0,0,0,0,0,0];
	    var ty = 4;
	    if(data.ty == 'rc'){
	        ty = 5;
	    }else if(data.ty == 'el'){
	        ty = 6;
	    }else if(data.ty == 'sr'){
	        ty = 7;
	    }
	    this.sh = ShapePropertyFactory.getShapeProp(element,data,ty,element);
	    var i , len = styles.length,styledShape;
	    for (i = 0; i < len; i += 1) {
	        if (!styles[i].closed) {
	            styledShape = {
	                transforms: transformsManager.addTransformSequence(styles[i].transforms),
	                trNodes: []
	            }
	            this.styledShapes.push(styledShape);
	            styles[i].elements.push(styledShape);
	        }
	    }
	}
	
	CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
	function BaseElement(){
	}
	
	BaseElement.prototype = {
	    checkMasks: function(){
	        if(!this.data.hasMask){
	            return false;
	        }
	        var i = 0, len = this.data.masksProperties.length;
	        while(i<len) {
	            if((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
	                return true;
	            }
	            i += 1;
	        }
	        return false;
	    },
	    initExpressions: function(){
	        this.layerInterface = LayerExpressionInterface(this);
	        if(this.data.hasMask && this.maskManager) {
	            this.layerInterface.registerMaskInterface(this.maskManager);
	        }
	        var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this,this.layerInterface);
	        this.layerInterface.registerEffectsInterface(effectsInterface);
	
	        if(this.data.ty === 0 || this.data.xt){
	            this.compInterface = CompExpressionInterface(this);
	        } else if(this.data.ty === 4){
	            this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData,this.itemsData,this.layerInterface);
	            this.layerInterface.content = this.layerInterface.shapeInterface;
	        } else if(this.data.ty === 5){
	            this.layerInterface.textInterface = TextExpressionInterface(this);
	            this.layerInterface.text = this.layerInterface.textInterface;
	        }
	    },
	    setBlendMode: function(){
	        var blendModeValue = getBlendMode(this.data.bm);
	        var elem = this.baseElement || this.layerElement;
	
	        elem.style['mix-blend-mode'] = blendModeValue;
	    },
	    initBaseData: function(data, globalData, comp){
	        this.globalData = globalData;
	        this.comp = comp;
	        this.data = data;
	        this.layerId = createElementID();
	        
	        //Stretch factor for old animations missing this property.
	        if(!this.data.sr){
	            this.data.sr = 1;
	        }
	        // effects manager
	        this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties);
	        
	    },
	    getType: function(){
	        return this.type;
	    }
	    ,sourceRectAtTime: function(){}
	}
	function NullElement(data,globalData,comp){
	    this.initFrame();
		this.initBaseData(data, globalData, comp);
	    this.initFrame();
	    this.initTransform(data, globalData, comp);
	    this.initHierarchy();
	}
	
	NullElement.prototype.prepareFrame = function(num) {
	    this.prepareProperties(num, true);
	};
	
	NullElement.prototype.renderFrame = function() {
	};
	
	NullElement.prototype.getBaseElement = function() {
		return null;
	};
	
	NullElement.prototype.destroy = function() {
	};
	
	NullElement.prototype.sourceRectAtTime = function() {
	};
	
	NullElement.prototype.hide = function() {
	};
	
	extendPrototype([BaseElement,TransformElement,HierarchyElement,FrameElement], NullElement);
	
	function SVGBaseElement(){
	}
	
	SVGBaseElement.prototype = {
	    initRendererElement: function() {
	        this.layerElement = createNS('g');
	    },
	    createContainerElements: function(){
	        this.matteElement = createNS('g');
	        this.transformedElement = this.layerElement;
	        this.maskedElement = this.layerElement;
	        this._sizeChanged = false;
	        var layerElementParent = null;
	        //If this layer acts as a mask for the following layer
	        var filId, fil, gg;
	        if (this.data.td) {
	            if (this.data.td == 3 || this.data.td == 1) {
	                var masker = createNS('mask');
	                masker.setAttribute('id', this.layerId);
	                masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha');
	                masker.appendChild(this.layerElement);
	                layerElementParent = masker;
	                this.globalData.defs.appendChild(masker);
	                // This is only for IE and Edge when mask if of type alpha
	                if (!featureSupport.maskType && this.data.td == 1) {
	                    masker.setAttribute('mask-type', 'luminance');
	                    filId = createElementID();
	                    fil = filtersFactory.createFilter(filId);
	                    this.globalData.defs.appendChild(fil);
	                    fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	                    gg = createNS('g');
	                    gg.appendChild(this.layerElement);
	                    layerElementParent = gg;
	                    masker.appendChild(gg);
	                    gg.setAttribute('filter','url(' + locationHref + '#' + filId + ')');
	                }
	            } else if(this.data.td == 2) {
	                var maskGroup = createNS('mask');
	                maskGroup.setAttribute('id', this.layerId);
	                maskGroup.setAttribute('mask-type','alpha');
	                var maskGrouper = createNS('g');
	                maskGroup.appendChild(maskGrouper);
	                filId = createElementID();
	                fil = filtersFactory.createFilter(filId);
	                ////
	
	                // This solution doesn't work on Android when meta tag with viewport attribute is set
	                /*var feColorMatrix = createNS('feColorMatrix');
	                feColorMatrix.setAttribute('type', 'matrix');
	                feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
	                feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
	                fil.appendChild(feColorMatrix);*/
	                ////
	                var feCTr = createNS('feComponentTransfer');
	                feCTr.setAttribute('in','SourceGraphic');
	                fil.appendChild(feCTr);
	                var feFunc = createNS('feFuncA');
	                feFunc.setAttribute('type','table');
	                feFunc.setAttribute('tableValues','1.0 0.0');
	                feCTr.appendChild(feFunc);
	                ////
	                this.globalData.defs.appendChild(fil);
	                var alphaRect = createNS('rect');
	                alphaRect.setAttribute('width',  this.comp.data.w);
	                alphaRect.setAttribute('height', this.comp.data.h);
	                alphaRect.setAttribute('x','0');
	                alphaRect.setAttribute('y','0');
	                alphaRect.setAttribute('fill','#ffffff');
	                alphaRect.setAttribute('opacity','0');
	                maskGrouper.setAttribute('filter', 'url(' + locationHref + '#'+filId+')');
	                maskGrouper.appendChild(alphaRect);
	                maskGrouper.appendChild(this.layerElement);
	                layerElementParent = maskGrouper;
	                if (!featureSupport.maskType) {
	                    maskGroup.setAttribute('mask-type', 'luminance');
	                    fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
	                    gg = createNS('g');
	                    maskGrouper.appendChild(alphaRect);
	                    gg.appendChild(this.layerElement);
	                    layerElementParent = gg;
	                    maskGrouper.appendChild(gg);
	                }
	                this.globalData.defs.appendChild(maskGroup);
	            }
	        } else if (this.data.tt) {
	            this.matteElement.appendChild(this.layerElement);
	            layerElementParent = this.matteElement;
	            this.baseElement = this.matteElement;
	        } else {
	            this.baseElement = this.layerElement;
	        }
	        if (this.data.ln) {
	            this.layerElement.setAttribute('id', this.data.ln);
	        }
	        if (this.data.cl) {
	            this.layerElement.setAttribute('class', this.data.cl);
	        }
	        //Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
	        if (this.data.ty === 0 && !this.data.hd) {
	            var cp = createNS( 'clipPath');
	            var pt = createNS('path');
	            pt.setAttribute('d','M0,0 L' + this.data.w + ',0' + ' L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
	            var clipId = createElementID();
	            cp.setAttribute('id',clipId);
	            cp.appendChild(pt);
	            this.globalData.defs.appendChild(cp);
	
	            if (this.checkMasks()) {
	                var cpGroup = createNS('g');
	                cpGroup.setAttribute('clip-path','url(' + locationHref + '#'+clipId + ')');
	                cpGroup.appendChild(this.layerElement);
	                this.transformedElement = cpGroup;
	                if (layerElementParent) {
	                    layerElementParent.appendChild(this.transformedElement);
	                } else {
	                    this.baseElement = this.transformedElement;
	                }
	            } else {
	                this.layerElement.setAttribute('clip-path','url(' + locationHref + '#'+clipId+')');
	            }
	            
	        }
	        if (this.data.bm !== 0) {
	            this.setBlendMode();
	        }
	
	    },
	    renderElement: function() {
	        if (this.finalTransform._matMdf) {
	            this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
	        }
	        if (this.finalTransform._opMdf) {
	            this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
	        }
	    },
	    destroyBaseElement: function() {
	        this.layerElement = null;
	        this.matteElement = null;
	        this.maskManager.destroy();
	    },
	    getBaseElement: function() {
	        if (this.data.hd) {
	            return null;
	        }
	        return this.baseElement;
	    },
	    createRenderableComponents: function() {
	        this.maskManager = new MaskElement(this.data, this, this.globalData);
	        this.renderableEffectsManager = new SVGEffects(this);
	    },
	    setMatte: function(id) {
	        if (!this.matteElement) {
	            return;
	        }
	        this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + id + ")");
	    }
	};
	function IShapeElement(){
	}
	
	IShapeElement.prototype = {
	    addShapeToModifiers: function(data) {
	        var i, len = this.shapeModifiers.length;
	        for(i=0;i<len;i+=1){
	            this.shapeModifiers[i].addShape(data);
	        }
	    },
	    isShapeInAnimatedModifiers: function(data) {
	        var i = 0, len = this.shapeModifiers.length;
	        while(i < len) {
	            if(this.shapeModifiers[i].isAnimatedWithShape(data)) {
	                return true;
	            }
	        }
	        return false;
	    },
	    renderModifiers: function() {
	        if(!this.shapeModifiers.length){
	            return;
	        }
	        var i, len = this.shapes.length;
	        for(i=0;i<len;i+=1){
	            this.shapes[i].sh.reset();
	        }
	
	        len = this.shapeModifiers.length;
	        for(i=len-1;i>=0;i-=1){
	            this.shapeModifiers[i].processShapes(this._isFirstFrame);
	        }
	    },
	    lcEnum: {
	        '1': 'butt',
	        '2': 'round',
	        '3': 'square'
	    },
	    ljEnum: {
	        '1': 'miter',
	        '2': 'round',
	        '3': 'bevel'
	    },
	    searchProcessedElement: function(elem){
	        var elements = this.processedElements;
	        var i = 0, len = elements.length;
	        while (i < len) {
	            if (elements[i].elem === elem) {
	                return elements[i].pos;
	            }
	            i += 1;
	        }
	        return 0;
	    },
	    addProcessedElement: function(elem, pos){
	        var elements = this.processedElements;
	        var i = elements.length;
	        while(i) {
	            i -= 1;
	            if (elements[i].elem === elem) {
	                elements[i].pos = pos;
	                return;
	            }
	        }
	        elements.push(new ProcessedElement(elem, pos));
	    },
	    prepareFrame: function(num) {
	        this.prepareRenderableFrame(num);
	        this.prepareProperties(num, this.isInRange);
	    }
	};
	function ITextElement(){
	}
	
	ITextElement.prototype.initElement = function(data,globalData,comp){
	    this.lettersChangedFlag = true;
	    this.initFrame();
	    this.initBaseData(data, globalData, comp);
	    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
	    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
	    this.initTransform(data, globalData, comp);
	    this.initHierarchy();
	    this.initRenderable();
	    this.initRendererElement();
	    this.createContainerElements();
	    this.createRenderableComponents();
	    this.createContent();
	    this.hide();
	    this.textAnimator.searchProperties(this.dynamicProperties);
	};
	
	ITextElement.prototype.prepareFrame = function(num) {
	    this._mdf = false;
	    this.prepareRenderableFrame(num);
	    this.prepareProperties(num, this.isInRange);
	    if(this.textProperty._mdf || this.textProperty._isFirstFrame) {
	        this.buildNewText();
	        this.textProperty._isFirstFrame = false;
	        this.textProperty._mdf = false;
	    }
	};
	
	ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
	    var j,jLen = shapes.length;
	    var k, kLen, pathNodes;
	    var shapeStr = '';
	    for(j=0;j<jLen;j+=1){
	        pathNodes = shapes[j].ks.k;
	        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
	    }
	    return shapeStr;
	};
	
	ITextElement.prototype.updateDocumentData = function(newData, index) {
	    this.textProperty.updateDocumentData(newData, index);
	};
	
	ITextElement.prototype.canResizeFont = function(_canResize) {
	    this.textProperty.canResizeFont(_canResize);
	};
	
	ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
	    this.textProperty.setMinimumFontSize(_fontSize);
	};
	
	ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
	    if(documentData.ps){
	        matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
	    }
	    matrixHelper.translate(0,-documentData.ls,0);
	    switch(documentData.j){
	        case 1:
	            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]),0,0);
	            break;
	        case 2:
	            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber] )/2,0,0);
	            break;
	    }
	    matrixHelper.translate(xPos, yPos, 0);
	};
	
	
	ITextElement.prototype.buildColor = function(colorData) {
	    return 'rgb(' + Math.round(colorData[0]*255) + ',' + Math.round(colorData[1]*255) + ',' + Math.round(colorData[2]*255) + ')';
	};
	
	ITextElement.prototype.emptyProp = new LetterProps();
	
	ITextElement.prototype.destroy = function(){
	    
	};
	function ICompElement(){}
	
	extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
	
	ICompElement.prototype.initElement = function(data,globalData,comp) {
	    this.initFrame();
	    this.initBaseData(data, globalData, comp);
	    this.initTransform(data, globalData, comp);
	    this.initRenderable();
	    this.initHierarchy();
	    this.initRendererElement();
	    this.createContainerElements();
	    this.createRenderableComponents();
	    if(this.data.xt || !globalData.progressiveLoad){
	        this.buildAllItems();
	    }
	    this.hide();
	};
	
	/*ICompElement.prototype.hide = function(){
	    if(!this.hidden){
	        this.hideElement();
	        var i,len = this.elements.length;
	        for( i = 0; i < len; i+=1 ){
	            if(this.elements[i]){
	                this.elements[i].hide();
	            }
	        }
	    }
	};*/
	
	ICompElement.prototype.prepareFrame = function(num){
	    this._mdf = false;
	    this.prepareRenderableFrame(num);
	    this.prepareProperties(num, this.isInRange);
	    if(!this.isInRange && !this.data.xt){
	        return;
	    }
	
	    if (!this.tm._placeholder) {
	        var timeRemapped = this.tm.v;
	        if(timeRemapped === this.data.op){
	            timeRemapped = this.data.op - 1;
	        }
	        this.renderedFrame = timeRemapped;
	    } else {
	        this.renderedFrame = num/this.data.sr;
	    }
	    var i,len = this.elements.length;
	    if(!this.completeLayers){
	        this.checkLayers(this.renderedFrame);
	    }
	    //This iteration needs to be backwards because of how expressions connect between each other
	    for( i = len - 1; i >= 0; i -= 1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
	            if(this.elements[i]._mdf) {
	                this._mdf = true;
	            }
	        }
	    }
	};
	
	ICompElement.prototype.renderInnerContent = function() {
	    var i,len = this.layers.length;
	    for( i = 0; i < len; i += 1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	};
	
	ICompElement.prototype.setElements = function(elems){
	    this.elements = elems;
	};
	
	ICompElement.prototype.getElements = function(){
	    return this.elements;
	};
	
	ICompElement.prototype.destroyElements = function(){
	    var i,len = this.layers.length;
	    for( i = 0; i < len; i+=1 ){
	        if(this.elements[i]){
	            this.elements[i].destroy();
	        }
	    }
	};
	
	ICompElement.prototype.destroy = function(){
	    this.destroyElements();
	    this.destroyBaseElement();
	};
	
	function IImageElement(data,globalData,comp){
	    this.assetData = globalData.getAssetData(data.refId);
	    this.initElement(data,globalData,comp);
	    this.sourceRect = {top:0,left:0,width:this.assetData.w,height:this.assetData.h};
	}
	
	extendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement], IImageElement);
	
	IImageElement.prototype.createContent = function(){
	
	    var assetPath = this.globalData.getAssetsPath(this.assetData);
	
	    this.innerElem = createNS('image');
	    this.innerElem.setAttribute('width',this.assetData.w+"px");
	    this.innerElem.setAttribute('height',this.assetData.h+"px");
	    this.innerElem.setAttribute('preserveAspectRatio',this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
	    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
	    
	    this.layerElement.appendChild(this.innerElem);
	};
	
	IImageElement.prototype.sourceRectAtTime = function() {
		return this.sourceRect;
	}
	function ISolidElement(data,globalData,comp){
	    this.initElement(data,globalData,comp);
	}
	extendPrototype([IImageElement], ISolidElement);
	
	ISolidElement.prototype.createContent = function(){
	
	    var rect = createNS('rect');
	    ////rect.style.width = this.data.sw;
	    ////rect.style.height = this.data.sh;
	    ////rect.style.fill = this.data.sc;
	    rect.setAttribute('width',this.data.sw);
	    rect.setAttribute('height',this.data.sh);
	    rect.setAttribute('fill',this.data.sc);
	    this.layerElement.appendChild(rect);
	};
	function SVGCompElement(data,globalData,comp){
	    this.layers = data.layers;
	    this.supports3d = true;
	    this.completeLayers = false;
	    this.pendingElements = [];
	    this.elements = this.layers ? createSizedArray(this.layers.length) : [];
	    //this.layerElement = createNS('g');
	    this.initElement(data,globalData,comp);
	    this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this) : {_placeholder:true};
	}
	
	extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);
	function SVGTextElement(data,globalData,comp){
	    this.textSpans = [];
	    this.renderType = 'svg';
	    this.initElement(data,globalData,comp);
	}
	
	extendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement], SVGTextElement);
	
	SVGTextElement.prototype.createContent = function(){
	
	    if (this.data.singleShape && !this.globalData.fontManager.chars) {
	        this.textContainer = createNS('text');
	    }
	};
	
	SVGTextElement.prototype.buildTextContents = function(textArray) {
	    var i = 0, len = textArray.length;
	    var textContents = [], currentTextContent = '';
	    while (i < len) {
	        if(textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
	            textContents.push(currentTextContent);
	            currentTextContent = '';
	        } else {
	            currentTextContent += textArray[i];
	        }
	        i += 1;
	    }
	    textContents.push(currentTextContent);
	    return textContents;
	}
	
	SVGTextElement.prototype.buildNewText = function(){
	    var i, len;
	
	    var documentData = this.textProperty.currentData;
	    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
	    if(documentData.fc) {
	        this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
	    }else{
	        this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
	    }
	    if(documentData.sc){
	        this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
	        this.layerElement.setAttribute('stroke-width', documentData.sw);
	    }
	    this.layerElement.setAttribute('font-size', documentData.finalSize);
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    if(fontData.fClass){
	        this.layerElement.setAttribute('class',fontData.fClass);
	    } else {
	        this.layerElement.setAttribute('font-family', fontData.fFamily);
	        var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
	        this.layerElement.setAttribute('font-style', fStyle);
	        this.layerElement.setAttribute('font-weight', fWeight);
	    }
	    this.layerElement.setAttribute('arial-label', documentData.t);
	
	    var letters = documentData.l || [];
	    var usesGlyphs = !!this.globalData.fontManager.chars;
	    len = letters.length;
	
	    var tSpan;
	    var matrixHelper = this.mHelper;
	    var shapes, shapeStr = '', singleShape = this.data.singleShape;
	    var xPos = 0, yPos = 0, firstLine = true;
	    var trackingOffset = documentData.tr/1000*documentData.finalSize;
	    if(singleShape && !usesGlyphs && !documentData.sz) {
	        var tElement = this.textContainer;
	        var justify = 'start';
	        switch(documentData.j) {
	            case 1:
	                justify = 'end';
	                break;
	            case 2:
	                justify = 'middle';
	                break;
	        }
	        tElement.setAttribute('text-anchor',justify);
	        tElement.setAttribute('letter-spacing',trackingOffset);
	        var textContent = this.buildTextContents(documentData.finalText);
	        len = textContent.length;
	        yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
	        for ( i = 0; i < len; i += 1) {
	            tSpan = this.textSpans[i] || createNS('tspan');
	            tSpan.textContent = textContent[i];
	            tSpan.setAttribute('x', 0);
	            tSpan.setAttribute('y', yPos);
	            tSpan.style.display = 'inherit';
	            tElement.appendChild(tSpan);
	            this.textSpans[i] = tSpan;
	            yPos += documentData.finalLineHeight;
	        }
	        
	        this.layerElement.appendChild(tElement);
	    } else {
	        var cachedSpansLength = this.textSpans.length;
	        var shapeData, charData;
	        for (i = 0; i < len; i += 1) {
	            if(!usesGlyphs || !singleShape || i === 0){
	                tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs?'path':'text');
	                if (cachedSpansLength <= i) {
	                    tSpan.setAttribute('stroke-linecap', 'butt');
	                    tSpan.setAttribute('stroke-linejoin','round');
	                    tSpan.setAttribute('stroke-miterlimit','4');
	                    this.textSpans[i] = tSpan;
	                    this.layerElement.appendChild(tSpan);
	                }
	                tSpan.style.display = 'inherit';
	            }
	            
	            matrixHelper.reset();
	            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
	            if (singleShape) {
	                if(letters[i].n) {
	                    xPos = -trackingOffset;
	                    yPos += documentData.yOffset;
	                    yPos += firstLine ? 1 : 0;
	                    firstLine = false;
	                }
	                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
	                xPos += letters[i].l || 0;
	                //xPos += letters[i].val === ' ' ? 0 : trackingOffset;
	                xPos += trackingOffset;
	            }
	            if(usesGlyphs) {
	                charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	                shapeData = charData && charData.data || {};
	                shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
	                if(!singleShape){
	                    tSpan.setAttribute('d',this.createPathShape(matrixHelper,shapes));
	                } else {
	                    shapeStr += this.createPathShape(matrixHelper,shapes);
	                }
	            } else {
	                if(singleShape) {
	                    tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
	                }
	                tSpan.textContent = letters[i].val;
	                tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
	            }
	            //
	        }
	        if (singleShape && tSpan) {
	            tSpan.setAttribute('d',shapeStr);
	        }
	    }
	    while (i < this.textSpans.length){
	        this.textSpans[i].style.display = 'none';
	        i += 1;
	    }
	    
	    this._sizeChanged = true;
	};
	
	SVGTextElement.prototype.sourceRectAtTime = function(time){
	    this.prepareFrame(this.comp.renderedFrame - this.data.st);
	    this.renderInnerContent();
	    if(this._sizeChanged){
	        this._sizeChanged = false;
	        var textBox = this.layerElement.getBBox();
	        this.bbox = {
	            top: textBox.y,
	            left: textBox.x,
	            width: textBox.width,
	            height: textBox.height
	        };
	    }
	    return this.bbox;
	};
	
	SVGTextElement.prototype.renderInnerContent = function(){
	
	    if(!this.data.singleShape){
	        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	        if(this.lettersChangedFlag || this.textAnimator.lettersChangedFlag){
	            this._sizeChanged = true;
	            var  i,len;
	            var renderedLetters = this.textAnimator.renderedLetters;
	
	            var letters = this.textProperty.currentData.l;
	
	            len = letters.length;
	            var renderedLetter, textSpan;
	            for(i=0;i<len;i+=1){
	                if(letters[i].n){
	                    continue;
	                }
	                renderedLetter = renderedLetters[i];
	                textSpan = this.textSpans[i];
	                if(renderedLetter._mdf.m) {
	                    textSpan.setAttribute('transform',renderedLetter.m);
	                }
	                if(renderedLetter._mdf.o) {
	                    textSpan.setAttribute('opacity',renderedLetter.o);
	                }
	                if(renderedLetter._mdf.sw){
	                    textSpan.setAttribute('stroke-width',renderedLetter.sw);
	                }
	                if(renderedLetter._mdf.sc){
	                    textSpan.setAttribute('stroke',renderedLetter.sc);
	                }
	                if(renderedLetter._mdf.fc){
	                    textSpan.setAttribute('fill',renderedLetter.fc);
	                }
	            }
	        }
	    }
	};
	function SVGShapeElement(data,globalData,comp){
	    //List of drawable elements
	    this.shapes = [];
	    // Full shape data
	    this.shapesData = data.shapes;
	    //List of styles that will be applied to shapes
	    this.stylesList = [];
	    //List of modifiers that will be applied to shapes
	    this.shapeModifiers = [];
	    //List of items in shape tree
	    this.itemsData = [];
	    //List of items in previous shape tree
	    this.processedElements = [];
	    // List of animated components
	    this.animatedContents = [];
	    this.initElement(data,globalData,comp);
	    //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
	    // List of elements that have been created
	    this.prevViewData = [];
	    //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
	}
	
	extendPrototype([BaseElement,TransformElement,SVGBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableDOMElement], SVGShapeElement);
	
	SVGShapeElement.prototype.initSecondaryElement = function() {
	};
	
	SVGShapeElement.prototype.identityMatrix = new Matrix();
	
	SVGShapeElement.prototype.buildExpressionInterface = function(){};
	
	SVGShapeElement.prototype.createContent = function(){
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement, 0, [], true);
	    this.filterUniqueShapes();
	};
	
	/*
	This method searches for multiple shapes that affect a single element and one of them is animated
	*/
	SVGShapeElement.prototype.filterUniqueShapes = function(){
	    var i, len = this.shapes.length, shape;
	    var j, jLen = this.stylesList.length;
	    var style, count = 0;
	    var tempShapes = [];
	    var areAnimated = false;
	    for(j = 0; j < jLen; j += 1) {
	        style = this.stylesList[j];
	        areAnimated = false;
	        tempShapes.length = 0;
	        for(i = 0; i < len; i += 1) {
	            shape = this.shapes[i];
	            if(shape.styles.indexOf(style) !== -1) {
	                tempShapes.push(shape);
	                areAnimated = shape._isAnimated || areAnimated;
	            }
	        }
	        if(tempShapes.length > 1 && areAnimated) {
	            this.setShapesAsAnimated(tempShapes);
	        }
	    }
	}
	
	SVGShapeElement.prototype.setShapesAsAnimated = function(shapes){
	    var i, len = shapes.length;
	    for(i = 0; i < len; i += 1) {
	        shapes[i].setAsAnimated();
	    }
	}
	
	SVGShapeElement.prototype.createStyleElement = function(data, level){
	    //TODO: prevent drawing of hidden styles
	    var elementData;
	    var styleOb = new SVGStyleData(data, level);
	
	    var pathElement = styleOb.pElem;
	    if(data.ty === 'st') {
	        elementData = new SVGStrokeStyleData(this, data, styleOb);
	    } else if(data.ty === 'fl') {
	        elementData = new SVGFillStyleData(this, data, styleOb);
	    } else if(data.ty === 'gf' || data.ty === 'gs') {
	        var gradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
	        elementData = new gradientConstructor(this, data, styleOb);
	        this.globalData.defs.appendChild(elementData.gf);
	        if (elementData.maskId) {
	            this.globalData.defs.appendChild(elementData.ms);
	            this.globalData.defs.appendChild(elementData.of);
	            pathElement.setAttribute('mask','url(' + locationHref + '#' + elementData.maskId + ')');
	        }
	    }
	    
	    if(data.ty === 'st' || data.ty === 'gs') {
	        pathElement.setAttribute('stroke-linecap', this.lcEnum[data.lc] || 'round');
	        pathElement.setAttribute('stroke-linejoin',this.ljEnum[data.lj] || 'round');
	        pathElement.setAttribute('fill-opacity','0');
	        if(data.lj === 1) {
	            pathElement.setAttribute('stroke-miterlimit',data.ml);
	        }
	    }
	
	    if(data.r === 2) {
	        pathElement.setAttribute('fill-rule', 'evenodd');
	    }
	
	    if(data.ln){
	        pathElement.setAttribute('id',data.ln);
	    }
	    if(data.cl){
	        pathElement.setAttribute('class',data.cl);
	    }
	    if(data.bm){
	        pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
	    }
	    this.stylesList.push(styleOb);
	    this.addToAnimatedContents(data, elementData);
	    return elementData;
	};
	
	SVGShapeElement.prototype.createGroupElement = function(data) {
	    var elementData = new ShapeGroupData();
	    if(data.ln){
	        elementData.gr.setAttribute('id',data.ln);
	    }
	    if(data.cl){
	        elementData.gr.setAttribute('class',data.cl);
	    }
	    if(data.bm){
	        elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
	    }
	    return elementData;
	};
	
	SVGShapeElement.prototype.createTransformElement = function(data, container) {
	    var transformProperty = TransformPropertyFactory.getTransformProperty(this,data,this);
	    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
	    this.addToAnimatedContents(data, elementData);
	    return elementData;
	};
	
	SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {
	    var ty = 4;
	    if(data.ty === 'rc'){
	        ty = 5;
	    }else if(data.ty === 'el'){
	        ty = 6;
	    }else if(data.ty === 'sr'){
	        ty = 7;
	    }
	    var shapeProperty = ShapePropertyFactory.getShapeProp(this,data,ty,this);
	    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
	    this.shapes.push(elementData);
	    this.addShapeToModifiers(elementData);
	    this.addToAnimatedContents(data, elementData);
	    return elementData;
	};
	
	SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {
	    var i = 0, len = this.animatedContents.length;
	    while(i < len) {
	        if(this.animatedContents[i].element === element) {
	            return;
	        }
	        i += 1;
	    }
	    this.animatedContents.push({
	        fn: SVGElementsRenderer.createRenderFunction(data),
	        element: element,
	        data: data
	    });
	};
	
	SVGShapeElement.prototype.setElementStyles = function(elementData){
	    var arr = elementData.styles;
	    var j, jLen = this.stylesList.length;
	    for (j = 0; j < jLen; j += 1) {
	        if (!this.stylesList[j].closed) {
	            arr.push(this.stylesList[j]);
	        }
	    }
	};
	
	SVGShapeElement.prototype.reloadShapes = function(){
	    this._isFirstFrame = true;
	    var i, len = this.itemsData.length;
	    for( i = 0; i < len; i += 1) {
	        this.prevViewData[i] = this.itemsData[i];
	    }
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement, 0, [], true);
	    this.filterUniqueShapes();
	    len = this.dynamicProperties.length;
	    for(i = 0; i < len; i += 1) {
	        this.dynamicProperties[i].getValue();
	    }
	    this.renderModifiers();
	};
	
	SVGShapeElement.prototype.searchShapes = function(arr,itemsData,prevViewData,container, level, transformers, render){
	    var ownTransformers = [].concat(transformers);
	    var i, len = arr.length - 1;
	    var j, jLen;
	    var ownStyles = [], ownModifiers = [], styleOb, currentTransform, modifier, processedPos;
	    for(i=len;i>=0;i-=1){
	        processedPos = this.searchProcessedElement(arr[i]);
	        if(!processedPos){
	            arr[i]._render = render;
	        } else {
	            itemsData[i] = prevViewData[processedPos - 1];
	        }
	        if(arr[i].ty == 'fl' || arr[i].ty == 'st' || arr[i].ty == 'gf' || arr[i].ty == 'gs'){
	            if(!processedPos){
	                itemsData[i] = this.createStyleElement(arr[i], level);
	            } else {
	                itemsData[i].style.closed = false;
	            }
	            if(arr[i]._render){
	                container.appendChild(itemsData[i].style.pElem);
	            }
	            ownStyles.push(itemsData[i].style);
	        }else if(arr[i].ty == 'gr'){
	            if(!processedPos){
	                itemsData[i] = this.createGroupElement(arr[i]);
	            } else {
	                jLen = itemsData[i].it.length;
	                for(j=0;j<jLen;j+=1){
	                    itemsData[i].prevViewData[j] = itemsData[i].it[j];
	                }
	            }
	            this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData,itemsData[i].gr, level + 1, ownTransformers, render);
	            if(arr[i]._render){
	                container.appendChild(itemsData[i].gr);
	            }
	        }else if(arr[i].ty == 'tr'){
	            if(!processedPos){
	                itemsData[i] = this.createTransformElement(arr[i], container);
	            }
	            currentTransform = itemsData[i].transform;
	            ownTransformers.push(currentTransform);
	        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
	            if(!processedPos){
	                itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
	            }
	            this.setElementStyles(itemsData[i]);
	
	        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'ms'){
	            if(!processedPos){
	                modifier = ShapeModifiers.getModifier(arr[i].ty);
	                modifier.init(this,arr[i]);
	                itemsData[i] = modifier;
	                this.shapeModifiers.push(modifier);
	            } else {
	                modifier = itemsData[i];
	                modifier.closed = false;
	            }
	            ownModifiers.push(modifier);
	        }else if(arr[i].ty == 'rp'){
	            if(!processedPos){
	                modifier = ShapeModifiers.getModifier(arr[i].ty);
	                itemsData[i] = modifier;
	                modifier.init(this,arr,i,itemsData);
	                this.shapeModifiers.push(modifier);
	                render = false;
	            }else{
	                modifier = itemsData[i];
	                modifier.closed = true;
	            }
	            ownModifiers.push(modifier);
	        }
	        this.addProcessedElement(arr[i], i + 1);
	    }
	    len = ownStyles.length;
	    for(i=0;i<len;i+=1){
	        ownStyles[i].closed = true;
	    }
	    len = ownModifiers.length;
	    for(i=0;i<len;i+=1){
	        ownModifiers[i].closed = true;
	    }
	};
	
	SVGShapeElement.prototype.renderInnerContent = function() {
	    this.renderModifiers();
	    var i, len = this.stylesList.length;
	    for(i=0;i<len;i+=1){
	        this.stylesList[i].reset();
	    }
	    this.renderShape();
	
	    for (i = 0; i < len; i += 1) {
	        if (this.stylesList[i]._mdf || this._isFirstFrame) {
	            if(this.stylesList[i].msElem){
	                this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
	                //Adding M0 0 fixes same mask bug on all browsers
	                this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
	            }
	            this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
	        }
	    }
	};
	
	SVGShapeElement.prototype.renderShape = function() {
	    var i, len = this.animatedContents.length;
	    var animatedContent;
	    for(i = 0; i < len; i += 1) {
	        animatedContent = this.animatedContents[i];
	        if((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
	            animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
	        }
	    }
	}
	
	SVGShapeElement.prototype.destroy = function(){
	    this.destroyBaseElement();
	    this.shapesData = null;
	    this.itemsData = null;
	};
	
	function SVGTintFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = createNS('feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
	    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f1');
	    filter.appendChild(feColorMatrix);
	    feColorMatrix = createNS('feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f2');
	    filter.appendChild(feColorMatrix);
	    this.matrixFilter = feColorMatrix;
	    if(filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k){
	        var feMerge = createNS('feMerge');
	        filter.appendChild(feMerge);
	        var feMergeNode;
	        feMergeNode = createNS('feMergeNode');
	        feMergeNode.setAttribute('in','SourceGraphic');
	        feMerge.appendChild(feMergeNode);
	        feMergeNode = createNS('feMergeNode');
	        feMergeNode.setAttribute('in','f2');
	        feMerge.appendChild(feMergeNode);
	    }
	}
	
	SVGTintFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager._mdf){
	        var colorBlack = this.filterManager.effectElements[0].p.v;
	        var colorWhite = this.filterManager.effectElements[1].p.v;
	        var opacity = this.filterManager.effectElements[2].p.v/100;
	        this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
	    }
	};
	function SVGFillFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = createNS('feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
	    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
	    filter.appendChild(feColorMatrix);
	    this.matrixFilter = feColorMatrix;
	}
	SVGFillFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager._mdf){
	        var color = this.filterManager.effectElements[2].p.v;
	        var opacity = this.filterManager.effectElements[6].p.v;
	        this.matrixFilter.setAttribute('values','0 0 0 0 '+color[0]+' 0 0 0 0 '+color[1]+' 0 0 0 0 '+color[2]+' 0 0 0 '+opacity+' 0');
	    }
	};
	function SVGGaussianBlurEffect(filter, filterManager){
	    // Outset the filter region by 100% on all sides to accommodate blur expansion.
	    filter.setAttribute('x','-100%');
	    filter.setAttribute('y','-100%');
	    filter.setAttribute('width','300%');
	    filter.setAttribute('height','300%');
	
	    this.filterManager = filterManager;
	    var feGaussianBlur = createNS('feGaussianBlur');
	    filter.appendChild(feGaussianBlur);
	    this.feGaussianBlur = feGaussianBlur;
	}
	
	SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager._mdf){
	        // Empirical value, matching AE's blur appearance.
	        var kBlurrinessToSigma = 0.3;
	        var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
	
	        // Dimensions mapping:
	        //
	        //   1 -> horizontal & vertical
	        //   2 -> horizontal only
	        //   3 -> vertical only
	        //
	        var dimensions = this.filterManager.effectElements[1].p.v;
	        var sigmaX = (dimensions == 3) ? 0 : sigma;
	        var sigmaY = (dimensions == 2) ? 0 : sigma;
	
	        this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + " " + sigmaY);
	
	        // Repeat edges mapping:
	        //
	        //   0 -> off -> duplicate
	        //   1 -> on  -> wrap
	        var edgeMode = (this.filterManager.effectElements[2].p.v == 1) ? 'wrap' : 'duplicate';
	        this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
	    }
	}
	function SVGStrokeEffect(elem, filterManager){
	    this.initialized = false;
	    this.filterManager = filterManager;
	    this.elem = elem;
	    this.paths = [];
	}
	
	SVGStrokeEffect.prototype.initialize = function(){
	
	    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	    var path,groupPath, i, len;
	    if(this.filterManager.effectElements[1].p.v === 1){
	        len = this.elem.maskManager.masksProperties.length;
	        i = 0;
	    } else {
	        i = this.filterManager.effectElements[0].p.v - 1;
	        len = i + 1;
	    }
	    groupPath = createNS('g'); 
	    groupPath.setAttribute('fill','none');
	    groupPath.setAttribute('stroke-linecap','round');
	    groupPath.setAttribute('stroke-dashoffset',1);
	    for(i;i<len;i+=1){
	        path = createNS('path');
	        groupPath.appendChild(path);
	        this.paths.push({p:path,m:i});
	    }
	    if(this.filterManager.effectElements[10].p.v === 3){
	        var mask = createNS('mask');
	        var id = createElementID();
	        mask.setAttribute('id',id);
	        mask.setAttribute('mask-type','alpha');
	        mask.appendChild(groupPath);
	        this.elem.globalData.defs.appendChild(mask);
	        var g = createNS('g');
	        g.setAttribute('mask','url(' + locationHref + '#'+id+')');
	        while (elemChildren[0]) {
	            g.appendChild(elemChildren[0]);
	        }
	        this.elem.layerElement.appendChild(g);
	        this.masker = mask;
	        groupPath.setAttribute('stroke','#fff');
	    } else if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
	        if(this.filterManager.effectElements[10].p.v === 2){
	            elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
	            while(elemChildren.length){
	                this.elem.layerElement.removeChild(elemChildren[0]);
	            }
	        }
	        this.elem.layerElement.appendChild(groupPath);
	        this.elem.layerElement.removeAttribute('mask');
	        groupPath.setAttribute('stroke','#fff');
	    }
	    this.initialized = true;
	    this.pathMasker = groupPath;
	};
	
	SVGStrokeEffect.prototype.renderFrame = function(forceRender){
	    if(!this.initialized){
	        this.initialize();
	    }
	    var i, len = this.paths.length;
	    var mask, path;
	    for(i=0;i<len;i+=1){
	        if(this.paths[i].m === -1) {
	            continue;
	        }
	        mask = this.elem.maskManager.viewData[this.paths[i].m];
	        path = this.paths[i].p;
	        if(forceRender || this.filterManager._mdf || mask.prop._mdf){
	            path.setAttribute('d',mask.lastPath);
	        }
	        if(forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf){
	            var dasharrayValue;
	            if(this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100){
	                var s = Math.min(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
	                var e = Math.max(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
	                var l = path.getTotalLength();
	                dasharrayValue = '0 0 0 ' + l*s + ' ';
	                var lineLength = l*(e-s);
	                var segment = 1+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
	                var units = Math.floor(lineLength/segment);
	                var j;
	                for(j=0;j<units;j+=1){
	                    dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100 + ' ';
	                }
	                dasharrayValue += '0 ' + l*10 + ' 0 0';
	            } else {
	                dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
	            }
	            path.setAttribute('stroke-dasharray',dasharrayValue);
	        }
	    }
	    if(forceRender || this.filterManager.effectElements[4].p._mdf){
	        this.pathMasker.setAttribute('stroke-width',this.filterManager.effectElements[4].p.v*2);
	    }
	    
	    if(forceRender || this.filterManager.effectElements[6].p._mdf){
	        this.pathMasker.setAttribute('opacity',this.filterManager.effectElements[6].p.v);
	    }
	    if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
	        if(forceRender || this.filterManager.effectElements[3].p._mdf){
	            var color = this.filterManager.effectElements[3].p.v;
	            this.pathMasker.setAttribute('stroke','rgb('+bm_floor(color[0]*255)+','+bm_floor(color[1]*255)+','+bm_floor(color[2]*255)+')');
	        }
	    }
	};
	function SVGTritoneFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var feColorMatrix = createNS('feColorMatrix');
	    feColorMatrix.setAttribute('type','matrix');
	    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
	    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
	    feColorMatrix.setAttribute('result','f1');
	    filter.appendChild(feColorMatrix);
	    var feComponentTransfer = createNS('feComponentTransfer');
	    feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	    filter.appendChild(feComponentTransfer);
	    this.matrixFilter = feComponentTransfer;
	    var feFuncR = createNS('feFuncR');
	    feFuncR.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncR);
	    this.feFuncR = feFuncR;
	    var feFuncG = createNS('feFuncG');
	    feFuncG.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncG);
	    this.feFuncG = feFuncG;
	    var feFuncB = createNS('feFuncB');
	    feFuncB.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFuncB);
	    this.feFuncB = feFuncB;
	}
	
	SVGTritoneFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager._mdf){
	        var color1 = this.filterManager.effectElements[0].p.v;
	        var color2 = this.filterManager.effectElements[1].p.v;
	        var color3 = this.filterManager.effectElements[2].p.v;
	        var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
	        var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
	        var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
	        this.feFuncR.setAttribute('tableValues', tableR);
	        this.feFuncG.setAttribute('tableValues', tableG);
	        this.feFuncB.setAttribute('tableValues', tableB);
	        //var opacity = this.filterManager.effectElements[2].p.v/100;
	        //this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
	    }
	};
	function SVGProLevelsFilter(filter, filterManager){
	    this.filterManager = filterManager;
	    var effectElements = this.filterManager.effectElements;
	    var feComponentTransfer = createNS('feComponentTransfer');
	    var feFuncR, feFuncG, feFuncB;
	    
	    if(effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1){
	        this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
	    }
	    if(effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1){
	        this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
	    }
	    if(effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1){
	        this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
	    }
	    if(effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1){
	        this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
	    }
	    
	    if(this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA){
	        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	        filter.appendChild(feComponentTransfer);
	        feComponentTransfer = createNS('feComponentTransfer');
	    }
	
	    if(effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1){
	
	        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
	        filter.appendChild(feComponentTransfer);
	        this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
	        this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
	        this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
	    }
	}
	
	SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
	    var feFunc = createNS(type);
	    feFunc.setAttribute('type','table');
	    feComponentTransfer.appendChild(feFunc);
	    return feFunc;
	};
	
	SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
	    var cnt = 0;
	    var segments = 256;
	    var perc;
	    var min = Math.min(inputBlack, inputWhite);
	    var max = Math.max(inputBlack, inputWhite);
	    var table = Array.call(null,{length:segments});
	    var colorValue;
	    var pos = 0;
	    var outputDelta = outputWhite - outputBlack; 
	    var inputDelta = inputWhite - inputBlack; 
	    while(cnt <= 256) {
	        perc = cnt/256;
	        if(perc <= min){
	            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
	        } else if(perc >= max){
	            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
	        } else {
	            colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
	        }
	        table[pos++] = colorValue;
	        cnt += 256/(segments-1);
	    }
	    return table.join(' ');
	};
	
	SVGProLevelsFilter.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager._mdf){
	        var val, cnt, perc, bezier;
	        var effectElements = this.filterManager.effectElements;
	        if(this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)){
	            val = this.getTableValue(effectElements[3].p.v,effectElements[4].p.v,effectElements[5].p.v,effectElements[6].p.v,effectElements[7].p.v);
	            this.feFuncRComposed.setAttribute('tableValues',val);
	            this.feFuncGComposed.setAttribute('tableValues',val);
	            this.feFuncBComposed.setAttribute('tableValues',val);
	        }
	
	
	        if(this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)){
	            val = this.getTableValue(effectElements[10].p.v,effectElements[11].p.v,effectElements[12].p.v,effectElements[13].p.v,effectElements[14].p.v);
	            this.feFuncR.setAttribute('tableValues',val);
	        }
	
	        if(this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)){
	            val = this.getTableValue(effectElements[17].p.v,effectElements[18].p.v,effectElements[19].p.v,effectElements[20].p.v,effectElements[21].p.v);
	            this.feFuncG.setAttribute('tableValues',val);
	        }
	
	        if(this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)){
	            val = this.getTableValue(effectElements[24].p.v,effectElements[25].p.v,effectElements[26].p.v,effectElements[27].p.v,effectElements[28].p.v);
	            this.feFuncB.setAttribute('tableValues',val);
	        }
	
	        if(this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)){
	            val = this.getTableValue(effectElements[31].p.v,effectElements[32].p.v,effectElements[33].p.v,effectElements[34].p.v,effectElements[35].p.v);
	            this.feFuncA.setAttribute('tableValues',val);
	        }
	        
	    }
	};
	function SVGDropShadowEffect(filter, filterManager){
	    filter.setAttribute('x','-100%');
	    filter.setAttribute('y','-100%');
	    filter.setAttribute('width','400%');
	    filter.setAttribute('height','400%');
	    this.filterManager = filterManager;
	
	    var feGaussianBlur = createNS('feGaussianBlur');
	    feGaussianBlur.setAttribute('in','SourceAlpha');
	    feGaussianBlur.setAttribute('result','drop_shadow_1');
	    feGaussianBlur.setAttribute('stdDeviation','0');
	    this.feGaussianBlur = feGaussianBlur;
	    filter.appendChild(feGaussianBlur);
	
	    var feOffset = createNS('feOffset');
	    feOffset.setAttribute('dx','25');
	    feOffset.setAttribute('dy','0');
	    feOffset.setAttribute('in','drop_shadow_1');
	    feOffset.setAttribute('result','drop_shadow_2');
	    this.feOffset = feOffset;
	    filter.appendChild(feOffset);
	    var feFlood = createNS('feFlood');
	    feFlood.setAttribute('flood-color','#00ff00');
	    feFlood.setAttribute('flood-opacity','1');
	    feFlood.setAttribute('result','drop_shadow_3');
	    this.feFlood = feFlood;
	    filter.appendChild(feFlood);
	
	    var feComposite = createNS('feComposite');
	    feComposite.setAttribute('in','drop_shadow_3');
	    feComposite.setAttribute('in2','drop_shadow_2');
	    feComposite.setAttribute('operator','in');
	    feComposite.setAttribute('result','drop_shadow_4');
	    filter.appendChild(feComposite);
	
	
	    var feMerge = createNS('feMerge');
	    filter.appendChild(feMerge);
	    var feMergeNode;
	    feMergeNode = createNS('feMergeNode');
	    feMerge.appendChild(feMergeNode);
	    feMergeNode = createNS('feMergeNode');
	    feMergeNode.setAttribute('in','SourceGraphic');
	    this.feMergeNode = feMergeNode;
	    this.feMerge = feMerge;
	    this.originalNodeAdded = false;
	    feMerge.appendChild(feMergeNode);
	}
	
	SVGDropShadowEffect.prototype.renderFrame = function(forceRender){
	    if(forceRender || this.filterManager._mdf){
	        if(forceRender || this.filterManager.effectElements[4].p._mdf){
	            this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
	        }
	        if(forceRender || this.filterManager.effectElements[0].p._mdf){
	            var col = this.filterManager.effectElements[0].p.v;
	            this.feFlood.setAttribute('flood-color',rgbToHex(Math.round(col[0]*255),Math.round(col[1]*255),Math.round(col[2]*255)));
	        }
	        if(forceRender || this.filterManager.effectElements[1].p._mdf){
	            this.feFlood.setAttribute('flood-opacity',this.filterManager.effectElements[1].p.v/255);
	        }
	        if(forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf){
	            var distance = this.filterManager.effectElements[3].p.v;
	            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
	            var x = distance * Math.cos(angle);
	            var y = distance * Math.sin(angle);
	            this.feOffset.setAttribute('dx', x);
	            this.feOffset.setAttribute('dy', y);
	        }
	        /*if(forceRender || this.filterManager.effectElements[5].p._mdf){
	            if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
	                this.feMerge.removeChild(this.feMergeNode);
	                this.originalNodeAdded = false;
	            } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
	                this.feMerge.appendChild(this.feMergeNode);
	                this.originalNodeAdded = true;
	            }
	        }*/
	    }
	};
	var _svgMatteSymbols = [];
	
	function SVGMatte3Effect(filterElem, filterManager, elem){
	    this.initialized = false;
	    this.filterManager = filterManager;
	    this.filterElem = filterElem;
	    this.elem = elem;
	    elem.matteElement = createNS('g');
	    elem.matteElement.appendChild(elem.layerElement);
	    elem.matteElement.appendChild(elem.transformedElement);
	    elem.baseElement = elem.matteElement;
	}
	
	SVGMatte3Effect.prototype.findSymbol = function(mask) {
	    var i = 0, len = _svgMatteSymbols.length;
	    while(i < len) {
	        if(_svgMatteSymbols[i] === mask) {
	            return _svgMatteSymbols[i];
	        }
	        i += 1;
	    }
	    return null;
	};
	
	SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {
	    var parentNode = mask.layerElement.parentNode;
	    if(!parentNode) {
	        return;
	    }
	    var children = parentNode.children;
	    var i = 0, len = children.length;
	    while (i < len) {
	        if (children[i] === mask.layerElement) {
	            break;
	        }
	        i += 1;
	    }
	    var nextChild;
	    if (i <= len - 2) {
	        nextChild = children[i + 1];
	    }
	    var useElem = createNS('use');
	    useElem.setAttribute('href', '#' + symbolId);
	    if(nextChild) {
	        parentNode.insertBefore(useElem, nextChild);
	    } else {
	        parentNode.appendChild(useElem);
	    }
	};
	
	SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
	    if(!this.findSymbol(mask)) {
	        var symbolId = createElementID();
	        var masker = createNS('mask');
	        masker.setAttribute('id', mask.layerId);
	        masker.setAttribute('mask-type', 'alpha');
	        _svgMatteSymbols.push(mask);
	        var defs = elem.globalData.defs;
	        defs.appendChild(masker);
	        var symbol = createNS('symbol');
	        symbol.setAttribute('id', symbolId);
	        this.replaceInParent(mask, symbolId);
	        symbol.appendChild(mask.layerElement);
	        defs.appendChild(symbol);
	        var useElem = createNS('use');
	        useElem.setAttribute('href', '#' + symbolId);
	        masker.appendChild(useElem);
	        mask.data.hd = false;
	        mask.show();
	    }
	    elem.setMatte(mask.layerId);
	};
	
	SVGMatte3Effect.prototype.initialize = function() {
	    var ind = this.filterManager.effectElements[0].p.v;
	    var elements = this.elem.comp.elements;
	    var i = 0, len = elements.length;
	    while (i < len) {
	    	if (elements[i] && elements[i].data.ind === ind) {
	    		this.setElementAsMask(this.elem, elements[i]);
	    	}
	    	i += 1;
	    }
	    this.initialized = true;
	};
	
	SVGMatte3Effect.prototype.renderFrame = function() {
		if(!this.initialized) {
			this.initialize();
		}
	};
	function SVGEffects(elem){
	    var i, len = elem.data.ef ? elem.data.ef.length : 0;
	    var filId = createElementID();
	    var fil = filtersFactory.createFilter(filId);
	    var count = 0;
	    this.filters = [];
	    var filterManager;
	    for(i=0;i<len;i+=1){
	        filterManager = null;
	        if(elem.data.ef[i].ty === 20){
	            count += 1;
	            filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);
	        }else if(elem.data.ef[i].ty === 21){
	            count += 1;
	            filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);
	        }else if(elem.data.ef[i].ty === 22){
	            filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);
	        }else if(elem.data.ef[i].ty === 23){
	            count += 1;
	            filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);
	        }else if(elem.data.ef[i].ty === 24){
	            count += 1;
	            filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);
	        }else if(elem.data.ef[i].ty === 25){
	            count += 1;
	            filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);
	        }else if(elem.data.ef[i].ty === 28){
	            //count += 1;
	            filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);
	        }else if(elem.data.ef[i].ty === 29){
	            count += 1;
	            filterManager = new SVGGaussianBlurEffect(fil, elem.effectsManager.effectElements[i]);
	        }
	        if(filterManager) {
	            this.filters.push(filterManager);
	        }
	    }
	    if(count){
	        elem.globalData.defs.appendChild(fil);
	        elem.layerElement.setAttribute('filter','url(' + locationHref + '#'+filId+')');
	    }
	    if (this.filters.length) {
	        elem.addRenderableComponent(this);
	    }
	}
	
	SVGEffects.prototype.renderFrame = function(_isFirstFrame){
	    var i, len = this.filters.length;
	    for(i=0;i<len;i+=1){
	        this.filters[i].renderFrame(_isFirstFrame);
	    }
	};
	function CVContextData() {
		this.saved = [];
	    this.cArrPos = 0;
	    this.cTr = new Matrix();
	    this.cO = 1;
	    var i, len = 15;
	    this.savedOp = createTypedArray('float32', len);
	    for(i=0;i<len;i+=1){
	        this.saved[i] = createTypedArray('float32', 16);
	    }
	    this._length = len;
	}
	
	CVContextData.prototype.duplicate = function() {
		var newLength = this._length * 2;
		var currentSavedOp = this.savedOp;
	    this.savedOp = createTypedArray('float32', newLength);
	    this.savedOp.set(currentSavedOp);
	    var i = 0;
	    for(i = this._length; i < newLength; i += 1) {
	        this.saved[i] = createTypedArray('float32', 16);
	    }
	    this._length = newLength;
	};
	
	CVContextData.prototype.reset = function() {
		this.cArrPos = 0;
		this.cTr.reset();
	    this.cO = 1;
	};
	function CVBaseElement(){
	}
	
	CVBaseElement.prototype = {
	    createElements: function(){},
	    initRendererElement: function(){},
	    createContainerElements: function(){
	        this.canvasContext = this.globalData.canvasContext;
	        this.renderableEffectsManager = new CVEffects(this);
	    },
	    createContent: function(){},
	    setBlendMode: function(){
	        var globalData = this.globalData;
	        if(globalData.blendMode !== this.data.bm) {
	            globalData.blendMode = this.data.bm;
	            var blendModeValue = getBlendMode(this.data.bm);
	            globalData.canvasContext.globalCompositeOperation = blendModeValue;
	        }
	    },
	    createRenderableComponents: function(){
	        this.maskManager = new CVMaskElement(this.data, this);
	    },
	    hideElement: function(){
	        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
	            this.hidden = true;
	        }
	    },
	    showElement: function(){
	        if (this.isInRange && !this.isTransparent){
	            this.hidden = false;
	            this._isFirstFrame = true;
	            this.maskManager._isFirstFrame = true;
	        }
	    },
	    renderFrame: function() {
	        if (this.hidden || this.data.hd) {
	            return;
	        }
	        this.renderTransform();
	        this.renderRenderable();
	        this.setBlendMode();
	        this.globalData.renderer.save();
	        this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
	        this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
	        this.renderInnerContent();
	        this.globalData.renderer.restore();
	        if(this.maskManager.hasMasks) {
	            this.globalData.renderer.restore(true);
	        }
	        if (this._isFirstFrame) {
	            this._isFirstFrame = false;
	        }
	    },
	    destroy: function(){
	        this.canvasContext = null;
	        this.data = null;
	        this.globalData = null;
	        this.maskManager.destroy();
	    },
	    mHelper: new Matrix()
	};
	CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
	CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
	
	function CVImageElement(data, globalData, comp){
	    this.failed = false;
	    this.assetData = globalData.getAssetData(data.refId);
	    this.img = globalData.imageLoader.getImage(this.assetData);
	    this.initElement(data,globalData,comp);
	}
	extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
	
	CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
	CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
	
	CVImageElement.prototype.createContent = function(){
	
	    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
	        var canvas = createTag('canvas');
	        canvas.width = this.assetData.w;
	        canvas.height = this.assetData.h;
	        var ctx = canvas.getContext('2d');
	
	        var imgW = this.img.width;
	        var imgH = this.img.height;
	        var imgRel = imgW / imgH;
	        var canvasRel = this.assetData.w/this.assetData.h;
	        var widthCrop, heightCrop;
	        var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
	        if((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {
	            heightCrop = imgH;
	            widthCrop = heightCrop*canvasRel;
	        } else {
	            widthCrop = imgW;
	            heightCrop = widthCrop/canvasRel;
	        }
	        ctx.drawImage(this.img,(imgW-widthCrop)/2,(imgH-heightCrop)/2,widthCrop,heightCrop,0,0,this.assetData.w,this.assetData.h);
	        this.img = canvas;
	    }
	
	};
	
	CVImageElement.prototype.renderInnerContent = function(parentMatrix){
	    if (this.failed) {
	        return;
	    }
	    this.canvasContext.drawImage(this.img, 0, 0);
	};
	
	CVImageElement.prototype.destroy = function(){
	    this.img = null;
	};
	function CVCompElement(data, globalData, comp) {
	    this.completeLayers = false;
	    this.layers = data.layers;
	    this.pendingElements = [];
	    this.elements = createSizedArray(this.layers.length);
	    this.initElement(data, globalData, comp);
	    this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate, this) : {_placeholder:true};
	}
	
	extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);
	
	CVCompElement.prototype.renderInnerContent = function() {
	    var i,len = this.layers.length;
	    for( i = len - 1; i >= 0; i -= 1 ){
	        if(this.completeLayers || this.elements[i]){
	            this.elements[i].renderFrame();
	        }
	    }
	};
	
	CVCompElement.prototype.destroy = function(){
	    var i,len = this.layers.length;
	    for( i = len - 1; i >= 0; i -= 1 ){
	        if(this.elements[i]) {
	            this.elements[i].destroy();
	        }
	    }
	    this.layers = null;
	    this.elements = null;
	};
	
	function CVMaskElement(data,element){
	    this.data = data;
	    this.element = element;
	    this.masksProperties = this.data.masksProperties || [];
	    this.viewData = createSizedArray(this.masksProperties.length);
	    var i, len = this.masksProperties.length, hasMasks = false;
	    for (i = 0; i < len; i++) {
	        if(this.masksProperties[i].mode !== 'n'){
	            hasMasks = true;
	        }
	        this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element,this.masksProperties[i],3);
	    }
	    this.hasMasks = hasMasks;
	    if(hasMasks) {
	        this.element.addRenderableComponent(this);
	    }
	}
	
	CVMaskElement.prototype.renderFrame = function () {
	    if(!this.hasMasks){
	        return;
	    }
	    var transform = this.element.finalTransform.mat;
	    var ctx = this.element.canvasContext;
	    var i, len = this.masksProperties.length;
	    var pt,pts,data;
	    ctx.beginPath();
	    for (i = 0; i < len; i++) {
	        if(this.masksProperties[i].mode !== 'n'){
	            if (this.masksProperties[i].inv) {
	                ctx.moveTo(0, 0);
	                ctx.lineTo(this.element.globalData.compSize.w, 0);
	                ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
	                ctx.lineTo(0, this.element.globalData.compSize.h);
	                ctx.lineTo(0, 0);
	            }
	            data = this.viewData[i].v;
	            pt = transform.applyToPointArray(data.v[0][0],data.v[0][1],0);
	            ctx.moveTo(pt[0], pt[1]);
	            var j, jLen = data._length;
	            for (j = 1; j < jLen; j++) {
	                pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
	                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
	            }
	            pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
	            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
	        }
	    }
	    this.element.globalData.renderer.save(true);
	    ctx.clip();
	};
	
	CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
	
	CVMaskElement.prototype.destroy = function(){
	    this.element = null;
	};
	function CVShapeElement(data, globalData, comp) {
	    this.shapes = [];
	    this.shapesData = data.shapes;
	    this.stylesList = [];
	    this.itemsData = [];
	    this.prevViewData = [];
	    this.shapeModifiers = [];
	    this.processedElements = [];
	    this.transformsManager = new ShapeTransformManager();
	    this.initElement(data, globalData, comp);
	}
	
	extendPrototype([BaseElement,TransformElement,CVBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableElement], CVShapeElement);
	
	CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
	
	CVShapeElement.prototype.transformHelper = {opacity:1,_opMdf:false};
	
	CVShapeElement.prototype.dashResetter = [];
	
	CVShapeElement.prototype.createContent = function(){
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData, true, []);
	};
	
	CVShapeElement.prototype.createStyleElement = function(data, transforms) {
	    var styleElem = {
	        data: data,
	        type: data.ty,
	        preTransforms: this.transformsManager.addTransformSequence(transforms),
	        transforms: [],
	        elements: [],
	        closed: data.hd === true
	    };
	    var elementData = {};
	    if(data.ty == 'fl' || data.ty == 'st'){
	        elementData.c = PropertyFactory.getProp(this,data.c,1,255,this);
	        if(!elementData.c.k){
	            styleElem.co = 'rgb('+bm_floor(elementData.c.v[0])+','+bm_floor(elementData.c.v[1])+','+bm_floor(elementData.c.v[2])+')';
	        }
	    } else if (data.ty === 'gf' || data.ty === 'gs') {
	        elementData.s = PropertyFactory.getProp(this,data.s,1,null,this);
	        elementData.e = PropertyFactory.getProp(this,data.e,1,null,this);
	        elementData.h = PropertyFactory.getProp(this,data.h||{k:0},0,0.01,this);
	        elementData.a = PropertyFactory.getProp(this,data.a||{k:0},0,degToRads,this);
	        elementData.g = new GradientProperty(this,data.g,this);
	    }
	    elementData.o = PropertyFactory.getProp(this,data.o,0,0.01,this);
	    if(data.ty == 'st' || data.ty == 'gs') {
	        styleElem.lc = this.lcEnum[data.lc] || 'round';
	        styleElem.lj = this.ljEnum[data.lj] || 'round';
	        if(data.lj == 1) {
	            styleElem.ml = data.ml;
	        }
	        elementData.w = PropertyFactory.getProp(this,data.w,0,null,this);
	        if(!elementData.w.k){
	            styleElem.wi = elementData.w.v;
	        }
	        if(data.d){
	            var d = new DashProperty(this,data.d,'canvas', this);
	            elementData.d = d;
	            if(!elementData.d.k){
	                styleElem.da = elementData.d.dashArray;
	                styleElem.do = elementData.d.dashoffset[0];
	            }
	        }
	    } else {
	        styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
	    }
	    this.stylesList.push(styleElem);
	    elementData.style = styleElem;
	    return elementData;
	};
	
	CVShapeElement.prototype.createGroupElement = function(data) {
	    var elementData = {
	        it: [],
	        prevViewData: []
	    };
	    return elementData;
	};
	
	CVShapeElement.prototype.createTransformElement = function(data) {
	    var elementData = {
	        transform : {
	            opacity: 1,
	            _opMdf:false,
	            key: this.transformsManager.getNewKey(),
	            op: PropertyFactory.getProp(this,data.o,0,0.01,this),
	            mProps: TransformPropertyFactory.getTransformProperty(this,data,this)
	        }
	    };
	    return elementData;
	};
	
	CVShapeElement.prototype.createShapeElement = function(data) {
	    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
	    
	    this.shapes.push(elementData);
	    this.addShapeToModifiers(elementData);
	    return elementData;
	};
	
	CVShapeElement.prototype.reloadShapes = function() {
	    this._isFirstFrame = true;
	    var i, len = this.itemsData.length;
	    for (i = 0; i < len; i += 1) {
	        this.prevViewData[i] = this.itemsData[i];
	    }
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData, true, []);
	    len = this.dynamicProperties.length;
	    for (i = 0; i < len; i += 1) {
	        this.dynamicProperties[i].getValue();
	    }
	    this.renderModifiers();
	    this.transformsManager.processSequences(this._isFirstFrame);
	};
	
	CVShapeElement.prototype.addTransformToStyleList = function(transform) {
	    var i, len = this.stylesList.length;
	    for (i = 0; i < len; i += 1) {
	        if(!this.stylesList[i].closed) {
	            this.stylesList[i].transforms.push(transform);
	        }
	    }
	}
	
	CVShapeElement.prototype.removeTransformFromStyleList = function() {
	    var i, len = this.stylesList.length;
	    for (i = 0; i < len; i += 1) {
	        if(!this.stylesList[i].closed) {
	            this.stylesList[i].transforms.pop();
	        }
	    }
	}
	
	CVShapeElement.prototype.closeStyles = function(styles) {
	    var i, len = styles.length, j, jLen;
	    for (i = 0; i < len; i += 1) {
	        styles[i].closed = true;
	    }
	}
	
	CVShapeElement.prototype.searchShapes = function(arr,itemsData, prevViewData, shouldRender, transforms){
	    var i, len = arr.length - 1;
	    var j, jLen;
	    var ownStyles = [], ownModifiers = [], processedPos, modifier, currentTransform;
	    var ownTransforms = [].concat(transforms);
	    for(i=len;i>=0;i-=1){
	        processedPos = this.searchProcessedElement(arr[i]);
	        if(!processedPos){
	            arr[i]._shouldRender = shouldRender;
	        } else {
	            itemsData[i] = prevViewData[processedPos - 1];
	        }
	        if(arr[i].ty == 'fl' || arr[i].ty == 'st'|| arr[i].ty == 'gf'|| arr[i].ty == 'gs'){
	            if(!processedPos){
	                itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
	            } else {
	                itemsData[i].style.closed = false;
	            }
	            
	            ownStyles.push(itemsData[i].style);
	        }else if(arr[i].ty == 'gr'){
	            if(!processedPos){
	                itemsData[i] = this.createGroupElement(arr[i]);
	            } else {
	                jLen = itemsData[i].it.length;
	                for(j=0;j<jLen;j+=1){
	                    itemsData[i].prevViewData[j] = itemsData[i].it[j];
	                }
	            }
	            this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData, shouldRender, ownTransforms);
	        }else if(arr[i].ty == 'tr'){
	            if(!processedPos){
	                currentTransform = this.createTransformElement(arr[i]);
	                itemsData[i] = currentTransform;
	            }
	            ownTransforms.push(itemsData[i]);
	            this.addTransformToStyleList(itemsData[i]);
	        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
	            if(!processedPos){
	                itemsData[i] = this.createShapeElement(arr[i]);
	            }
	            
	        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd'){
	            if(!processedPos){
	                modifier = ShapeModifiers.getModifier(arr[i].ty);
	                modifier.init(this,arr[i]);
	                itemsData[i] = modifier;
	                this.shapeModifiers.push(modifier);
	            } else {
	                modifier = itemsData[i];
	                modifier.closed = false;
	            }
	            ownModifiers.push(modifier);
	        } else if(arr[i].ty == 'rp'){
	            if(!processedPos){
	                modifier = ShapeModifiers.getModifier(arr[i].ty);
	                itemsData[i] = modifier;
	                modifier.init(this,arr,i,itemsData);
	                this.shapeModifiers.push(modifier);
	                shouldRender = false;
	            }else{
	                modifier = itemsData[i];
	                modifier.closed = true;
	            }
	            ownModifiers.push(modifier);
	        }
	        this.addProcessedElement(arr[i], i + 1);
	    }
	    this.removeTransformFromStyleList();
	    this.closeStyles(ownStyles);
	    len = ownModifiers.length;
	    for(i=0;i<len;i+=1){
	        ownModifiers[i].closed = true;
	    }
	};
	
	CVShapeElement.prototype.renderInnerContent = function() {
	    this.transformHelper.opacity = 1;
	    this.transformHelper._opMdf = false;
	    this.renderModifiers();
	    this.transformsManager.processSequences(this._isFirstFrame);
	    this.renderShape(this.transformHelper,this.shapesData,this.itemsData,true);
	};
	
	CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
	    var props, groupMatrix;
	    if(parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
	        groupTransform.opacity = parentTransform.opacity;
	        groupTransform.opacity *= groupTransform.op.v;
	        groupTransform._opMdf = true;
	    }
	};
	
	CVShapeElement.prototype.drawLayer = function() {
	    var i, len = this.stylesList.length;
	    var j, jLen, k, kLen,elems,nodes, renderer = this.globalData.renderer, ctx = this.globalData.canvasContext, type, currentStyle;
	    for(i=0;i<len;i+=1){
	        currentStyle = this.stylesList[i];
	        type = currentStyle.type;
	
	        //Skipping style when
	        //Stroke width equals 0
	        //style should not be rendered (extra unused repeaters)
	        //current opacity equals 0
	        //global opacity equals 0
	        if(((type === 'st' || type === 'gs') && currentStyle.wi === 0) || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0){
	            continue;
	        }
	        renderer.save();
	        elems = currentStyle.elements;
	        if(type === 'st' || type === 'gs'){
	            ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
	            ctx.lineWidth = currentStyle.wi;
	            ctx.lineCap = currentStyle.lc;
	            ctx.lineJoin = currentStyle.lj;
	            ctx.miterLimit = currentStyle.ml || 0;
	        } else {
	            ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
	        }
	        renderer.ctxOpacity(currentStyle.coOp);
	        if(type !== 'st' && type !== 'gs'){
	            ctx.beginPath();
	        }
	        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
	        jLen = elems.length;
	        for(j=0;j<jLen;j+=1){
	            if(type === 'st' || type === 'gs'){
	                ctx.beginPath();
	                if(currentStyle.da){
	                    ctx.setLineDash(currentStyle.da);
	                    ctx.lineDashOffset = currentStyle.do;
	                }
	            }
	            nodes = elems[j].trNodes;
	            kLen = nodes.length;
	
	            for(k=0;k<kLen;k+=1){
	                if(nodes[k].t == 'm'){
	                    ctx.moveTo(nodes[k].p[0],nodes[k].p[1]);
	                }else if(nodes[k].t == 'c'){
	                    ctx.bezierCurveTo(nodes[k].pts[0],nodes[k].pts[1],nodes[k].pts[2],nodes[k].pts[3],nodes[k].pts[4],nodes[k].pts[5]);
	                }else{
	                    ctx.closePath();
	                }
	            }
	            if(type === 'st' || type === 'gs'){
	                ctx.stroke();
	                if(currentStyle.da){
	                    ctx.setLineDash(this.dashResetter);
	                }
	            }
	        }
	        if(type !== 'st' && type !== 'gs'){
	            ctx.fill(currentStyle.r);
	        }
	        renderer.restore();
	    }
	};
	
	CVShapeElement.prototype.renderShape = function(parentTransform,items,data,isMain){
	    var i, len = items.length - 1;
	    var groupTransform;
	    groupTransform = parentTransform;
	    for(i=len;i>=0;i-=1){
	        if(items[i].ty == 'tr'){
	            groupTransform = data[i].transform;
	            this.renderShapeTransform(parentTransform, groupTransform);
	        }else if(items[i].ty == 'sh' || items[i].ty == 'el' || items[i].ty == 'rc' || items[i].ty == 'sr'){
	            this.renderPath(items[i],data[i]);
	        }else if(items[i].ty == 'fl'){
	            this.renderFill(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'st'){
	            this.renderStroke(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'gf' || items[i].ty == 'gs'){
	            this.renderGradientFill(items[i],data[i],groupTransform);
	        }else if(items[i].ty == 'gr'){
	            this.renderShape(groupTransform,items[i].it,data[i].it);
	        }else if(items[i].ty == 'tm'){
	            //
	        }
	    }
	    if(isMain){
	        this.drawLayer();
	    }
	    
	};
	
	CVShapeElement.prototype.renderStyledShape = function(styledShape, shape){
	    if(this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
	        var shapeNodes = styledShape.trNodes;
	        var paths = shape.paths;
	        var i, len, j, jLen = paths._length;
	        shapeNodes.length = 0;
	        var groupTransformMat = styledShape.transforms.finalTransform;
	        for (j = 0; j < jLen; j += 1) {
	            var pathNodes = paths.shapes[j];
	            if(pathNodes && pathNodes.v){
	                len = pathNodes._length;
	                for (i = 1; i < len; i += 1) {
	                    if (i === 1) {
	                        shapeNodes.push({
	                            t: 'm',
	                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                        });
	                    }
	                    shapeNodes.push({
	                        t: 'c',
	                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
	                    });
	                }
	                if (len === 1) {
	                    shapeNodes.push({
	                        t: 'm',
	                        p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
	                    });
	                }
	                if (pathNodes.c && len) {
	                    shapeNodes.push({
	                        t: 'c',
	                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
	                    });
	                    shapeNodes.push({
	                        t: 'z'
	                    });
	                }
	            }
	        }
	        styledShape.trNodes = shapeNodes;
	    }
	}
	
	CVShapeElement.prototype.renderPath = function(pathData,itemData){
	    if(pathData.hd !== true && pathData._shouldRender) {
	        var i, len = itemData.styledShapes.length;
	        for (i = 0; i < len; i += 1) {
	            this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
	        }
	    }
	};
	
	CVShapeElement.prototype.renderFill = function(styleData,itemData, groupTransform){
	    var styleElem = itemData.style;
	
	    if (itemData.c._mdf || this._isFirstFrame) {
	        styleElem.co = 'rgb(' 
	        + bm_floor(itemData.c.v[0]) + ',' 
	        + bm_floor(itemData.c.v[1]) + ',' 
	        + bm_floor(itemData.c.v[2]) + ')';
	    }
	    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
	        styleElem.coOp = itemData.o.v * groupTransform.opacity;
	    }
	};
	
	CVShapeElement.prototype.renderGradientFill = function(styleData,itemData, groupTransform){
	    var styleElem = itemData.style;
	    if(!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))) {
	        var ctx = this.globalData.canvasContext;
	        var grd;
	        var pt1 = itemData.s.v, pt2 = itemData.e.v;
	        if (styleData.t === 1) {
	            grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
	        } else {
	            var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
	            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
	
	            var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99: itemData.h.v;
	            var dist = rad * percent;
	            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
	            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
	            var grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
	        }
	
	        var i, len = styleData.g.p;
	        var cValues = itemData.g.c;
	        var opacity = 1;
	
	        for (i = 0; i < len; i += 1){
	            if(itemData.g._hasOpacity && itemData.g._collapsable) {
	                opacity = itemData.g.o[i*2 + 1];
	            }
	            grd.addColorStop(cValues[i * 4] / 100,'rgba('+ cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ','+cValues[i * 4 + 3] + ',' + opacity + ')');
	        }
	        styleElem.grd = grd;
	    }
	    styleElem.coOp = itemData.o.v*groupTransform.opacity;
	    
	};
	
	CVShapeElement.prototype.renderStroke = function(styleData,itemData, groupTransform){
	    var styleElem = itemData.style;
	    var d = itemData.d;
	    if(d && (d._mdf  || this._isFirstFrame)){
	        styleElem.da = d.dashArray;
	        styleElem.do = d.dashoffset[0];
	    }
	    if(itemData.c._mdf || this._isFirstFrame){
	        styleElem.co = 'rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')';
	    }
	    if(itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame){
	        styleElem.coOp = itemData.o.v*groupTransform.opacity;
	    }
	    if(itemData.w._mdf || this._isFirstFrame){
	        styleElem.wi = itemData.w.v;
	    }
	};
	
	
	CVShapeElement.prototype.destroy = function(){
	    this.shapesData = null;
	    this.globalData = null;
	    this.canvasContext = null;
	    this.stylesList.length = 0;
	    this.itemsData.length = 0;
	};
	
	
	function CVSolidElement(data, globalData, comp) {
	    this.initElement(data,globalData,comp);
	}
	extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
	
	CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
	CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
	
	CVSolidElement.prototype.renderInnerContent = function() {
	    var ctx = this.canvasContext;
	    ctx.fillStyle = this.data.sc;
	    ctx.fillRect(0, 0, this.data.sw, this.data.sh);
	    //
	};
	function CVTextElement(data, globalData, comp){
	    this.textSpans = [];
	    this.yOffset = 0;
	    this.fillColorAnim = false;
	    this.strokeColorAnim = false;
	    this.strokeWidthAnim = false;
	    this.stroke = false;
	    this.fill = false;
	    this.justifyOffset = 0;
	    this.currentRender = null;
	    this.renderType = 'canvas';
	    this.values = {
	        fill: 'rgba(0,0,0,0)',
	        stroke: 'rgba(0,0,0,0)',
	        sWidth: 0,
	        fValue: ''
	    };
	    this.initElement(data,globalData,comp);
	}
	extendPrototype([BaseElement,TransformElement,CVBaseElement,HierarchyElement,FrameElement,RenderableElement,ITextElement], CVTextElement);
	
	CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');
	
	CVTextElement.prototype.buildNewText = function(){
	    var documentData = this.textProperty.currentData;
	    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
	
	    var hasFill = false;
	    if(documentData.fc) {
	        hasFill = true;
	        this.values.fill = this.buildColor(documentData.fc);
	    }else{
	        this.values.fill = 'rgba(0,0,0,0)';
	    }
	    this.fill = hasFill;
	    var hasStroke = false;
	    if(documentData.sc){
	        hasStroke = true;
	        this.values.stroke = this.buildColor(documentData.sc);
	        this.values.sWidth = documentData.sw;
	    }
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    var i, len;
	    var letters = documentData.l;
	    var matrixHelper = this.mHelper;
	    this.stroke = hasStroke;
	    this.values.fValue = documentData.finalSize + 'px '+ this.globalData.fontManager.getFontByName(documentData.f).fFamily;
	    len = documentData.finalText.length;
	    //this.tHelper.font = this.values.fValue;
	    var charData, shapeData, k, kLen, shapes, j, jLen, pathNodes, commands, pathArr, singleShape = this.data.singleShape;
	    var trackingOffset = documentData.tr/1000*documentData.finalSize;
	    var xPos = 0, yPos = 0, firstLine = true;
	    var cnt = 0;
	    for (i = 0; i < len; i += 1) {
	        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	        shapeData = charData && charData.data || {};
	        matrixHelper.reset();
	        if(singleShape && letters[i].n) {
	            xPos = -trackingOffset;
	            yPos += documentData.yOffset;
	            yPos += firstLine ? 1 : 0;
	            firstLine = false;
	        }
	
	        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
	        jLen = shapes.length;
	        matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);
	        if(singleShape){
	            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
	        }
	        commands = createSizedArray(jLen);
	        for(j=0;j<jLen;j+=1){
	            kLen = shapes[j].ks.k.i.length;
	            pathNodes = shapes[j].ks.k;
	            pathArr = [];
	            for(k=1;k<kLen;k+=1){
	                if(k==1){
	                    pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
	                }
	                pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToY(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToX(pathNodes.v[k][0],pathNodes.v[k][1],0),matrixHelper.applyToY(pathNodes.v[k][0],pathNodes.v[k][1],0));
	            }
	            pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToY(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
	            commands[j] = pathArr;
	        }
	        if(singleShape){
	            xPos += letters[i].l;
	            xPos += trackingOffset;
	        }
	        if(this.textSpans[cnt]){
	            this.textSpans[cnt].elem = commands;
	        } else {
	            this.textSpans[cnt] = {elem: commands};
	        }
	        cnt +=1;
	    }
	};
	
	CVTextElement.prototype.renderInnerContent = function(){
	    var ctx = this.canvasContext;
	    var finalMat = this.finalTransform.mat.props;
	    ctx.font = this.values.fValue;
	    ctx.lineCap = 'butt';
	    ctx.lineJoin = 'miter';
	    ctx.miterLimit = 4;
	
	    if(!this.data.singleShape){
	        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	    }
	
	    var  i,len, j, jLen, k, kLen;
	    var renderedLetters = this.textAnimator.renderedLetters;
	
	    var letters = this.textProperty.currentData.l;
	
	    len = letters.length;
	    var renderedLetter;
	    var lastFill = null, lastStroke = null, lastStrokeW = null, commands, pathArr;
	    for(i=0;i<len;i+=1){
	        if(letters[i].n){
	            continue;
	        }
	        renderedLetter = renderedLetters[i];
	        if(renderedLetter){
	            this.globalData.renderer.save();
	            this.globalData.renderer.ctxTransform(renderedLetter.p);
	            this.globalData.renderer.ctxOpacity(renderedLetter.o);
	        }
	        if(this.fill){
	            if(renderedLetter && renderedLetter.fc){
	                if(lastFill !== renderedLetter.fc){
	                    lastFill = renderedLetter.fc;
	                    ctx.fillStyle = renderedLetter.fc;
	                }
	            }else if(lastFill !== this.values.fill){
	                lastFill = this.values.fill;
	                ctx.fillStyle = this.values.fill;
	            }
	            commands = this.textSpans[i].elem;
	            jLen = commands.length;
	            this.globalData.canvasContext.beginPath();
	            for(j=0;j<jLen;j+=1) {
	                pathArr = commands[j];
	                kLen = pathArr.length;
	                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	                for (k = 2; k < kLen; k += 6) {
	                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	                }
	            }
	            this.globalData.canvasContext.closePath();
	            this.globalData.canvasContext.fill();
	            ///ctx.fillText(this.textSpans[i].val,0,0);
	        }
	        if(this.stroke){
	            if(renderedLetter && renderedLetter.sw){
	                if(lastStrokeW !== renderedLetter.sw){
	                    lastStrokeW = renderedLetter.sw;
	                    ctx.lineWidth = renderedLetter.sw;
	                }
	            }else if(lastStrokeW !== this.values.sWidth){
	                lastStrokeW = this.values.sWidth;
	                ctx.lineWidth = this.values.sWidth;
	            }
	            if(renderedLetter && renderedLetter.sc){
	                if(lastStroke !== renderedLetter.sc){
	                    lastStroke = renderedLetter.sc;
	                    ctx.strokeStyle = renderedLetter.sc;
	                }
	            }else if(lastStroke !== this.values.stroke){
	                lastStroke = this.values.stroke;
	                ctx.strokeStyle = this.values.stroke;
	            }
	            commands = this.textSpans[i].elem;
	            jLen = commands.length;
	            this.globalData.canvasContext.beginPath();
	            for(j=0;j<jLen;j+=1) {
	                pathArr = commands[j];
	                kLen = pathArr.length;
	                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
	                for (k = 2; k < kLen; k += 6) {
	                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
	                }
	            }
	            this.globalData.canvasContext.closePath();
	            this.globalData.canvasContext.stroke();
	            ///ctx.strokeText(letters[i].val,0,0);
	        }
	        if(renderedLetter) {
	            this.globalData.renderer.restore();
	        }
	    }
	};
	function CVEffects() {
	
	}
	CVEffects.prototype.renderFrame = function(){};
	function HBaseElement(data,globalData,comp){}
	HBaseElement.prototype = {
	    checkBlendMode: function(){},
	    initRendererElement: function(){
	        this.baseElement = createTag(this.data.tg || 'div');
	        if(this.data.hasMask) {
	            this.svgElement = createNS('svg');
	            this.layerElement = createNS('g');
	            this.maskedElement = this.layerElement;
	            this.svgElement.appendChild(this.layerElement);
	            this.baseElement.appendChild(this.svgElement);
	        } else {
	            this.layerElement = this.baseElement;
	        }
	        styleDiv(this.baseElement);
	    },
	    createContainerElements: function(){
	        this.renderableEffectsManager = new CVEffects(this);
	        this.transformedElement = this.baseElement;
	        this.maskedElement = this.layerElement;
	        if (this.data.ln) {
	            this.layerElement.setAttribute('id',this.data.ln);
	        }
	        if (this.data.cl) {
	            this.layerElement.setAttribute('class', this.data.cl);
	        }
	        if (this.data.bm !== 0) {
	            this.setBlendMode();
	        }
	    },
	    renderElement: function() {
	        if(this.finalTransform._matMdf){
	            this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = this.finalTransform.mat.toCSS();
	        }
	        if(this.finalTransform._opMdf){
	            this.transformedElement.style.opacity = this.finalTransform.mProp.o.v;
	        }
	    },
	    renderFrame: function() {
	        //If it is exported as hidden (data.hd === true) no need to render
	        //If it is not visible no need to render
	        if (this.data.hd || this.hidden) {
	            return;
	        }
	        this.renderTransform();
	        this.renderRenderable();
	        this.renderElement();
	        this.renderInnerContent();
	        if (this._isFirstFrame) {
	            this._isFirstFrame = false;
	        }
	    },
	    destroy: function(){
	        this.layerElement = null;
	        this.transformedElement = null;
	        if(this.matteElement) {
	            this.matteElement = null;
	        }
	        if(this.maskManager) {
	            this.maskManager.destroy();
	            this.maskManager = null;
	        }
	    },
	    createRenderableComponents: function(){
	        this.maskManager = new MaskElement(this.data, this, this.globalData);
	    },
	    addEffects: function(){
	    },
	    setMatte: function(){}
	};
	HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
	HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
	HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;
	function HSolidElement(data,globalData,comp){
	    this.initElement(data,globalData,comp);
	}
	extendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement], HSolidElement);
	
	HSolidElement.prototype.createContent = function(){
	    var rect;
	    if(this.data.hasMask){
	        rect = createNS('rect');
	        rect.setAttribute('width',this.data.sw);
	        rect.setAttribute('height',this.data.sh);
	        rect.setAttribute('fill',this.data.sc);
	        this.svgElement.setAttribute('width',this.data.sw);
	        this.svgElement.setAttribute('height',this.data.sh);
	    } else {
	        rect = createTag('div');
	        rect.style.width = this.data.sw + 'px';
	        rect.style.height = this.data.sh + 'px';
	        rect.style.backgroundColor = this.data.sc;
	    }
	    this.layerElement.appendChild(rect);
	};
	
	function HCompElement(data,globalData,comp){
	    this.layers = data.layers;
	    this.supports3d = !data.hasMask;
	    this.completeLayers = false;
	    this.pendingElements = [];
	    this.elements = this.layers ? createSizedArray(this.layers.length) : [];
	    this.initElement(data,globalData,comp);
	    this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this) : {_placeholder:true};
	}
	
	extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);
	HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
	
	HCompElement.prototype.createContainerElements = function(){
	    this._createBaseContainerElements();
	    //divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
	    if(this.data.hasMask){
	        this.svgElement.setAttribute('width',this.data.w);
	        this.svgElement.setAttribute('height',this.data.h);
	        this.transformedElement = this.baseElement;
	    } else {
	        this.transformedElement = this.layerElement;
	    }
	};
	
	HCompElement.prototype.addTo3dContainer = function(elem,pos) {
	    var j = 0;
	    var nextElement;
	    while(j<pos){
	        if(this.elements[j] && this.elements[j].getBaseElement){
	            nextElement = this.elements[j].getBaseElement();
	        }
	        j += 1;
	    }
	    if(nextElement){
	        this.layerElement.insertBefore(elem, nextElement);
	    } else {
	        this.layerElement.appendChild(elem);
	    }
	}
	
	function HShapeElement(data,globalData,comp){
	    //List of drawable elements
	    this.shapes = [];
	    // Full shape data
	    this.shapesData = data.shapes;
	    //List of styles that will be applied to shapes
	    this.stylesList = [];
	    //List of modifiers that will be applied to shapes
	    this.shapeModifiers = [];
	    //List of items in shape tree
	    this.itemsData = [];
	    //List of items in previous shape tree
	    this.processedElements = [];
	    // List of animated components
	    this.animatedContents = [];
	    this.shapesContainer = createNS('g');
	    this.initElement(data,globalData,comp);
	    //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
	    // List of elements that have been created
	    this.prevViewData = [];
	    this.currentBBox = {
	        x:999999,
	        y: -999999,
	        h: 0,
	        w: 0
	    };
	}
	extendPrototype([BaseElement,TransformElement,HSolidElement,SVGShapeElement,HBaseElement,HierarchyElement,FrameElement,RenderableElement], HShapeElement);
	HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
	
	HShapeElement.prototype.createContent = function(){
	    var cont;
	    this.baseElement.style.fontSize = 0;
	    if (this.data.hasMask) {
	        this.layerElement.appendChild(this.shapesContainer);
	        cont = this.svgElement;
	    } else {
	        cont = createNS('svg');
	        var size = this.comp.data ? this.comp.data : this.globalData.compSize;
	        cont.setAttribute('width',size.w);
	        cont.setAttribute('height',size.h);
	        cont.appendChild(this.shapesContainer);
	        this.layerElement.appendChild(cont);
	    }
	
	    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.shapesContainer,0, [], true);
	    this.filterUniqueShapes();
	    this.shapeCont = cont;
	};
	
	HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
	    var i, len = transformers.length;
	    for(i = 0; i < len; i += 1) {
	        point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
	    }
	    return point;
	}
	
	HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
	    var shape = item.sh.v;
	    var transformers = item.transformers;
	    var i, len = shape._length, vPoint, oPoint, nextIPoint, nextVPoint, bounds;
	    if (len <= 1) {
	        return;
	    }
	    for (i = 0; i < len - 1; i += 1) {
	        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
	        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
	        nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
	        nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
	        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
	    }
	    if(shape.c) {
	        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
	        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
	        nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
	        nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
	        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
	    }
	}
	
	HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
	    this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
	    var bounds = this.shapeBoundingBox;
	    boundingBox.x = bm_min(bounds.left, boundingBox.x);
	    boundingBox.xMax = bm_max(bounds.right, boundingBox.xMax);
	    boundingBox.y = bm_min(bounds.top, boundingBox.y);
	    boundingBox.yMax = bm_max(bounds.bottom, boundingBox.yMax);
	}
	
	HShapeElement.prototype.shapeBoundingBox = {
	    left:0,
	    right:0,
	    top:0,
	    bottom:0,
	}
	
	HShapeElement.prototype.tempBoundingBox = {
	    x:0,
	    xMax:0,
	    y:0,
	    yMax:0,
	    width:0,
	    height:0
	}
	
	HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
	
	    var bounds = [[p0[0],p3[0]], [p0[1],p3[1]]];
	
	    for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
	
	      b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
	      a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
	      c = 3 * p1[i] - 3 * p0[i];
	
	      b = b | 0;
	      a = a | 0;
	      c = c | 0;
	
	      if (a === 0) {
	
	        if (b === 0) {
	          continue;
	        }
	
	        t = -c / b;
	
	        if (0 < t && t < 1) {
	          bounds[i].push(this.calculateF(t,p0,p1,p2,p3,i));
	        }
	        continue;
	      }
	
	      b2ac = b * b - 4 * c * a;
	
	      if (b2ac < 0) {
	        continue;
	      }
	
	      t1 = (-b + bm_sqrt(b2ac))/(2 * a);
	      if (0 < t1 && t1 < 1) bounds[i].push(this.calculateF(t1,p0,p1,p2,p3,i));
	
	      t2 = (-b - bm_sqrt(b2ac))/(2 * a);
	      if (0 < t2 && t2 < 1) bounds[i].push(this.calculateF(t2,p0,p1,p2,p3,i));
	
	    }
	
	    this.shapeBoundingBox.left = bm_min.apply(null, bounds[0]);
	    this.shapeBoundingBox.top = bm_min.apply(null, bounds[1]);
	    this.shapeBoundingBox.right = bm_max.apply(null, bounds[0]);
	    this.shapeBoundingBox.bottom = bm_max.apply(null, bounds[1]);
	  };
	
	  HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {
	    return bm_pow(1-t, 3) * p0[i]
	        + 3 * bm_pow(1-t, 2) * t * p1[i]
	        + 3 * (1-t) * bm_pow(t, 2) * p2[i]
	        + bm_pow(t, 3) * p3[i];
	  }
	
	HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
	    var i, len = itemsData.length, path;
	    for(i = 0; i < len; i += 1) {
	        if(itemsData[i] && itemsData[i].sh) {
	            this.calculateShapeBoundingBox(itemsData[i], boundingBox)
	        } else if(itemsData[i] && itemsData[i].it) {
	            this.calculateBoundingBox(itemsData[i].it, boundingBox)
	        }
	    }
	}
	
	HShapeElement.prototype.currentBoxContains = function(box) {
	    return this.currentBBox.x <= box.x 
	    && this.currentBBox.y <= box.y 
	    && this.currentBBox.width + this.currentBBox.x >= box.x + box.width
	    && this.currentBBox.height + this.currentBBox.y >= box.y + box.height
	}
	
	HShapeElement.prototype.renderInnerContent = function() {
	    this._renderShapeFrame();
	
	    if(!this.hidden && (this._isFirstFrame || this._mdf)) {
	        var tempBoundingBox = this.tempBoundingBox;
	        var max = 999999;
	        tempBoundingBox.x = max;
	        tempBoundingBox.xMax = -max;
	        tempBoundingBox.y = max;
	        tempBoundingBox.yMax = -max;
	        this.calculateBoundingBox(this.itemsData, tempBoundingBox);
	        tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
	        tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
	        //var tempBoundingBox = this.shapeCont.getBBox();
	        if(this.currentBoxContains(tempBoundingBox)) {
	            return;
	        }
	        var changed = false;
	        if(this.currentBBox.w !== tempBoundingBox.width){
	            this.currentBBox.w = tempBoundingBox.width;
	            this.shapeCont.setAttribute('width',tempBoundingBox.width);
	            changed = true;
	        }
	        if(this.currentBBox.h !== tempBoundingBox.height){
	            this.currentBBox.h = tempBoundingBox.height;
	            this.shapeCont.setAttribute('height',tempBoundingBox.height);
	            changed = true;
	        }
	        if(changed  || this.currentBBox.x !== tempBoundingBox.x  || this.currentBBox.y !== tempBoundingBox.y){
	            this.currentBBox.w = tempBoundingBox.width;
	            this.currentBBox.h = tempBoundingBox.height;
	            this.currentBBox.x = tempBoundingBox.x;
	            this.currentBBox.y = tempBoundingBox.y;
	
	            this.shapeCont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
	            this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	        }
	    }
	
	};
	function HTextElement(data,globalData,comp){
	    this.textSpans = [];
	    this.textPaths = [];
	    this.currentBBox = {
	        x:999999,
	        y: -999999,
	        h: 0,
	        w: 0
	    };
	    this.renderType = 'svg';
	    this.isMasked = false;
	    this.initElement(data,globalData,comp);
	
	}
	extendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement], HTextElement);
	
	HTextElement.prototype.createContent = function(){
	    this.isMasked = this.checkMasks();
	    if(this.isMasked){
	        this.renderType = 'svg';
	        this.compW = this.comp.data.w;
	        this.compH = this.comp.data.h;
	        this.svgElement.setAttribute('width',this.compW);
	        this.svgElement.setAttribute('height',this.compH);
	        var g = createNS('g');
	        this.maskedElement.appendChild(g);
	        this.innerElem = g;
	    } else {
	        this.renderType = 'html';
	        this.innerElem = this.layerElement;
	    }
	
	    this.checkParenting();
	
	};
	
	HTextElement.prototype.buildNewText = function(){
	    var documentData = this.textProperty.currentData;
	    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
	    var innerElemStyle = this.innerElem.style;
	    innerElemStyle.color = innerElemStyle.fill = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
	    if(documentData.sc){
	        innerElemStyle.stroke = this.buildColor(documentData.sc);
	        innerElemStyle.strokeWidth = documentData.sw+'px';
	    }
	    var fontData = this.globalData.fontManager.getFontByName(documentData.f);
	    if(!this.globalData.fontManager.chars){
	        innerElemStyle.fontSize = documentData.finalSize+'px';
	        innerElemStyle.lineHeight = documentData.finalSize+'px';
	        if(fontData.fClass){
	            this.innerElem.className = fontData.fClass;
	        } else {
	            innerElemStyle.fontFamily = fontData.fFamily;
	            var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
	            innerElemStyle.fontStyle = fStyle;
	            innerElemStyle.fontWeight = fWeight;
	        }
	    }
	    var i, len;
	
	    var letters = documentData.l;
	    len = letters.length;
	    var tSpan,tParent,tCont;
	    var matrixHelper = this.mHelper;
	    var shapes, shapeStr = '';
	    var cnt = 0;
	    for (i = 0;i < len ;i += 1) {
	        if(this.globalData.fontManager.chars){
	            if(!this.textPaths[cnt]){
	                tSpan = createNS('path');
	                tSpan.setAttribute('stroke-linecap', 'butt');
	                tSpan.setAttribute('stroke-linejoin','round');
	                tSpan.setAttribute('stroke-miterlimit','4');
	            } else {
	                tSpan = this.textPaths[cnt];
	            }
	            if(!this.isMasked){
	                if(this.textSpans[cnt]){
	                    tParent = this.textSpans[cnt];
	                    tCont = tParent.children[0];
	                } else {
	
	                    tParent = createTag('div');
	                    tParent.style.lineHeight = 0;
	                    tCont = createNS('svg');
	                    tCont.appendChild(tSpan);
	                    styleDiv(tParent);
	                }
	            }
	        }else{
	            if(!this.isMasked){
	                if(this.textSpans[cnt]){
	                    tParent = this.textSpans[cnt];
	                    tSpan = this.textPaths[cnt];
	                } else {
	                    tParent = createTag('span');
	                    styleDiv(tParent);
	                    tSpan = createTag('span');
	                    styleDiv(tSpan);
	                    tParent.appendChild(tSpan);
	                }
	            } else {
	                tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
	            }
	        }
	        //tSpan.setAttribute('visibility', 'hidden');
	        if(this.globalData.fontManager.chars){
	            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
	            var shapeData;
	            if(charData){
	                shapeData = charData.data;
	            } else {
	                shapeData = null;
	            }
	            matrixHelper.reset();
	            if(shapeData && shapeData.shapes){
	                shapes = shapeData.shapes[0].it;
	                matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);
	                shapeStr = this.createPathShape(matrixHelper,shapes);
	                tSpan.setAttribute('d',shapeStr);
	            }
	            if(!this.isMasked){
	                this.innerElem.appendChild(tParent);
	                if(shapeData && shapeData.shapes){
	
	                    //document.body.appendChild is needed to get exact measure of shape
	                    document.body.appendChild(tCont);
	                    var boundingBox = tCont.getBBox();
	                    tCont.setAttribute('width',boundingBox.width + 2);
	                    tCont.setAttribute('height',boundingBox.height + 2);
	                    tCont.setAttribute('viewBox',(boundingBox.x-1)+' '+ (boundingBox.y-1)+' '+ (boundingBox.width+2)+' '+ (boundingBox.height+2));
	                    tCont.style.transform = tCont.style.webkitTransform = 'translate(' + (boundingBox.x-1) + 'px,' + (boundingBox.y-1) + 'px)';
	
	                    letters[i].yOffset = boundingBox.y-1;
	
	                } else{
	                    tCont.setAttribute('width',1);
	                    tCont.setAttribute('height',1);
	                }
	                    tParent.appendChild(tCont);
	            }else{
	                this.innerElem.appendChild(tSpan);
	            }
	        }else{
	            tSpan.textContent = letters[i].val;
	            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
	            if(!this.isMasked){
	                this.innerElem.appendChild(tParent);
	                //
	                tSpan.style.transform = tSpan.style.webkitTransform = 'translate3d(0,'+ -documentData.finalSize/1.2+'px,0)';
	            } else {
	                this.innerElem.appendChild(tSpan);
	            }
	        }
	        //
	        if(!this.isMasked){
	            this.textSpans[cnt] = tParent;
	        }else{
	            this.textSpans[cnt] = tSpan;
	        }
	        this.textSpans[cnt].style.display = 'block';
	        this.textPaths[cnt] = tSpan;
	        cnt += 1;
	    }
	    while(cnt < this.textSpans.length){
	        this.textSpans[cnt].style.display = 'none';
	        cnt += 1;
	    }
	};
	
	HTextElement.prototype.renderInnerContent = function() {
	
	    if(this.data.singleShape){
	        if(!this._isFirstFrame && !this.lettersChangedFlag){
	            return;
	        } else {
	            // Todo Benchmark if using this is better than getBBox
	             if(this.isMasked && this.finalTransform._matMdf){
	                 this.svgElement.setAttribute('viewBox',-this.finalTransform.mProp.p.v[0]+' '+ -this.finalTransform.mProp.p.v[1]+' '+this.compW+' '+this.compH);
	                this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
	             }
	        }
	    }
	
	    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
	    if(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag){
	        return;
	    }
	    var  i,len, count = 0;
	    var renderedLetters = this.textAnimator.renderedLetters;
	
	    var letters = this.textProperty.currentData.l;
	
	    len = letters.length;
	    var renderedLetter, textSpan, textPath;
	    for(i=0;i<len;i+=1){
	        if(letters[i].n){
	            count += 1;
	            continue;
	        }
	        textSpan = this.textSpans[i];
	        textPath = this.textPaths[i];
	        renderedLetter = renderedLetters[count];
	        count += 1;
	        if(renderedLetter._mdf.m) {
	            if(!this.isMasked){
	                textSpan.style.transform = textSpan.style.webkitTransform = renderedLetter.m;
	            }else{
	                textSpan.setAttribute('transform',renderedLetter.m);
	            }
	        }
	        ////textSpan.setAttribute('opacity',renderedLetter.o);
	        textSpan.style.opacity = renderedLetter.o;
	        if(renderedLetter.sw && renderedLetter._mdf.sw){
	            textPath.setAttribute('stroke-width',renderedLetter.sw);
	        }
	        if(renderedLetter.sc && renderedLetter._mdf.sc){
	            textPath.setAttribute('stroke',renderedLetter.sc);
	        }
	        if(renderedLetter.fc && renderedLetter._mdf.fc){
	            textPath.setAttribute('fill',renderedLetter.fc);
	            textPath.style.color = renderedLetter.fc;
	        }
	    }
	
	    if(this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)){
	        var boundingBox = this.innerElem.getBBox();
	
	        if(this.currentBBox.w !== boundingBox.width){
	            this.currentBBox.w = boundingBox.width;
	            this.svgElement.setAttribute('width',boundingBox.width);
	        }
	        if(this.currentBBox.h !== boundingBox.height){
	            this.currentBBox.h = boundingBox.height;
	            this.svgElement.setAttribute('height',boundingBox.height);
	        }
	
	        var margin = 1;
	        if(this.currentBBox.w !== (boundingBox.width + margin*2) || this.currentBBox.h !== (boundingBox.height + margin*2)  || this.currentBBox.x !== (boundingBox.x - margin)  || this.currentBBox.y !== (boundingBox.y - margin)){
	            this.currentBBox.w = boundingBox.width + margin*2;
	            this.currentBBox.h = boundingBox.height + margin*2;
	            this.currentBBox.x = boundingBox.x - margin;
	            this.currentBBox.y = boundingBox.y - margin;
	
	            this.svgElement.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
	            this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
	        }
	    }
	};
	function HImageElement(data,globalData,comp){
	    this.assetData = globalData.getAssetData(data.refId);
	    this.initElement(data,globalData,comp);
	}
	
	extendPrototype([BaseElement,TransformElement,HBaseElement,HSolidElement,HierarchyElement,FrameElement,RenderableElement], HImageElement);
	
	
	HImageElement.prototype.createContent = function(){
	    var assetPath = this.globalData.getAssetsPath(this.assetData);
	    var img = new Image();
	
	    if(this.data.hasMask){
	        this.imageElem = createNS('image');
	        this.imageElem.setAttribute('width',this.assetData.w+"px");
	        this.imageElem.setAttribute('height',this.assetData.h+"px");
	        this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
	        this.layerElement.appendChild(this.imageElem);
	        this.baseElement.setAttribute('width',this.assetData.w);
	        this.baseElement.setAttribute('height',this.assetData.h);
	    } else {
	        this.layerElement.appendChild(img);
	    }
	    img.src = assetPath;
	    if(this.data.ln){
	        this.baseElement.setAttribute('id',this.data.ln);
	    }
	};
	function HCameraElement(data,globalData,comp){
	    this.initFrame();
	    this.initBaseData(data,globalData,comp);
	    this.initHierarchy();
	    var getProp = PropertyFactory.getProp;
	    this.pe = getProp(this,data.pe,0,0,this);
	    if(data.ks.p.s){
	        this.px = getProp(this,data.ks.p.x,1,0,this);
	        this.py = getProp(this,data.ks.p.y,1,0,this);
	        this.pz = getProp(this,data.ks.p.z,1,0,this);
	    }else{
	        this.p = getProp(this,data.ks.p,1,0,this);
	    }
	    if(data.ks.a){
	        this.a = getProp(this,data.ks.a,1,0,this);
	    }
	    if(data.ks.or.k.length && data.ks.or.k[0].to){
	        var i,len = data.ks.or.k.length;
	        for(i=0;i<len;i+=1){
	            data.ks.or.k[i].to = null;
	            data.ks.or.k[i].ti = null;
	        }
	    }
	    this.or = getProp(this,data.ks.or,1,degToRads,this);
	    this.or.sh = true;
	    this.rx = getProp(this,data.ks.rx,0,degToRads,this);
	    this.ry = getProp(this,data.ks.ry,0,degToRads,this);
	    this.rz = getProp(this,data.ks.rz,0,degToRads,this);
	    this.mat = new Matrix();
	    this._prevMat = new Matrix();
	    this._isFirstFrame = true;
	    
	    // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
	    this.finalTransform = {
	        mProp: this
	    };
	}
	extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
	
	HCameraElement.prototype.setup = function() {
	    var i, len = this.comp.threeDElements.length, comp;
	    for(i=0;i<len;i+=1){
	        //[perspectiveElem,container]
	        comp = this.comp.threeDElements[i];
	        if(comp.type === '3d') {
	            comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';
	            comp.container.style.transformOrigin = comp.container.style.mozTransformOrigin = comp.container.style.webkitTransformOrigin = "0px 0px 0px";
	            comp.perspectiveElem.style.transform = comp.perspectiveElem.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
	        }
	    }
	};
	
	HCameraElement.prototype.createElements = function(){
	};
	
	HCameraElement.prototype.hide = function(){
	};
	
	HCameraElement.prototype.renderFrame = function(){
	    var _mdf = this._isFirstFrame;
	    var i, len;
	    if(this.hierarchy){
	        len = this.hierarchy.length;
	        for(i=0;i<len;i+=1){
	            _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
	        }
	    }
	    if(_mdf || this.pe._mdf || (this.p && this.p._mdf) || (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || (this.a && this.a._mdf)) {
	        this.mat.reset();
	
	        if(this.hierarchy){
	            var mat;
	            len = this.hierarchy.length - 1;
	            for (i = len; i >= 0; i -= 1) {
	                /*mat = this.hierarchy[i].finalTransform.mProp.v.props;
	                console.log(mat)
	                this.mat.transform(-mat[0],-mat[1],-mat[2],-mat[3],-mat[4],-mat[5],-mat[6],-mat[7],-mat[8],-mat[9],-mat[10],-mat[11],-mat[12],-mat[13],-mat[14],mat[15]);
	                console.log(this.mat.props)*/
	                var mTransf = this.hierarchy[i].finalTransform.mProp;
	                this.mat.translate(-mTransf.p.v[0],-mTransf.p.v[1],mTransf.p.v[2]);
	                this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
	                this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
	                this.mat.scale(1/mTransf.s.v[0],1/mTransf.s.v[1],1/mTransf.s.v[2]);
	                this.mat.translate(mTransf.a.v[0],mTransf.a.v[1],mTransf.a.v[2]);
	            }
	        }
	
	        if(this.p){
	            this.mat.translate(-this.p.v[0],-this.p.v[1],this.p.v[2]);
	        }else{
	            this.mat.translate(-this.px.v,-this.py.v,this.pz.v);
	        }
	        if(this.a){
	            var diffVector = [this.p.v[0]-this.a.v[0],this.p.v[1]-this.a.v[1],this.p.v[2]-this.a.v[2]];
	            var mag = Math.sqrt(Math.pow(diffVector[0],2)+Math.pow(diffVector[1],2)+Math.pow(diffVector[2],2));
	            //var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
	            var lookDir = [diffVector[0]/mag,diffVector[1]/mag,diffVector[2]/mag];
	            var lookLengthOnXZ = Math.sqrt( lookDir[2]*lookDir[2] + lookDir[0]*lookDir[0] );
	            var m_rotationX = (Math.atan2( lookDir[1], lookLengthOnXZ ));
	            var m_rotationY = (Math.atan2( lookDir[0], -lookDir[2]));
	            this.mat.rotateY(m_rotationY).rotateX(-m_rotationX);
	
	        }
	        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
	        this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
	        this.mat.translate(this.globalData.compSize.w/2,this.globalData.compSize.h/2,0);
	        this.mat.translate(0,0,this.pe.v);
	
	
	        
	
	        var hasMatrixChanged = !this._prevMat.equals(this.mat);
	        if((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
	            len = this.comp.threeDElements.length;
	            var comp;
	            for(i=0;i<len;i+=1){
	                comp = this.comp.threeDElements[i];
	                if(comp.type === '3d') {
	                    if(hasMatrixChanged) {
	                        comp.container.style.transform = comp.container.style.webkitTransform = this.mat.toCSS();
	                    }
	                    if(this.pe._mdf) {
	                        comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';
	                    }
	                }
	            }
	            this.mat.clone(this._prevMat);
	        }
	    }
	    this._isFirstFrame = false;
	};
	
	HCameraElement.prototype.prepareFrame = function(num) {
	    this.prepareProperties(num, true);
	};
	
	HCameraElement.prototype.destroy = function(){
	};
	HCameraElement.prototype.getBaseElement = function(){return null;};
	function HEffects() {
	}
	HEffects.prototype.renderFrame = function(){};
	var animationManager = (function(){
	    var moduleOb = {};
	    var registeredAnimations = [];
	    var initTime = 0;
	    var len = 0;
	    var playingAnimationsNum = 0;
	    var _stopped = true;
	    var _isFrozen = false;
	
	    function removeElement(ev){
	        var i = 0;
	        var animItem = ev.target;
	        while(i<len) {
	            if (registeredAnimations[i].animation === animItem) {
	                registeredAnimations.splice(i, 1);
	                i -= 1;
	                len -= 1;
	                if(!animItem.isPaused){
	                    subtractPlayingCount();
	                }
	            }
	            i += 1;
	        }
	    }
	
	    function registerAnimation(element, animationData){
	        if(!element){
	            return null;
	        }
	        var i=0;
	        while(i<len){
	            if(registeredAnimations[i].elem == element && registeredAnimations[i].elem !== null ){
	                return registeredAnimations[i].animation;
	            }
	            i+=1;
	        }
	        var animItem = new AnimationItem();
	        setupAnimation(animItem, element);
	        animItem.setData(element, animationData);
	        return animItem;
	    }
	
	    function getRegisteredAnimations() {
	        var i, len = registeredAnimations.length;
	        var animations = [];
	        for(i = 0; i < len; i += 1) {
	            animations.push(registeredAnimations[i].animation);
	        }
	        return animations;
	    }
	
	    function addPlayingCount(){
	        playingAnimationsNum += 1;
	        activate();
	    }
	
	    function subtractPlayingCount(){
	        playingAnimationsNum -= 1;
	    }
	
	    function setupAnimation(animItem, element){
	        animItem.addEventListener('destroy',removeElement);
	        animItem.addEventListener('_active',addPlayingCount);
	        animItem.addEventListener('_idle',subtractPlayingCount);
	        registeredAnimations.push({elem: element,animation:animItem});
	        len += 1;
	    }
	
	    function loadAnimation(params){
	        var animItem = new AnimationItem();
	        setupAnimation(animItem, null);
	        animItem.setParams(params);
	        return animItem;
	    }
	
	
	    function setSpeed(val,animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.setSpeed(val, animation);
	        }
	    }
	
	    function setDirection(val, animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.setDirection(val, animation);
	        }
	    }
	
	    function play(animation){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.play(animation);
	        }
	    }
	    function resume(nowTime) {
	        var elapsedTime = nowTime - initTime;
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.advanceTime(elapsedTime);
	        }
	        initTime = nowTime;
	        if(playingAnimationsNum && !_isFrozen) {
	            window.requestAnimationFrame(resume);
	        } else {
	            _stopped = true;
	        }
	    }
	
	    function first(nowTime){
	        initTime = nowTime;
	        window.requestAnimationFrame(resume);
	    }
	
	    function pause(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.pause(animation);
	        }
	    }
	
	    function goToAndStop(value,isFrame,animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.goToAndStop(value,isFrame,animation);
	        }
	    }
	
	    function stop(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.stop(animation);
	        }
	    }
	
	    function togglePause(animation) {
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.togglePause(animation);
	        }
	    }
	
	    function destroy(animation) {
	        var i;
	        for(i=(len-1);i>=0;i-=1){
	            registeredAnimations[i].animation.destroy(animation);
	        }
	    }
	
	    function searchAnimations(animationData, standalone, renderer){
	        var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')),
	                  [].slice.call(document.getElementsByClassName('bodymovin')));
	        var i, len = animElements.length;
	        for(i=0;i<len;i+=1){
	            if(renderer){
	                animElements[i].setAttribute('data-bm-type',renderer);
	            }
	            registerAnimation(animElements[i], animationData);
	        }
	        if(standalone && len === 0){
	            if(!renderer){
	                renderer = 'svg';
	            }
	            var body = document.getElementsByTagName('body')[0];
	            body.innerHTML = '';
	            var div = createTag('div');
	            div.style.width = '100%';
	            div.style.height = '100%';
	            div.setAttribute('data-bm-type',renderer);
	            body.appendChild(div);
	            registerAnimation(div, animationData);
	        }
	    }
	
	    function resize(){
	        var i;
	        for(i=0;i<len;i+=1){
	            registeredAnimations[i].animation.resize();
	        }
	    }
	
	    function activate(){
	        if(!_isFrozen && playingAnimationsNum){
	            if(_stopped) {
	                window.requestAnimationFrame(first);
	                _stopped = false;
	            }
	        }
	    }
	
	    function freeze() {
	        _isFrozen = true;
	    }
	
	    function unfreeze() {
	        _isFrozen = false;
	        activate();
	    }
	
	    moduleOb.registerAnimation = registerAnimation;
	    moduleOb.loadAnimation = loadAnimation;
	    moduleOb.setSpeed = setSpeed;
	    moduleOb.setDirection = setDirection;
	    moduleOb.play = play;
	    moduleOb.pause = pause;
	    moduleOb.stop = stop;
	    moduleOb.togglePause = togglePause;
	    moduleOb.searchAnimations = searchAnimations;
	    moduleOb.resize = resize;
	    //moduleOb.start = start;
	    moduleOb.goToAndStop = goToAndStop;
	    moduleOb.destroy = destroy;
	    moduleOb.freeze = freeze;
	    moduleOb.unfreeze = unfreeze;
	    moduleOb.getRegisteredAnimations = getRegisteredAnimations;
	    return moduleOb;
	}());
	
	var AnimationItem = function () {
	    this._cbs = [];
	    this.name = '';
	    this.path = '';
	    this.isLoaded = false;
	    this.currentFrame = 0;
	    this.currentRawFrame = 0;
	    this.totalFrames = 0;
	    this.frameRate = 0;
	    this.frameMult = 0;
	    this.playSpeed = 1;
	    this.playDirection = 1;
	    this.playCount = 0;
	    this.animationData = {};
	    this.assets = [];
	    this.isPaused = true;
	    this.autoplay = false;
	    this.loop = true;
	    this.renderer = null;
	    this.animationID = createElementID();
	    this.assetsPath = '';
	    this.timeCompleted = 0;
	    this.segmentPos = 0;
	    this.subframeEnabled = subframeEnabled;
	    this.segments = [];
	    this._idle = true;
	    this._completedLoop = false;
	    this.projectInterface = ProjectInterface();
	    this.imagePreloader = new ImagePreloader();
	};
	
	extendPrototype([BaseEvent], AnimationItem);
	
	AnimationItem.prototype.setParams = function(params) {
	    if(params.context){
	        this.context = params.context;
	    }
	    if(params.wrapper || params.container){
	        this.wrapper = params.wrapper || params.container;
	    }
	    var animType = params.animType ? params.animType : params.renderer ? params.renderer : 'svg';
	    switch(animType){
	        case 'canvas':
	            this.renderer = new CanvasRenderer(this, params.rendererSettings);
	            break;
	        case 'svg':
	            this.renderer = new SVGRenderer(this, params.rendererSettings);
	            break;
	        default:
	            this.renderer = new HybridRenderer(this, params.rendererSettings);
	            break;
	    }
	    this.renderer.setProjectInterface(this.projectInterface);
	    this.animType = animType;
	
	    if(params.loop === '' || params.loop === null){
	    }else if(params.loop === false){
	        this.loop = false;
	    }else if(params.loop === true){
	        this.loop = true;
	    }else{
	        this.loop = parseInt(params.loop);
	    }
	    this.autoplay = 'autoplay' in params ? params.autoplay : true;
	    this.name = params.name ? params.name :  '';
	    this.autoloadSegments = params.hasOwnProperty('autoloadSegments') ? params.autoloadSegments :  true;
	    this.assetsPath = params.assetsPath;
	    if(params.animationData){
	        this.configAnimation(params.animationData);
	    }else if(params.path){
	        if(params.path.substr(-4) != 'json'){
	            if (params.path.substr(-1, 1) != '/') {
	                params.path += '/';
	            }
	            params.path += 'data.json';
	        }
	
	        if(params.path.lastIndexOf('\\') != -1){
	            this.path = params.path.substr(0,params.path.lastIndexOf('\\')+1);
	        }else{
	            this.path = params.path.substr(0,params.path.lastIndexOf('/')+1);
	        }
	        this.fileName = params.path.substr(params.path.lastIndexOf('/')+1);
	        this.fileName = this.fileName.substr(0,this.fileName.lastIndexOf('.json'));
	
	        assetLoader.load(params.path, this.configAnimation.bind(this), function() {
	            this.trigger('data_failed');
	        }.bind(this));
	    }
	};
	
	AnimationItem.prototype.setData = function (wrapper, animationData) {
	    var params = {
	        wrapper: wrapper,
	        animationData: animationData ? (typeof animationData  === "object") ? animationData : JSON.parse(animationData) : null
	    };
	    var wrapperAttributes = wrapper.attributes;
	
	    params.path = wrapperAttributes.getNamedItem('data-animation-path') ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') ? wrapperAttributes.getNamedItem('data-bm-path').value :  wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
	    params.animType = wrapperAttributes.getNamedItem('data-anim-type') ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') ? wrapperAttributes.getNamedItem('bm-type').value :  wrapperAttributes.getNamedItem('data-bm-renderer') ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : 'canvas';
	
	    var loop = wrapperAttributes.getNamedItem('data-anim-loop') ? wrapperAttributes.getNamedItem('data-anim-loop').value :  wrapperAttributes.getNamedItem('data-bm-loop') ? wrapperAttributes.getNamedItem('data-bm-loop').value :  wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
	    if(loop === ''){
	    }else if(loop === 'false'){
	        params.loop = false;
	    }else if(loop === 'true'){
	        params.loop = true;
	    }else{
	        params.loop = parseInt(loop);
	    }
	    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') ? wrapperAttributes.getNamedItem('data-anim-autoplay').value :  wrapperAttributes.getNamedItem('data-bm-autoplay') ? wrapperAttributes.getNamedItem('data-bm-autoplay').value :  wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
	    params.autoplay = autoplay !== "false";
	
	    params.name = wrapperAttributes.getNamedItem('data-name') ? wrapperAttributes.getNamedItem('data-name').value :  wrapperAttributes.getNamedItem('data-bm-name') ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value :  '';
	    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') ? wrapperAttributes.getNamedItem('data-anim-prerender').value :  wrapperAttributes.getNamedItem('data-bm-prerender') ? wrapperAttributes.getNamedItem('data-bm-prerender').value :  wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';
	
	    if(prerender === 'false'){
	        params.prerender = false;
	    }
	    this.setParams(params);
	};
	
	AnimationItem.prototype.includeLayers = function(data) {
	    if(data.op > this.animationData.op){
	        this.animationData.op = data.op;
	        this.totalFrames = Math.floor(data.op - this.animationData.ip);
	    }
	    var layers = this.animationData.layers;
	    var i, len = layers.length;
	    var newLayers = data.layers;
	    var j, jLen = newLayers.length;
	    for(j=0;j<jLen;j+=1){
	        i = 0;
	        while(i<len){
	            if(layers[i].id == newLayers[j].id){
	                layers[i] = newLayers[j];
	                break;
	            }
	            i += 1;
	        }
	    }
	    if(data.chars || data.fonts){
	        this.renderer.globalData.fontManager.addChars(data.chars);
	        this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
	    }
	    if(data.assets){
	        len = data.assets.length;
	        for(i = 0; i < len; i += 1){
	            this.animationData.assets.push(data.assets[i]);
	        }
	    }
	    this.animationData.__complete = false;
	    dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
	    this.renderer.includeLayers(data.layers);
	    if(expressionsPlugin){
	        expressionsPlugin.initExpressions(this);
	    }
	    this.loadNextSegment();
	};
	
	AnimationItem.prototype.loadNextSegment = function() {
	    var segments = this.animationData.segments;
	    if(!segments || segments.length === 0 || !this.autoloadSegments){
	        this.trigger('data_ready');
	        this.timeCompleted = this.totalFrames;
	        return;
	    }
	    var segment = segments.shift();
	    this.timeCompleted = segment.time * this.frameRate;
	    var segmentPath = this.path+this.fileName+'_' + this.segmentPos + '.json';
	    this.segmentPos += 1;
	    assetLoader.load(segmentPath, this.includeLayers.bind(this), function() {
	        this.trigger('data_failed');
	    }.bind(this));
	};
	
	AnimationItem.prototype.loadSegments = function() {
	    var segments = this.animationData.segments;
	    if(!segments) {
	        this.timeCompleted = this.totalFrames;
	    }
	    this.loadNextSegment();
	};
	
	AnimationItem.prototype.imagesLoaded = function() {
	    this.trigger('loaded_images');
	    this.checkLoaded()
	}
	
	AnimationItem.prototype.preloadImages = function() {
	    this.imagePreloader.setAssetsPath(this.assetsPath);
	    this.imagePreloader.setPath(this.path);
	    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
	}
	
	AnimationItem.prototype.configAnimation = function (animData) {
	    if(!this.renderer){
	        return;
	    }
	    this.animationData = animData;
	    this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
	    this.renderer.configAnimation(animData);
	    if(!animData.assets){
	        animData.assets = [];
	    }
	    this.renderer.searchExtraCompositions(animData.assets);
	
	    this.assets = this.animationData.assets;
	    this.frameRate = this.animationData.fr;
	    this.firstFrame = Math.round(this.animationData.ip);
	    this.frameMult = this.animationData.fr / 1000;
	    this.trigger('config_ready');
	    this.preloadImages();
	    this.loadSegments();
	    this.updaFrameModifier();
	    this.waitForFontsLoaded();
	};
	
	AnimationItem.prototype.waitForFontsLoaded = function(){
	    if(!this.renderer) {
	        return;
	    }
	    if(this.renderer.globalData.fontManager.loaded()){
	        this.checkLoaded();
	    }else{
	        setTimeout(this.waitForFontsLoaded.bind(this),20);
	    }
	}
	
	AnimationItem.prototype.checkLoaded = function () {
	    if (!this.isLoaded && this.renderer.globalData.fontManager.loaded() && (this.imagePreloader.loaded() || this.renderer.rendererType !== 'canvas')) {
	        this.isLoaded = true;
	        dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
	        if(expressionsPlugin){
	            expressionsPlugin.initExpressions(this);
	        }
	        this.renderer.initItems();
	        setTimeout(function() {
	            this.trigger('DOMLoaded');
	        }.bind(this), 0);
	        this.gotoFrame();
	        if(this.autoplay){
	            this.play();
	        }
	    }
	};
	
	AnimationItem.prototype.resize = function () {
	    this.renderer.updateContainerSize();
	};
	
	AnimationItem.prototype.setSubframe = function(flag){
	    this.subframeEnabled = flag ? true : false;
	};
	
	AnimationItem.prototype.gotoFrame = function () {
	    this.currentFrame = this.subframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
	
	    if(this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted){
	        this.currentFrame = this.timeCompleted;
	    }
	    this.trigger('enterFrame');
	    this.renderFrame();
	};
	
	AnimationItem.prototype.renderFrame = function () {
	    if(this.isLoaded === false){
	        return;
	    }
	    this.renderer.renderFrame(this.currentFrame + this.firstFrame);
	};
	
	AnimationItem.prototype.play = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === true){
	        this.isPaused = false;
	        if(this._idle){
	            this._idle = false;
	            this.trigger('_active');
	        }
	    }
	};
	
	AnimationItem.prototype.pause = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === false){
	        this.isPaused = true;
	        this._idle = true;
	        this.trigger('_idle');
	    }
	};
	
	AnimationItem.prototype.togglePause = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(this.isPaused === true){
	        this.play();
	    }else{
	        this.pause();
	    }
	};
	
	AnimationItem.prototype.stop = function (name) {
	    if(name && this.name != name){
	        return;
	    }
	    this.pause();
	    this.playCount = 0;
	    this._completedLoop = false;
	    this.setCurrentRawFrameValue(0);
	};
	
	AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
	    if(name && this.name != name){
	        return;
	    }
	    if(isFrame){
	        this.setCurrentRawFrameValue(value);
	    }else{
	        this.setCurrentRawFrameValue(value * this.frameModifier);
	    }
	    this.pause();
	};
	
	AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
	    this.goToAndStop(value, isFrame, name);
	    this.play();
	};
	
	AnimationItem.prototype.advanceTime = function (value) {
	    if (this.isPaused === true || this.isLoaded === false) {
	        return;
	    }
	    var nextValue = this.currentRawFrame + value * this.frameModifier;
	    var _isComplete = false;
	    // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
	    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
	    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
	        if (!this.loop || this.playCount === this.loop) {
	            if (!this.checkSegments(nextValue >  this.totalFrames ? nextValue % this.totalFrames : 0)) {
	                _isComplete = true;
	                nextValue = this.totalFrames - 1;
	            }
	        } else if (nextValue >= this.totalFrames) {
	            this.playCount += 1;
	            if (!this.checkSegments(nextValue % this.totalFrames)) {
	                this.setCurrentRawFrameValue(nextValue % this.totalFrames);
	                this._completedLoop = true;
	                this.trigger('loopComplete');
	            }
	        } else {
	            this.setCurrentRawFrameValue(nextValue);
	        }
	    } else if(nextValue < 0) {
	        if (!this.checkSegments(nextValue % this.totalFrames)) {
	            if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
	                this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames));
	                if(!this._completedLoop) {
	                    this._completedLoop = true;
	                } else {
	                    this.trigger('loopComplete');
	                }
	            } else {
	                _isComplete = true;
	                nextValue = 0;
	            }
	        }
	    } else {
	        this.setCurrentRawFrameValue(nextValue);
	    }
	    if (_isComplete) {
	        this.setCurrentRawFrameValue(nextValue);
	        this.pause();
	        this.trigger('complete');
	    }
	};
	
	AnimationItem.prototype.adjustSegment = function(arr, offset){
	    this.playCount = 0;
	    if(arr[1] < arr[0]){
	        if(this.frameModifier > 0){
	            if(this.playSpeed < 0){
	                this.setSpeed(-this.playSpeed);
	            } else {
	                this.setDirection(-1);
	            }
	        }
	        this.timeCompleted = this.totalFrames = arr[0] - arr[1];
	        this.firstFrame = arr[1];
	        this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
	    } else if(arr[1] > arr[0]){
	        if(this.frameModifier < 0){
	            if(this.playSpeed < 0){
	                this.setSpeed(-this.playSpeed);
	            } else {
	                this.setDirection(1);
	            }
	        }
	        this.timeCompleted = this.totalFrames = arr[1] - arr[0];
	        this.firstFrame = arr[0];
	        this.setCurrentRawFrameValue(0.001 + offset);
	    }
	    this.trigger('segmentStart');
	};
	AnimationItem.prototype.setSegment = function (init,end) {
	    var pendingFrame = -1;
	    if(this.isPaused) {
	        if (this.currentRawFrame + this.firstFrame < init) {
	            pendingFrame = init;
	        } else if (this.currentRawFrame + this.firstFrame > end) {
	            pendingFrame = end - init;
	        }
	    }
	
	    this.firstFrame = init;
	    this.timeCompleted = this.totalFrames = end - init;
	    if(pendingFrame !== -1) {
	        this.goToAndStop(pendingFrame,true);
	    }
	};
	
	AnimationItem.prototype.playSegments = function (arr, forceFlag) {
	    if (forceFlag) {
	        this.segments.length = 0;
	    }
	    if (typeof arr[0] === 'object') {
	        var i, len = arr.length;
	        for (i = 0; i < len; i += 1) {
	            this.segments.push(arr[i]);
	        }
	    } else {
	        this.segments.push(arr);
	    }
	    if (this.segments.length && forceFlag) {
	        this.adjustSegment(this.segments.shift(), 0);
	    }
	    if (this.isPaused) {
	        this.play();
	    }
	};
	
	AnimationItem.prototype.resetSegments = function (forceFlag) {
	    this.segments.length = 0;
	    this.segments.push([this.animationData.ip,this.animationData.op]);
	    //this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);
	    if (forceFlag) {
	        this.checkSegments(0);
	    }
	};
	AnimationItem.prototype.checkSegments = function(offset) {
	    if (this.segments.length) {
	        this.adjustSegment(this.segments.shift(), offset);
	        return true;
	    }
	    return false;
	};
	
	AnimationItem.prototype.destroy = function (name) {
	    if ((name && this.name != name) || !this.renderer) {
	        return;
	    }
	    this.renderer.destroy();
	    this.imagePreloader.destroy();
	    this.trigger('destroy');
	    this._cbs = null;
	    this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null;
	    this.renderer = null;
	};
	
	AnimationItem.prototype.setCurrentRawFrameValue = function(value){
	    this.currentRawFrame = value;
	    this.gotoFrame();
	};
	
	AnimationItem.prototype.setSpeed = function (val) {
	    this.playSpeed = val;
	    this.updaFrameModifier();
	};
	
	AnimationItem.prototype.setDirection = function (val) {
	    this.playDirection = val < 0 ? -1 : 1;
	    this.updaFrameModifier();
	};
	
	AnimationItem.prototype.updaFrameModifier = function () {
	    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
	};
	
	AnimationItem.prototype.getPath = function () {
	    return this.path;
	};
	
	AnimationItem.prototype.getAssetsPath = function (assetData) {
	    var path = '';
	    if(assetData.e) {
	        path = assetData.p;
	    } else if(this.assetsPath){
	        var imagePath = assetData.p;
	        if(imagePath.indexOf('images/') !== -1){
	            imagePath = imagePath.split('/')[1];
	        }
	        path = this.assetsPath + imagePath;
	    } else {
	        path = this.path;
	        path += assetData.u ? assetData.u : '';
	        path += assetData.p;
	    }
	    return path;
	};
	
	AnimationItem.prototype.getAssetData = function (id) {
	    var i = 0, len = this.assets.length;
	    while (i < len) {
	        if(id == this.assets[i].id){
	            return this.assets[i];
	        }
	        i += 1;
	    }
	};
	
	AnimationItem.prototype.hide = function () {
	    this.renderer.hide();
	};
	
	AnimationItem.prototype.show = function () {
	    this.renderer.show();
	};
	
	AnimationItem.prototype.getDuration = function (isFrame) {
	    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
	};
	
	AnimationItem.prototype.trigger = function(name){
	    if(this._cbs && this._cbs[name]){
	        switch(name){
	            case 'enterFrame':
	                this.triggerEvent(name,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameModifier));
	                break;
	            case 'loopComplete':
	                this.triggerEvent(name,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
	                break;
	            case 'complete':
	                this.triggerEvent(name,new BMCompleteEvent(name,this.frameMult));
	                break;
	            case 'segmentStart':
	                this.triggerEvent(name,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
	                break;
	            case 'destroy':
	                this.triggerEvent(name,new BMDestroyEvent(name,this));
	                break;
	            default:
	                this.triggerEvent(name);
	        }
	    }
	    if(name === 'enterFrame' && this.onEnterFrame){
	        this.onEnterFrame.call(this,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));
	    }
	    if(name === 'loopComplete' && this.onLoopComplete){
	        this.onLoopComplete.call(this,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
	    }
	    if(name === 'complete' && this.onComplete){
	        this.onComplete.call(this,new BMCompleteEvent(name,this.frameMult));
	    }
	    if(name === 'segmentStart' && this.onSegmentStart){
	        this.onSegmentStart.call(this,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
	    }
	    if(name === 'destroy' && this.onDestroy){
	        this.onDestroy.call(this,new BMDestroyEvent(name,this));
	    }
	};
	
	var Expressions = (function(){
	    var ob = {};
	    ob.initExpressions = initExpressions;
	
	
	    function initExpressions(animation){
	
	    	var stackCount = 0;
	    	var registers = [];
	
	    	function pushExpression() {
				stackCount += 1;
	    	}
	
	    	function popExpression() {
				stackCount -= 1;
				if (stackCount === 0) {
					releaseInstances();
				}
	    	}
	
	    	function registerExpressionProperty(expression) {
	    		if (registers.indexOf(expression) === -1) {
					registers.push(expression)
	    		}
	    	}
	
	    	function releaseInstances() {
	    		var i, len = registers.length;
	    		for (i = 0; i < len; i += 1) {
					registers[i].release();
	    		}
	    		registers.length = 0;
	    	}
	
	        animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
	        animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
	        animation.renderer.globalData.pushExpression = pushExpression;
	        animation.renderer.globalData.popExpression = popExpression;
	        animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
	    }
	   return ob;
	}());
	
	expressionsPlugin = Expressions;
	
	var ExpressionManager = (function(){
	    'use strict';
	    var ob = {};
	    var Math = BMMath;
	    var window = null;
	    var document = null;
	
	    function $bm_isInstanceOfArray(arr) {
	        return arr.constructor === Array || arr.constructor === Float32Array;
	    }
	
	    function isNumerable(tOfV, v) {
	        return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;
	    }
	
	    function $bm_neg(a){
	        var tOfA = typeof a;
	        if(tOfA === 'number' || tOfA === 'boolean'  || a instanceof Number ){
	            return -a;
	        }
	        if($bm_isInstanceOfArray(a)){
	            var i, lenA = a.length;
	            var retArr = [];
	            for(i=0;i<lenA;i+=1){
	                retArr[i] = -a[i];
	            }
	            return retArr;
	        }
	        if (a.propType) {
	            return a.v;
	        }
	    }
	
	    var easeInBez = BezierFactory.getBezierEasing(0.333,0,.833,.833, 'easeIn').get;
	    var easeOutBez = BezierFactory.getBezierEasing(0.167,0.167,.667,1, 'easeOut').get;
	    var easeInOutBez = BezierFactory.getBezierEasing(.33,0,.667,1, 'easeInOut').get;
	
	    function sum(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        if(tOfA === 'string' || tOfB === 'string'){
	            return a + b;
	        }
	        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	            return a + b;
	        }
	        if($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){
	            a = a.slice(0);
	            a[0] = a[0] + b;
	            return a;
	        }
	        if(isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)){
	            b = b.slice(0);
	            b[0] = a + b[0];
	            return b;
	        }
	        if($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)){
	            
	            var i = 0, lenA = a.length, lenB = b.length;
	            var retArr = [];
	            while(i<lenA || i < lenB){
	                if((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)){
	                    retArr[i] = a[i] + b[i];
	                }else{
	                    retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
	                }
	                i += 1;
	            }
	            return retArr;
	        }
	        return 0;
	    }
	    var add = sum;
	
	    function sub(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	            if(tOfA === 'string') {
	                a = parseInt(a);
	            }
	            if(tOfB === 'string') {
	                b = parseInt(b);
	            }
	            return a - b;
	        }
	        if( $bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){
	            a = a.slice(0);
	            a[0] = a[0] - b;
	            return a;
	        }
	        if(isNumerable(tOfA, a) &&  $bm_isInstanceOfArray(b)){
	            b = b.slice(0);
	            b[0] = a - b[0];
	            return b;
	        }
	        if($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)){
	            var i = 0, lenA = a.length, lenB = b.length;
	            var retArr = [];
	            while(i<lenA || i < lenB){
	                if((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)){
	                    retArr[i] = a[i] - b[i];
	                }else{
	                    retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
	                }
	                i += 1;
	            }
	            return retArr;
	        }
	        return 0;
	    }
	
	    function mul(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        var arr;
	        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	            return a * b;
	        }
	
	        var i, len;
	        if($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){
	            len = a.length;
	            arr = createTypedArray('float32', len);
	            for(i=0;i<len;i+=1){
	                arr[i] = a[i] * b;
	            }
	            return arr;
	        }
	        if(isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)){
	            len = b.length;
	            arr = createTypedArray('float32', len);
	            for(i=0;i<len;i+=1){
	                arr[i] = a * b[i];
	            }
	            return arr;
	        }
	        return 0;
	    }
	
	    function div(a,b) {
	        var tOfA = typeof a;
	        var tOfB = typeof b;
	        var arr;
	        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
	            return a / b;
	        }
	        var i, len;
	        if($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){
	            len = a.length;
	            arr = createTypedArray('float32', len);
	            for(i=0;i<len;i+=1){
	                arr[i] = a[i] / b;
	            }
	            return arr;
	        }
	        if(isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)){
	            len = b.length;
	            arr = createTypedArray('float32', len);
	            for(i=0;i<len;i+=1){
	                arr[i] = a / b[i];
	            }
	            return arr;
	        }
	        return 0;
	    }
	    function mod(a,b) {
	        if(typeof a === 'string') {
	            a = parseInt(a);
	        }
	        if(typeof b === 'string') {
	            b = parseInt(b);
	        }
	        return a % b;
	    }
	    var $bm_sum = sum;
	    var $bm_sub = sub;
	    var $bm_mul = mul;
	    var $bm_div = div;
	    var $bm_mod = mod;
	
	    function clamp(num, min, max) {
	        if(min > max){
	            var mm = max;
	            max = min;
	            min = mm;
	        }
	        return Math.min(Math.max(num, min), max);
	    }
	
	    function radiansToDegrees(val) {
	        return val/degToRads;
	    }
	    var radians_to_degrees = radiansToDegrees;
	
	    function degreesToRadians(val) {
	        return val*degToRads;
	    }
	    var degrees_to_radians = radiansToDegrees;
	
	    var helperLengthArray = [0,0,0,0,0,0];
	
	    function length(arr1, arr2) {
	        if (typeof arr1 === 'number' || arr1 instanceof Number) {
	            arr2 = arr2 || 0;
	            return Math.abs(arr1 - arr2);
	        }
	        if(!arr2) {
	            arr2 = helperLengthArray;
	        }
	        var i, len = Math.min(arr1.length, arr2.length);
	        var addedLength = 0;
	        for (i = 0; i < len; i += 1) {
	            addedLength += Math.pow(arr2[i] - arr1[i], 2);
	        }
	        return Math.sqrt(addedLength);
	    }
	
	    function normalize(vec) {
	        return div(vec, length(vec));
	    }
	
	    function rgbToHsl(val) {
	        var r = val[0]; var g = val[1]; var b = val[2];
	        var max = Math.max(r, g, b), min = Math.min(r, g, b);
	        var h, s, l = (max + min) / 2;
	
	        if(max == min){
	            h = s = 0; // achromatic
	        }else{
	            var d = max - min;
	            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	            switch(max){
	                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	                case g: h = (b - r) / d + 2; break;
	                case b: h = (r - g) / d + 4; break;
	            }
	            h /= 6;
	        }
	
	        return [h, s, l,val[3]];
	    }
	
	    function hue2rgb(p, q, t){
	        if(t < 0) t += 1;
	        if(t > 1) t -= 1;
	        if(t < 1/6) return p + (q - p) * 6 * t;
	        if(t < 1/2) return q;
	        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	        return p;
	    }
	
	    function hslToRgb(val){
	        var h = val[0];
	        var s = val[1];
	        var l = val[2];
	
	        var r, g, b;
	
	        if(s === 0){
	            r = g = b = l; // achromatic
	        }else{
	
	            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	            var p = 2 * l - q;
	            r = hue2rgb(p, q, h + 1/3);
	            g = hue2rgb(p, q, h);
	            b = hue2rgb(p, q, h - 1/3);
	        }
	
	        return [r, g , b, val[3]];
	    }
	
	    function linear(t, tMin, tMax, value1, value2){
	        if(value1 === undefined || value2 === undefined){
	            value1 = tMin;
	            value2 = tMax;
	            tMin = 0;
	            tMax = 1;
	        }
	        if(tMax < tMin) {
	            var _tMin = tMax;
	            tMax = tMin;
	            tMin = _tMin;
	        }
	        if(t <= tMin) {
	            return value1;
	        }else if(t >= tMax){
	            return value2;
	        }
	        var perc = tMax === tMin ? 0 : (t-tMin)/(tMax-tMin);
	        if(!value1.length){
	            return value1 + (value2-value1)*perc;
	        }
	        var i, len = value1.length;
	        var arr = createTypedArray('float32', len);
	        for(i=0;i<len;i+=1){
	            arr[i] = value1[i] + (value2[i]-value1[i])*perc;
	        }
	        return arr;
	    }
	    function random(min,max){
	        if(max === undefined){
	            if(min === undefined){
	                min = 0;
	                max = 1;
	            } else {
	                max = min;
	                min = undefined;
	            }
	        }
	        if(max.length){
	            var i, len = max.length;
	            if(!min){
	                min = createTypedArray('float32', len);
	            }
	            var arr = createTypedArray('float32', len);
	            var rnd = BMMath.random();
	            for(i=0;i<len;i+=1){
	                arr[i] = min[i] + rnd*(max[i]-min[i]);
	            }
	            return arr;
	        }
	        if(min === undefined){
	            min = 0;
	        }
	        var rndm = BMMath.random();
	        return min + rndm*(max-min);
	    }
	
	    function createPath(points, inTangents, outTangents, closed) {
	        var i, len = points.length;
	        var path = shape_pool.newElement();
	        path.setPathData(!!closed, len);
	        var arrPlaceholder = [0,0], inVertexPoint, outVertexPoint;
	        for(i = 0; i < len; i += 1) {
	            inVertexPoint = (inTangents && inTangents[i]) ? inTangents[i] : arrPlaceholder;
	            outVertexPoint = (outTangents && outTangents[i]) ? outTangents[i] : arrPlaceholder;
	            path.setTripleAt(points[i][0],points[i][1],outVertexPoint[0] + points[i][0],outVertexPoint[1] + points[i][1],inVertexPoint[0] + points[i][0],inVertexPoint[1] + points[i][1],i,true);
	        }
	        return path;
	    }
	
	    function initiateExpression(elem,data,property){
	        var val = data.x;
	        var needsVelocity = /velocity(?![\w\d])/.test(val);
	        var _needsRandom = val.indexOf('random') !== -1;
	        var elemType = elem.data.ty;
	        var transform,$bm_transform,content,effect;
	        var thisProperty = property;
	        thisProperty.valueAtTime = thisProperty.getValueAtTime;
	        Object.defineProperty(thisProperty, 'value', {
	            get: function() {
	                return thisProperty.v
	            }
	        })
	        elem.comp.frameDuration = 1/elem.comp.globalData.frameRate;
	        elem.comp.displayStartTime = 0;
	        var inPoint = elem.data.ip/elem.comp.globalData.frameRate;
	        var outPoint = elem.data.op/elem.comp.globalData.frameRate;
	        var width = elem.data.sw ? elem.data.sw : 0;
	        var height = elem.data.sh ? elem.data.sh : 0;
	        var name = elem.data.nm;
	        var loopIn, loop_in, loopOut, loop_out, smooth;
	        var toWorld,fromWorld,fromComp,toComp,fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp,mask,valueAtTime,velocityAtTime;
	        var __expression_functions = [];
	        if(data.xf) {
	            var i, len = data.xf.length;
	            for(i = 0; i < len; i += 1) {
	                __expression_functions[i] = eval('(function(){ return ' + data.xf[i] + '}())');
	            }
	        }
	
	        var scoped_bm_rt;
	        var expression_function = eval('[function _expression_function(){' + val+';scoped_bm_rt=$bm_rt}' + ']')[0];
	        var numKeys = property.kf ? data.k.length : 0;
	
	        var active = !this.data || this.data.hd !== true;
	
	        var wiggle = function wiggle(freq,amp){
	            var i,j, len = this.pv.length ? this.pv.length : 1;
	            var addedAmps = createTypedArray('float32', len);
	            freq = 5;
	            var iterations = Math.floor(time*freq);
	            i = 0;
	            j = 0;
	            while(i<iterations){
	                //var rnd = BMMath.random();
	                for(j=0;j<len;j+=1){
	                    addedAmps[j] += -amp + amp*2*BMMath.random();
	                    //addedAmps[j] += -amp + amp*2*rnd;
	                }
	                i += 1;
	            }
	            //var rnd2 = BMMath.random();
	            var periods = time*freq;
	            var perc = periods - Math.floor(periods);
	            var arr = createTypedArray('float32', len);
	            if(len>1){
	                for(j=0;j<len;j+=1){
	                    arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*BMMath.random())*perc;
	                    //arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
	                    //arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
	                }
	                return arr;
	            } else {
	                return this.pv + addedAmps[0] + (-amp + amp*2*BMMath.random())*perc;
	            }
	        }.bind(this);
	
	        if(thisProperty.loopIn) {
	            loopIn = thisProperty.loopIn.bind(thisProperty);
	            loop_in = loopIn;
	        }
	
	        if(thisProperty.loopOut) {
	            loopOut = thisProperty.loopOut.bind(thisProperty);
	            loop_out = loopOut;
	        }
	
	        if(thisProperty.smooth) {
	            smooth = thisProperty.smooth.bind(thisProperty);
	        }
	
	        function loopInDuration(type,duration){
	            return loopIn(type,duration,true);
	        }
	
	        function loopOutDuration(type,duration){
	            return loopOut(type,duration,true);
	        }
	
	        if(this.getValueAtTime) {
	            valueAtTime = this.getValueAtTime.bind(this);
	        }
	
	        if(this.getVelocityAtTime) {
	            velocityAtTime = this.getVelocityAtTime.bind(this);
	        }
	
	        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
	
	        function lookAt(elem1,elem2){
	            var fVec = [elem2[0]-elem1[0],elem2[1]-elem1[1],elem2[2]-elem1[2]];
	            var pitch = Math.atan2(fVec[0],Math.sqrt(fVec[1]*fVec[1]+fVec[2]*fVec[2]))/degToRads;
	            var yaw = -Math.atan2(fVec[1],fVec[2])/degToRads;
	            return [yaw,pitch,0];
	        }
	
	        function easeOut(t, tMin, tMax, val1, val2){
	            return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
	        }
	
	        function easeIn(t, tMin, tMax, val1, val2){
	            return applyEase(easeInBez, t, tMin, tMax, val1, val2);
	        }
	
	        function ease(t, tMin, tMax, val1, val2){
	            return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
	        }
	
	        function applyEase(fn, t, tMin, tMax, val1, val2) {
	            if(val1 === undefined){
	                val1 = tMin;
	                val2 = tMax;
	            } else {
	                t = (t - tMin) / (tMax - tMin);
	            }
	            t = t > 1 ? 1 : t < 0 ? 0 : t;
	            var mult = fn(t);
	            if($bm_isInstanceOfArray(val1)) {
	                var i, len = val1.length;
	                var arr = createTypedArray('float32', len);
	                for (i = 0; i < len; i += 1) {
	                    arr[i] = (val2[i] - val1[i]) * mult + val1[i];
	                }
	                return arr;
	            } else {
	                return (val2 - val1) * mult + val1;
	            }
	        }
	
	        function nearestKey(time){
	            var i, len = data.k.length,index,keyTime;
	            if(!data.k.length || typeof(data.k[0]) === 'number'){
	                index = 0;
	                keyTime = 0;
	            } else {
	                index = -1;
	                time *= elem.comp.globalData.frameRate;
	                if (time < data.k[0].t) {
	                    index = 1;
	                    keyTime = data.k[0].t;
	                } else {
	                    for(i=0;i<len-1;i+=1){
	                        if(time === data.k[i].t){
	                            index = i + 1;
	                            keyTime = data.k[i].t;
	                            break;
	                        }else if(time>data.k[i].t && time<data.k[i+1].t){
	                            if(time-data.k[i].t > data.k[i+1].t - time){
	                                index = i + 2;
	                                keyTime = data.k[i+1].t;
	                            } else {
	                                index = i + 1;
	                                keyTime = data.k[i].t;
	                            }
	                            break;
	                        }
	                    }
	                    if(index === -1){
	                        index = i + 1;
	                        keyTime = data.k[i].t;
	                    }
	                }
	                
	            }
	            var ob = {};
	            ob.index = index;
	            ob.time = keyTime/elem.comp.globalData.frameRate;
	            return ob;
	        }
	
	        function key(ind){
	            var ob, i, len;
	            if(!data.k.length || typeof(data.k[0]) === 'number'){
	                throw new Error('The property has no keyframe at index ' + ind);
	            }
	            ind -= 1;
	            ob = {
	                time: data.k[ind].t/elem.comp.globalData.frameRate,
	                value: []
	            };
	            var arr;
	            if(ind === data.k.length - 1 && !data.k[ind].h){
	                arr = (data.k[ind].s || data.k[ind].s === 0) ? data.k[ind-1].s : data.k[ind].e;
	            }else{
	                arr = data.k[ind].s;
	            }
	            len = arr.length;
	            for(i=0;i<len;i+=1){
	                ob[i] = arr[i];
	                ob.value[i] = arr[i]
	            }
	            return ob;
	        }
	
	        function framesToTime(frames, fps) { 
	            if (!fps) {
	                fps = elem.comp.globalData.frameRate;
	            }
	            return frames / fps;
	        }
	
	        function timeToFrames(t, fps) {
	            if (!t && t !== 0) {
	                t = time;
	            }
	            if (!fps) {
	                fps = elem.comp.globalData.frameRate;
	            }
	            return t * fps;
	        }
	
	        function seedRandom(seed){
	            BMMath.seedrandom(randSeed + seed);
	        }
	
	        function sourceRectAtTime() {
	            return elem.sourceRectAtTime();
	        }
	
	        function substring(init, end) {
	            if(typeof value === 'string') {
	                if(end === undefined) {
	                return value.substring(init)
	                }
	                return value.substring(init, end)
	            }
	            return '';
	        }
	
	        function substr(init, end) {
	            if(typeof value === 'string') {
	                if(end === undefined) {
	                return value.substr(init)
	                }
	                return value.substr(init, end)
	            }
	            return '';
	        }
	
	        var time, velocity, value, text, textIndex, textTotal, selectorValue;
	        var index = elem.data.ind;
	        var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	        var parent;
	        var randSeed = Math.floor(Math.random()*1000000);
	        var globalData = elem.globalData;
	        function executeExpression(_value) {
	            // globalData.pushExpression();
	            value = _value;
	            if (_needsRandom) {
	                seedRandom(randSeed);
	            }
	            if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
	                return value;
	            }
	            if(this.propType === 'textSelector'){
	                textIndex = this.textIndex;
	                textTotal = this.textTotal;
	                selectorValue = this.selectorValue;
	            }
	            if (!thisLayer) {
	                text = elem.layerInterface.text;
	                thisLayer = elem.layerInterface;
	                thisComp = elem.comp.compInterface;
	                toWorld = thisLayer.toWorld.bind(thisLayer);
	                fromWorld = thisLayer.fromWorld.bind(thisLayer);
	                fromComp = thisLayer.fromComp.bind(thisLayer);
	                toComp = thisLayer.toComp.bind(thisLayer);
	                mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
	                fromCompToSurface = fromComp;
	            }
	            if (!transform) {
	                transform = elem.layerInterface("ADBE Transform Group");
	                $bm_transform = transform;
	                if(transform) {
	                    anchorPoint = transform.anchorPoint;
	                    /*position = transform.position;
	                    rotation = transform.rotation;
	                    scale = transform.scale;*/
	                }
	            }
	            
	            if (elemType === 4 && !content) {
	                content = thisLayer("ADBE Root Vectors Group");
	            }
	            if (!effect) {
	                effect = thisLayer(4);
	            }
	            hasParent = !!(elem.hierarchy && elem.hierarchy.length);
	            if (hasParent && !parent) {
	                parent = elem.hierarchy[0].layerInterface;
	            }
	            time = this.comp.renderedFrame/this.comp.globalData.frameRate;
	            if (needsVelocity) {
	                velocity = velocityAtTime(time);
	            }
	            expression_function();
	            this.frameExpressionId = elem.globalData.frameId;
	
	
	            //TODO: Check if it's possible to return on ShapeInterface the .v value
	            if (scoped_bm_rt.propType === "shape") {
	                scoped_bm_rt = scoped_bm_rt.v;
	            }
	            // globalData.popExpression();
	            return scoped_bm_rt;
	        }
	        return executeExpression;
	    }
	
	    ob.initiateExpression = initiateExpression;
	    return ob;
	}());
	var expressionHelpers = (function(){
	
	    function searchExpressions(elem,data,prop){
	        if(data.x){
	            prop.k = true;
	            prop.x = true;
	            prop.initiateExpression = ExpressionManager.initiateExpression;
	            prop.effectsSequence.push(prop.initiateExpression(elem,data,prop).bind(prop));
	        }
	    }
	
	    function getValueAtTime(frameNum) {
	        frameNum *= this.elem.globalData.frameRate;
	        frameNum -= this.offsetTime;
	        if(frameNum !== this._cachingAtTime.lastFrame) {
	            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
	            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
	            this._cachingAtTime.lastFrame = frameNum;
	        }
	        return this._cachingAtTime.value;
	
	    }
	
	    function getSpeedAtTime(frameNum) {
	        var delta = -0.01;
	        var v1 = this.getValueAtTime(frameNum);
	        var v2 = this.getValueAtTime(frameNum + delta);
	        var speed = 0;
	        if(v1.length){
	            var i;
	            for(i=0;i<v1.length;i+=1){
	                speed += Math.pow(v2[i] - v1[i], 2);
	            }
	            speed = Math.sqrt(speed) * 100;
	        } else {
	            speed = 0;
	        }
	        return speed;
	    }
	
	    function getVelocityAtTime(frameNum) {
	        if(this.vel !== undefined){
	            return this.vel;
	        }
	        var delta = -0.001;
	        //frameNum += this.elem.data.st;
	        var v1 = this.getValueAtTime(frameNum);
	        var v2 = this.getValueAtTime(frameNum + delta);
	        var velocity;
	        if(v1.length){
	            velocity = createTypedArray('float32', v1.length);
	            var i;
	            for(i=0;i<v1.length;i+=1){
	                //removing frameRate
	                //if needed, don't add it here
	                //velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
	                velocity[i] = (v2[i] - v1[i])/delta;
	            }
	        } else {
	            velocity = (v2 - v1)/delta;
	        }
	        return velocity;
	    }
	
	    function getStaticValueAtTime() {
	        return this.pv;
	    }
	
	    function setGroupProperty(propertyGroup){
	        this.propertyGroup = propertyGroup;
	    }
	
		return {
			searchExpressions: searchExpressions,
			getSpeedAtTime: getSpeedAtTime,
			getVelocityAtTime: getVelocityAtTime,
			getValueAtTime: getValueAtTime,
			getStaticValueAtTime: getStaticValueAtTime,
			setGroupProperty: setGroupProperty,
		}
	}());
	(function addPropertyDecorator() {
	
	    function loopOut(type,duration,durationFlag){
	        if(!this.k || !this.keyframes){
	            return this.pv;
	        }
	        type = type ? type.toLowerCase() : '';
	        var currentFrame = this.comp.renderedFrame;
	        var keyframes = this.keyframes;
	        var lastKeyFrame = keyframes[keyframes.length - 1].t;
	        if(currentFrame<=lastKeyFrame){
	            return this.pv;
	        }else{
	            var cycleDuration, firstKeyFrame;
	            if(!durationFlag){
	                if(!duration || duration > keyframes.length - 1){
	                    duration = keyframes.length - 1;
	                }
	                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
	                cycleDuration = lastKeyFrame - firstKeyFrame;
	            } else {
	                if(!duration){
	                    cycleDuration = Math.max(0,lastKeyFrame - this.elem.data.ip);
	                } else {
	                    cycleDuration = Math.abs(lastKeyFrame - elem.comp.globalData.frameRate*duration);
	                }
	                firstKeyFrame = lastKeyFrame - cycleDuration;
	            }
	            var i, len, ret;
	            if(type === 'pingpong') {
	                var iterations = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
	                if(iterations % 2 !== 0){
	                    return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
	                }
	            } else if(type === 'offset'){
	                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                var repeats = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
	                if(this.pv.length){
	                    ret = new Array(initV.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = (endV[i]-initV[i])*repeats + current[i];
	                    }
	                    return ret;
	                }
	                return (endV-initV)*repeats + current;
	            } else if(type === 'continue'){
	                var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
	                if(this.pv.length){
	                    ret = new Array(lastValue.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = lastValue[i] + (lastValue[i]-nextLastValue[i])*((currentFrame - lastKeyFrame)/ this.comp.globalData.frameRate)/0.0005;
	                    }
	                    return ret;
	                }
	                return lastValue + (lastValue-nextLastValue)*(((currentFrame - lastKeyFrame))/0.001);
	            }
	            return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
	        }
	    }
	
	    function loopIn(type,duration, durationFlag) {
	        if(!this.k){
	            return this.pv;
	        }
	        type = type ? type.toLowerCase() : '';
	        var currentFrame = this.comp.renderedFrame;
	        var keyframes = this.keyframes;
	        var firstKeyFrame = keyframes[0].t;
	        if(currentFrame>=firstKeyFrame){
	            return this.pv;
	        }else{
	            var cycleDuration, lastKeyFrame;
	            if(!durationFlag){
	                if(!duration || duration > keyframes.length - 1){
	                    duration = keyframes.length - 1;
	                }
	                lastKeyFrame = keyframes[duration].t;
	                cycleDuration = lastKeyFrame - firstKeyFrame;
	            } else {
	                if(!duration){
	                    cycleDuration = Math.max(0,this.elem.data.op - firstKeyFrame);
	                } else {
	                    cycleDuration = Math.abs(elem.comp.globalData.frameRate*duration);
	                }
	                lastKeyFrame = firstKeyFrame + cycleDuration;
	            }
	            var i, len, ret;
	            if(type === 'pingpong') {
	                var iterations = Math.floor((firstKeyFrame - currentFrame)/cycleDuration);
	                if(iterations % 2 === 0){
	                    return this.getValueAtTime((((firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
	                }
	            } else if(type === 'offset'){
	                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
	                var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
	                var repeats = Math.floor((firstKeyFrame - currentFrame)/cycleDuration)+1;
	                if(this.pv.length){
	                    ret = new Array(initV.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = current[i]-(endV[i]-initV[i])*repeats;
	                    }
	                    return ret;
	                }
	                return current-(endV-initV)*repeats;
	            } else if(type === 'continue'){
	                var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
	                var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
	                if(this.pv.length){
	                    ret = new Array(firstValue.length);
	                    len = ret.length;
	                    for(i=0;i<len;i+=1){
	                        ret[i] = firstValue[i] + (firstValue[i]-nextFirstValue[i])*(firstKeyFrame - currentFrame)/0.001;
	                    }
	                    return ret;
	                }
	                return firstValue + (firstValue-nextFirstValue)*(firstKeyFrame - currentFrame)/0.001;
	            }
	            return this.getValueAtTime(((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
	        }
	    }
	
	    function smooth(width, samples) {
	        if (!this.k){
	            return this.pv;
	        }
	        width = (width || 0.4) * 0.5;
	        samples = Math.floor(samples || 5);
	        if (samples <= 1) {
	            return this.pv;
	        }
	        var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
	        var initFrame = currentTime - width;
	        var endFrame = currentTime + width;
	        var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
	        var i = 0, j = 0;
	        var value;
	        if (this.pv.length) {
	            value = createTypedArray('float32', this.pv.length);
	        } else {
	            value = 0;
	        }
	        var sampleValue;
	        while (i < samples) {
	            sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
	            if(this.pv.length) {
	                for (j = 0; j < this.pv.length; j += 1) {
	                    value[j] += sampleValue[j];
	                }
	            } else {
	                value += sampleValue;
	            }
	            i += 1;
	        }
	        if(this.pv.length) {
	            for (j = 0; j < this.pv.length; j += 1) {
	                value[j] /= samples;
	            }
	        } else {
	            value /= samples;
	        }
	        return value;
	    }
	
	    function getValueAtTime(frameNum) {
	        frameNum *= this.elem.globalData.frameRate;
	        frameNum -= this.offsetTime;
	        if(frameNum !== this._cachingAtTime.lastFrame) {
	            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
	            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
	            this._cachingAtTime.lastFrame = frameNum;
	        }
	        return this._cachingAtTime.value;
	
	    }
	
	    function getTransformValueAtTime(time) {
	        console.warn('Transform at time not supported');
	    }
	
	    function getTransformStaticValueAtTime(time) {
	
	    }
	
	    var getTransformProperty = TransformPropertyFactory.getTransformProperty;
	    TransformPropertyFactory.getTransformProperty = function(elem, data, container) {
	        var prop = getTransformProperty(elem, data, container);
	        if(prop.dynamicProperties.length) {
	            prop.getValueAtTime = getTransformValueAtTime.bind(prop);
	        } else {
	            prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
	        }
	        prop.setGroupProperty = expressionHelpers.setGroupProperty;
	        return prop;
	    };
	
	    var propertyGetProp = PropertyFactory.getProp;
	    PropertyFactory.getProp = function(elem,data,type, mult, container){
	        var prop = propertyGetProp(elem,data,type, mult, container);
	        //prop.getVelocityAtTime = getVelocityAtTime;
	        //prop.loopOut = loopOut;
	        //prop.loopIn = loopIn;
	        if(prop.kf){
	            prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
	        } else {
	            prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
	        }
	        prop.setGroupProperty = expressionHelpers.setGroupProperty;
	        prop.loopOut = loopOut;
	        prop.loopIn = loopIn;
	        prop.smooth = smooth;
	        prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
	        prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
	        prop.numKeys = data.a === 1 ? data.k.length : 0;
	        prop.propertyIndex = data.ix;
	        var value = 0;
	        if(type !== 0) {
	            value = createTypedArray('float32', data.a === 1 ?  data.k[0].s.length : data.k.length);
	        }
	        prop._cachingAtTime = {
	            lastFrame: initialDefaultFrame,
	            lastIndex: 0,
	            value: value
	        };
	        expressionHelpers.searchExpressions(elem,data,prop);
	        if(prop.k){
	            container.addDynamicProperty(prop);
	        }
	
	        return prop;
	    };
	
	    function getShapeValueAtTime(frameNum) {
	        //For now this caching object is created only when needed instead of creating it when the shape is initialized.
	        if (!this._cachingAtTime) {
	            this._cachingAtTime = {
	                shapeValue: shape_pool.clone(this.pv),
	                lastIndex: 0,
	                lastTime: initialDefaultFrame
	            };
	        }
	        
	        frameNum *= this.elem.globalData.frameRate;
	        frameNum -= this.offsetTime;
	        if(frameNum !== this._cachingAtTime.lastTime) {
	            this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
	            this._cachingAtTime.lastTime = frameNum;
	            this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
	        }
	        return this._cachingAtTime.shapeValue;
	    }
	
	    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
	    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
	
	    function ShapeExpressions(){}
	    ShapeExpressions.prototype = {
	        vertices: function(prop, time){
	            if (this.k) {
	                this.getValue();
	            }
	            var shapePath = this.v;
	            if(time !== undefined) {
	                shapePath = this.getValueAtTime(time, 0);
	            }
	            var i, len = shapePath._length;
	            var vertices = shapePath[prop];
	            var points = shapePath.v;
	            var arr = createSizedArray(len);
	            for(i = 0; i < len; i += 1) {
	                if(prop === 'i' || prop === 'o') {
	                    arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
	                } else {
	                    arr[i] = [vertices[i][0], vertices[i][1]];
	                }
	                
	            }
	            return arr;
	        },
	        points: function(time){
	            return this.vertices('v', time);
	        },
	        inTangents: function(time){
	            return this.vertices('i', time);
	        },
	        outTangents: function(time){
	            return this.vertices('o', time);
	        },
	        isClosed: function(){
	            return this.v.c;
	        },
	        pointOnPath: function(perc, time){
	            var shapePath = this.v;
	            if(time !== undefined) {
	                shapePath = this.getValueAtTime(time, 0);
	            }
	            if(!this._segmentsLength) {
	                this._segmentsLength = bez.getSegmentsLength(shapePath);
	            }
	
	            var segmentsLength = this._segmentsLength;
	            var lengths = segmentsLength.lengths;
	            var lengthPos = segmentsLength.totalLength * perc;
	            var i = 0, len = lengths.length;
	            var j = 0, jLen;
	            var accumulatedLength = 0, pt;
	            while(i < len) {
	                if(accumulatedLength + lengths[i].addedLength > lengthPos) {
	                    var initIndex = i;
	                    var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
	                    var segmentPerc = (lengthPos - accumulatedLength)/lengths[i].addedLength;
	                    pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
	                    break;
	                } else {
	                    accumulatedLength += lengths[i].addedLength;
	                }
	                i += 1;
	            }
	            if(!pt){
	                pt = shapePath.c ? [shapePath.v[0][0],shapePath.v[0][1]]:[shapePath.v[shapePath._length-1][0],shapePath.v[shapePath._length-1][1]];
	            }
	            return pt;
	        },
	        vectorOnPath: function(perc, time, vectorType){
	            //perc doesn't use triple equality because it can be a Number object as well as a primitive.
	            perc = perc == 1 ? this.v.c ? 0 : 0.999 : perc;
	            var pt1 = this.pointOnPath(perc, time);
	            var pt2 = this.pointOnPath(perc + 0.001, time);
	            var xLength = pt2[0] - pt1[0];
	            var yLength = pt2[1] - pt1[1];
	            var magnitude = Math.sqrt(Math.pow(xLength,2) + Math.pow(yLength,2));
	            if (magnitude === 0) {
	                return [0,0];
	            }
	            var unitVector = vectorType === 'tangent' ? [xLength/magnitude, yLength/magnitude] : [-yLength/magnitude, xLength/magnitude];
	            return unitVector;
	        },
	        tangentOnPath: function(perc, time){
	            return this.vectorOnPath(perc, time, 'tangent');
	        },
	        normalOnPath: function(perc, time){
	            return this.vectorOnPath(perc, time, 'normal');
	        },
	        setGroupProperty: expressionHelpers.setGroupProperty,
	        getValueAtTime: expressionHelpers.getStaticValueAtTime
	    };
	    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
	    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
	    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
	    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
	
	    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
	    ShapePropertyFactory.getShapeProp = function(elem,data,type, arr, trims){
	        var prop = propertyGetShapeProp(elem,data,type, arr, trims);
	        prop.propertyIndex = data.ix;
	        prop.lock = false;
	        if(type === 3){
	            expressionHelpers.searchExpressions(elem,data.pt,prop);
	        } else if(type === 4){
	            expressionHelpers.searchExpressions(elem,data.ks,prop);
	        }
	        if(prop.k){
	            elem.addDynamicProperty(prop);
	        }
	        return prop;
	    };
	}());
	(function addDecorator() {
	
	    function searchExpressions(){
	        if(this.data.d.x){
	            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem,this.data.d,this);
	            this.addEffect(this.getExpressionValue.bind(this));
	            return true;
	        }
	    }
	
	    TextProperty.prototype.getExpressionValue = function(currentValue, text) {
	        var newValue = this.calculateExpression(text);
	        if(currentValue.t !== newValue) {
	            var newData = {};
	            this.copyData(newData, currentValue);
	            newData.t = newValue.toString();
	            newData.__complete = false;
	            return newData;
	        }
	        return currentValue;
	    }
	
	    TextProperty.prototype.searchProperty = function(){
	
	        var isKeyframed = this.searchKeyframes();
	        var hasExpressions = this.searchExpressions();
	        this.kf = isKeyframed || hasExpressions;
	        return this.kf;
	    };
	
	    TextProperty.prototype.searchExpressions = searchExpressions;
	    
	}());
	var ShapeExpressionInterface = (function(){
	
	    function iterateElements(shapes,view, propertyGroup){
	        var arr = [];
	        var i, len = shapes ? shapes.length : 0;
	        for(i=0;i<len;i+=1){
	            if(shapes[i].ty == 'gr'){
	                arr.push(groupInterfaceFactory(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'fl'){
	                arr.push(fillInterfaceFactory(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'st'){
	                arr.push(strokeInterfaceFactory(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'tm'){
	                arr.push(trimInterfaceFactory(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'tr'){
	                //arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'el'){
	                arr.push(ellipseInterfaceFactory(shapes[i],view[i],propertyGroup));
	            }else if(shapes[i].ty == 'sr'){
	                arr.push(starInterfaceFactory(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'sh'){
	                arr.push(pathInterfaceFactory(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rc'){
	                arr.push(rectInterfaceFactory(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rd'){
	                arr.push(roundedInterfaceFactory(shapes[i],view[i],propertyGroup));
	            } else if(shapes[i].ty == 'rp'){
	                arr.push(repeaterInterfaceFactory(shapes[i],view[i],propertyGroup));
	            }
	        }
	        return arr;
	    }
	
	    function contentsInterfaceFactory(shape,view, propertyGroup){
	       var interfaces;
	       var interfaceFunction = function _interfaceFunction(value){
	           var i = 0, len = interfaces.length;
	            while(i<len){
	                if(interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value){
	                   return interfaces[i];
	                }
	                i+=1;
	            }
	            if(typeof value === 'number'){
	               return interfaces[value-1];
	            }
	       };
	       interfaceFunction.propertyGroup = function(val){
	           if(val === 1){
	               return interfaceFunction;
	           } else{
	               return propertyGroup(val-1);
	           }
	       };
	       interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
	       interfaceFunction.numProperties = interfaces.length;
	       interfaceFunction.propertyIndex = shape.cix;
	       interfaceFunction._name = shape.nm;
	
	       return interfaceFunction;
	   }
	
	    function groupInterfaceFactory(shape,view, propertyGroup){
	        var interfaceFunction = function _interfaceFunction(value){
	            switch(value){
	                case 'ADBE Vectors Group':
	                case 'Contents':
	                case 2:
	                    return interfaceFunction.content;
	                //Not necessary for now. Keeping them here in case a new case appears
	                //case 'ADBE Vector Transform Group':
	                //case 3:
	                default:
	                    return interfaceFunction.transform;
	            }
	        };
	        interfaceFunction.propertyGroup = function(val){
	            if(val === 1){
	                return interfaceFunction;
	            } else{
	                return propertyGroup(val-1);
	            }
	        };
	        var content = contentsInterfaceFactory(shape,view,interfaceFunction.propertyGroup);
	        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1],view.it[view.it.length - 1],interfaceFunction.propertyGroup);
	        interfaceFunction.content = content;
	        interfaceFunction.transform = transformInterface;
	        Object.defineProperty(interfaceFunction, '_name', {
	            get: function(){
	                return shape.nm;
	            }
	        });
	        //interfaceFunction.content = interfaceFunction;
	        interfaceFunction.numProperties = shape.np;
	        interfaceFunction.propertyIndex = shape.ix;
	        interfaceFunction.nm = shape.nm;
	        interfaceFunction.mn = shape.mn;
	        return interfaceFunction;
	    }
	
	    function fillInterfaceFactory(shape,view,propertyGroup){
	        function interfaceFunction(val){
	            if(val === 'Color' || val === 'color'){
	                return interfaceFunction.color;
	            } else if(val === 'Opacity' || val === 'opacity'){
	                return interfaceFunction.opacity;
	            }
	        }
	        Object.defineProperties(interfaceFunction, {
	            'color': {
	                get: ExpressionPropertyInterface(view.c)
	            },
	            'opacity': {
	                get: ExpressionPropertyInterface(view.o)
	            },
	            '_name': { value: shape.nm },
	            'mn': { value: shape.mn }
	        });
	
	        view.c.setGroupProperty(propertyGroup);
	        view.o.setGroupProperty(propertyGroup);
	        return interfaceFunction;
	    }
	
	    function strokeInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val === 1){
	                return ob;
	            } else{
	                return propertyGroup(val-1);
	            }
	        }
	        function _dashPropertyGroup(val){
	            if(val === 1){
	                return dashOb;
	            } else{
	                return _propertyGroup(val-1);
	            }
	        }
	        function addPropertyToDashOb(i) {
	            Object.defineProperty(dashOb, shape.d[i].nm, {
	                get: ExpressionPropertyInterface(view.d.dataProps[i].p)
	            });
	        }
	        var i, len = shape.d ? shape.d.length : 0;
	        var dashOb = {};
	        for (i = 0; i < len; i += 1) {
	            addPropertyToDashOb(i);
	            view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
	        }
	
	        function interfaceFunction(val){
	            if(val === 'Color' || val === 'color'){
	                return interfaceFunction.color;
	            } else if(val === 'Opacity' || val === 'opacity'){
	                return interfaceFunction.opacity;
	            } else if(val === 'Stroke Width' || val === 'stroke width'){
	                return interfaceFunction.strokeWidth;
	            }
	        }
	        Object.defineProperties(interfaceFunction, {
	            'color': {
	                get: ExpressionPropertyInterface(view.c)
	            },
	            'opacity': {
	                get: ExpressionPropertyInterface(view.o)
	            },
	            'strokeWidth': {
	                get: ExpressionPropertyInterface(view.w)
	            },
	            'dash': {
	                get: function() {
	                    return dashOb;
	                }
	            },
	            '_name': { value: shape.nm },
	            'mn': { value: shape.mn }
	        });
	
	        view.c.setGroupProperty(_propertyGroup);
	        view.o.setGroupProperty(_propertyGroup);
	        view.w.setGroupProperty(_propertyGroup);
	        return interfaceFunction;
	    }
	
	    function trimInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        interfaceFunction.propertyIndex = shape.ix;
	
	        view.s.setGroupProperty(_propertyGroup);
	        view.e.setGroupProperty(_propertyGroup);
	        view.o.setGroupProperty(_propertyGroup);
	
	        function interfaceFunction(val){
	            if(val === shape.e.ix || val === 'End' || val === 'end'){
	                return interfaceFunction.end;
	            }
	            if(val === shape.s.ix){
	                return interfaceFunction.start;
	            }
	            if(val === shape.o.ix){
	                return interfaceFunction.offset;
	            }
	        }
	        interfaceFunction.propertyIndex = shape.ix;
	        interfaceFunction.propertyGroup = propertyGroup;
	
	        Object.defineProperties(interfaceFunction, {
	            'start': {
	                get: ExpressionPropertyInterface(view.s)
	            },
	            'end': {
	                get: ExpressionPropertyInterface(view.e)
	            },
	            'offset': {
	                get: ExpressionPropertyInterface(view.o)
	            },
	            '_name': { value: shape.nm }
	        });
	        interfaceFunction.mn = shape.mn;
	        return interfaceFunction;
	    }
	
	    function transformInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        view.transform.mProps.o.setGroupProperty(_propertyGroup);
	        view.transform.mProps.p.setGroupProperty(_propertyGroup);
	        view.transform.mProps.a.setGroupProperty(_propertyGroup);
	        view.transform.mProps.s.setGroupProperty(_propertyGroup);
	        view.transform.mProps.r.setGroupProperty(_propertyGroup);
	        if(view.transform.mProps.sk){
	            view.transform.mProps.sk.setGroupProperty(_propertyGroup);
	            view.transform.mProps.sa.setGroupProperty(_propertyGroup);
	        }
	        view.transform.op.setGroupProperty(_propertyGroup);
	
	        function interfaceFunction(value){
	            if(shape.a.ix === value || value === 'Anchor Point'){
	                return interfaceFunction.anchorPoint;
	            }
	            if(shape.o.ix === value || value === 'Opacity'){
	                return interfaceFunction.opacity;
	            }
	            if(shape.p.ix === value || value === 'Position'){
	                return interfaceFunction.position;
	            }
	            if(shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation'){
	                return interfaceFunction.rotation;
	            }
	            if(shape.s.ix === value || value === 'Scale'){
	                return interfaceFunction.scale;
	            }
	            if(shape.sk && shape.sk.ix === value || value === 'Skew'){
	                return interfaceFunction.skew;
	            }
	            if(shape.sa && shape.sa.ix === value || value === 'Skew Axis'){
	                return interfaceFunction.skewAxis;
	            }
	
	        }
	        Object.defineProperties(interfaceFunction, {
	            'opacity': {
	                get: ExpressionPropertyInterface(view.transform.mProps.o)
	            },
	            'position': {
	                get: ExpressionPropertyInterface(view.transform.mProps.p)
	            },
	            'anchorPoint': {
	                get: ExpressionPropertyInterface(view.transform.mProps.a)
	            },
	            'scale': {
	                get: ExpressionPropertyInterface(view.transform.mProps.s)
	            },
	            'rotation': {
	                get: ExpressionPropertyInterface(view.transform.mProps.r)
	            },
	            'skew': {
	                get: ExpressionPropertyInterface(view.transform.mProps.sk)
	            },
	            'skewAxis': {
	                get: ExpressionPropertyInterface(view.transform.mProps.sa)
	            },
	            '_name': { value: shape.nm }
	        });
	        interfaceFunction.ty = 'tr';
	        interfaceFunction.mn = shape.mn;
	        interfaceFunction.propertyGroup = propertyGroup;
	        return interfaceFunction;
	    }
	
	    function ellipseInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        interfaceFunction.propertyIndex = shape.ix;
	        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	        prop.s.setGroupProperty(_propertyGroup);
	        prop.p.setGroupProperty(_propertyGroup);
	        function interfaceFunction(value){
	            if(shape.p.ix === value){
	                return interfaceFunction.position;
	            }
	            if(shape.s.ix === value){
	                return interfaceFunction.size;
	            }
	        }
	
	        Object.defineProperties(interfaceFunction, {
	            'size': {
	                get: ExpressionPropertyInterface(prop.s)
	            },
	            'position': {
	                get: ExpressionPropertyInterface(prop.p)
	            },
	            '_name': { value: shape.nm }
	        });
	        interfaceFunction.mn = shape.mn;
	        return interfaceFunction;
	    }
	
	    function starInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	        interfaceFunction.propertyIndex = shape.ix;
	        prop.or.setGroupProperty(_propertyGroup);
	        prop.os.setGroupProperty(_propertyGroup);
	        prop.pt.setGroupProperty(_propertyGroup);
	        prop.p.setGroupProperty(_propertyGroup);
	        prop.r.setGroupProperty(_propertyGroup);
	        if(shape.ir){
	            prop.ir.setGroupProperty(_propertyGroup);
	            prop.is.setGroupProperty(_propertyGroup);
	        }
	
	        function interfaceFunction(value){
	            if(shape.p.ix === value){
	                return interfaceFunction.position;
	            }
	            if(shape.r.ix === value){
	                return interfaceFunction.rotation;
	            }
	            if(shape.pt.ix === value){
	                return interfaceFunction.points;
	            }
	            if(shape.or.ix === value || 'ADBE Vector Star Outer Radius' === value){
	                return interfaceFunction.outerRadius;
	            }
	            if(shape.os.ix === value){
	                return interfaceFunction.outerRoundness;
	            }
	            if(shape.ir && (shape.ir.ix === value || 'ADBE Vector Star Inner Radius' === value)){
	                return interfaceFunction.innerRadius;
	            }
	            if(shape.is && shape.is.ix === value){
	                return interfaceFunction.innerRoundness;
	            }
	
	        }
	
	        Object.defineProperties(interfaceFunction, {
	            'position': {
	                get: ExpressionPropertyInterface(prop.p)
	            },
	            'rotation': {
	                get: ExpressionPropertyInterface(prop.r)
	            },
	            'points': {
	                get: ExpressionPropertyInterface(prop.pt)
	            },
	            'outerRadius': {
	                get: ExpressionPropertyInterface(prop.or)
	            },
	            'outerRoundness': {
	                get: ExpressionPropertyInterface(prop.os)
	            },
	            'innerRadius': {
	                get: ExpressionPropertyInterface(prop.ir)
	            },
	            'innerRoundness': {
	                get: ExpressionPropertyInterface(prop.is)
	            },
	            '_name': { value: shape.nm }
	        });
	        interfaceFunction.mn = shape.mn;
	        return interfaceFunction;
	    }
	
	    function rectInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
	        interfaceFunction.propertyIndex = shape.ix;
	        prop.p.setGroupProperty(_propertyGroup);
	        prop.s.setGroupProperty(_propertyGroup);
	        prop.r.setGroupProperty(_propertyGroup);
	
	        function interfaceFunction(value){
	            if(shape.p.ix === value){
	                return interfaceFunction.position;
	            }
	            if(shape.r.ix === value){
	                return interfaceFunction.roundness;
	            }
	            if(shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size'){
	                return interfaceFunction.size;
	            }
	
	        }
	        Object.defineProperties(interfaceFunction, {
	            'position': {
	                get: ExpressionPropertyInterface(prop.p)
	            },
	            'roundness': {
	                get: ExpressionPropertyInterface(prop.r)
	            },
	            'size': {
	                get: ExpressionPropertyInterface(prop.s)
	            },
	            '_name': { value: shape.nm }
	        });
	        interfaceFunction.mn = shape.mn;
	        return interfaceFunction;
	    }
	
	    function roundedInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        var prop = view;
	        interfaceFunction.propertyIndex = shape.ix;
	        prop.rd.setGroupProperty(_propertyGroup);
	
	        function interfaceFunction(value){
	            if(shape.r.ix === value || 'Round Corners 1' === value){
	                return interfaceFunction.radius;
	            }
	
	        }
	        Object.defineProperties(interfaceFunction, {
	            'radius': {
	                get: ExpressionPropertyInterface(prop.rd)
	            },
	            '_name': { value: shape.nm }
	        });
	        interfaceFunction.mn = shape.mn;
	        return interfaceFunction;
	    }
	
	    function repeaterInterfaceFactory(shape,view,propertyGroup){
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        var prop = view;
	        interfaceFunction.propertyIndex = shape.ix;
	        prop.c.setGroupProperty(_propertyGroup);
	        prop.o.setGroupProperty(_propertyGroup);
	
	        function interfaceFunction(value){
	            if(shape.c.ix === value || 'Copies' === value){
	                return interfaceFunction.copies;
	            } else if(shape.o.ix === value || 'Offset' === value){
	                return interfaceFunction.offset;
	            }
	
	        }
	        Object.defineProperties(interfaceFunction, {
	            'copies': {
	                get: ExpressionPropertyInterface(prop.c)
	            },
	            'offset': {
	                get: ExpressionPropertyInterface(prop.o)
	            },
	            '_name': { value: shape.nm }
	        });
	        interfaceFunction.mn = shape.mn;
	        return interfaceFunction;
	    }
	
	    function pathInterfaceFactory(shape,view,propertyGroup){
	        var prop = view.sh;
	        function _propertyGroup(val){
	            if(val == 1){
	                return interfaceFunction;
	            } else {
	                return propertyGroup(--val);
	            }
	        }
	        prop.setGroupProperty(_propertyGroup);
	
	        function interfaceFunction(val){
	            if(val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2){
	                return interfaceFunction.path;
	            }
	        }
	        Object.defineProperties(interfaceFunction, {
	            'path': {
	                get: function(){
	                    if(prop.k){
	                        prop.getValue();
	                    }
	                    return prop;
	                }
	            },
	            'shape': {
	                get: function(){
	                    if(prop.k){
	                        prop.getValue();
	                    }
	                    return prop;
	                }
	            },
	            '_name': { value: shape.nm },
	            'ix': { value: shape.ix },
	            'mn': { value: shape.mn }
	        });
	        return interfaceFunction;
	    }
	
	    return function(shapes,view,propertyGroup) {
	        var interfaces;
	        function _interfaceFunction(value){
	            if(typeof value === 'number'){
	                return interfaces[value-1];
	            } else {
	                var i = 0, len = interfaces.length;
	                while(i<len){
	                    if(interfaces[i]._name === value){
	                        return interfaces[i];
	                    }
	                    i+=1;
	                }
	            }
	        }
	        _interfaceFunction.propertyGroup = propertyGroup;
	        interfaces = iterateElements(shapes, view, _interfaceFunction);
	        _interfaceFunction.numProperties = interfaces.length;
	        return _interfaceFunction;
	    };
	}());
	
	var TextExpressionInterface = (function(){
		return function(elem){
	        var _prevValue, _sourceText;
	        function _thisLayerFunction(){
	        }
	        Object.defineProperty(_thisLayerFunction, "sourceText", {
	            get: function(){
	                elem.textProperty.getValue()
	                var stringValue = elem.textProperty.currentData.t;
	                if(stringValue !== _prevValue) {
	                    elem.textProperty.currentData.t = _prevValue;
	                    _sourceText = new String(stringValue);
	                    //If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
	                    _sourceText.value = stringValue ? stringValue : new String(stringValue);
	                }
	                return _sourceText;
	            }
	        });
	        return _thisLayerFunction;
	    };
	}());
	var LayerExpressionInterface = (function (){
	    function toWorld(arr, time){
	        var toWorldMat = new Matrix();
	        toWorldMat.reset();
	        var transformMat;
	        if(time) {
	            //Todo implement value at time on transform properties
	            //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
	            transformMat = this._elem.finalTransform.mProp;
	        } else {
	            transformMat = this._elem.finalTransform.mProp;
	        }
	        transformMat.applyToMatrix(toWorldMat);
	        if(this._elem.hierarchy && this._elem.hierarchy.length){
	            var i, len = this._elem.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	            }
	            return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
	        }
	        return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
	    }
	    function fromWorld(arr, time){
	        var toWorldMat = new Matrix();
	        toWorldMat.reset();
	        var transformMat;
	        if(time) {
	            //Todo implement value at time on transform properties
	            //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
	            transformMat = this._elem.finalTransform.mProp;
	        } else {
	            transformMat = this._elem.finalTransform.mProp;
	        }
	        transformMat.applyToMatrix(toWorldMat);
	        if(this._elem.hierarchy && this._elem.hierarchy.length){
	            var i, len = this._elem.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	            }
	            return toWorldMat.inversePoint(arr);
	        }
	        return toWorldMat.inversePoint(arr);
	    }
	    function fromComp(arr){
	        var toWorldMat = new Matrix();
	        toWorldMat.reset();
	        this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
	        if(this._elem.hierarchy && this._elem.hierarchy.length){
	            var i, len = this._elem.hierarchy.length;
	            for(i=0;i<len;i+=1){
	                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
	            }
	            return toWorldMat.inversePoint(arr);
	        }
	        return toWorldMat.inversePoint(arr);
	    }
	
	    function sampleImage() {
	        return [1,1,1,1];
	    }
	
	
	    return function(elem){
	
	        var transformInterface;
	
	        function _registerMaskInterface(maskManager){
	            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
	        }
	        function _registerEffectsInterface(effects){
	            _thisLayerFunction.effect = effects;
	        }
	
	        function _thisLayerFunction(name){
	            switch(name){
	                case "ADBE Root Vectors Group":
	                case "Contents":
	                case 2:
	                    return _thisLayerFunction.shapeInterface;
	                case 1:
	                case 6:
	                case "Transform":
	                case "transform":
	                case "ADBE Transform Group":
	                    return transformInterface;
	                case 4:
	                case "ADBE Effect Parade":
	                case "effects":
	                case "Effects":
	                    return _thisLayerFunction.effect;
	            }
	        }
	        _thisLayerFunction.toWorld = toWorld;
	        _thisLayerFunction.fromWorld = fromWorld;
	        _thisLayerFunction.toComp = toWorld;
	        _thisLayerFunction.fromComp = fromComp;
	        _thisLayerFunction.sampleImage = sampleImage;
	        _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
	        _thisLayerFunction._elem = elem;
	        transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
	        var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
	        Object.defineProperties(_thisLayerFunction,{
	            hasParent: {
	                get: function(){
	                    return elem.hierarchy.length;
	                }
	            },
	            parent: {
	                get: function(){
	                    return elem.hierarchy[0].layerInterface;
	                }
	            },
	            rotation: getDescriptor(transformInterface, 'rotation'),
	            scale: getDescriptor(transformInterface, 'scale'),
	            position: getDescriptor(transformInterface, 'position'),
	            opacity: getDescriptor(transformInterface, 'opacity'),
	            anchorPoint: anchorPointDescriptor,
	            anchor_point: anchorPointDescriptor,
	            transform: {
	                get: function () {
	                    return transformInterface;
	                }
	            },
	            active: {
	                get: function(){
	                    return elem.isInRange;
	                }
	            }
	        });
	
	        _thisLayerFunction.startTime = elem.data.st;
	        _thisLayerFunction.index = elem.data.ind;
	        _thisLayerFunction.source = elem.data.refId;
	        _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
	        _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
	        _thisLayerFunction.inPoint = elem.data.ip/elem.comp.globalData.frameRate;
	        _thisLayerFunction.outPoint = elem.data.op/elem.comp.globalData.frameRate;
	        _thisLayerFunction._name = elem.data.nm;
	
	        _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
	        _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
	        return _thisLayerFunction;
	    };
	}());
	
	var CompExpressionInterface = (function () {
	    return function(comp) {
	        function _thisLayerFunction(name) {
	            var i = 0, len = comp.layers.length;
	            while ( i < len) {
	                if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
	                    return comp.elements[i].layerInterface;
	                }
	                i += 1;
	            }
	            return null;
	            //return {active:false};
	        }
	        Object.defineProperty(_thisLayerFunction, "_name", { value: comp.data.nm });
	        _thisLayerFunction.layer = _thisLayerFunction;
	        _thisLayerFunction.pixelAspect = 1;
	        _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
	        _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
	        _thisLayerFunction.pixelAspect = 1;
	        _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
	        _thisLayerFunction.displayStartTime = 0;
	        _thisLayerFunction.numLayers = comp.layers.length;
	        return _thisLayerFunction;
	    };
	}());
	var TransformExpressionInterface = (function (){
	    return function(transform){
	        function _thisFunction(name){
	            switch(name){
	                case "scale":
	                case "Scale":
	                case "ADBE Scale":
	                case 6:
	                    return _thisFunction.scale;
	                case "rotation":
	                case "Rotation":
	                case "ADBE Rotation":
	                case "ADBE Rotate Z":
	                case 10:
	                    return _thisFunction.rotation;
	                case "ADBE Rotate X":
	                    return _thisFunction.xRotation;
	                case "ADBE Rotate Y":
	                    return _thisFunction.yRotation;
	                case "position":
	                case "Position":
	                case "ADBE Position":
	                case 2:
	                    return _thisFunction.position;
	                case 'ADBE Position_0':
	                    return _thisFunction.xPosition;
	                case 'ADBE Position_1':
	                    return _thisFunction.yPosition;
	                case 'ADBE Position_2':
	                    return _thisFunction.zPosition;
	                case "anchorPoint":
	                case "AnchorPoint":
	                case "Anchor Point":
	                case "ADBE AnchorPoint":
	                case 1:
	                    return _thisFunction.anchorPoint;
	                case "opacity":
	                case "Opacity":
	                case 11:
	                    return _thisFunction.opacity;
	            }
	        }
	
	        Object.defineProperty(_thisFunction, "rotation", {
	            get: ExpressionPropertyInterface(transform.r || transform.rz)
	        });
	
	        Object.defineProperty(_thisFunction, "zRotation", {
	            get: ExpressionPropertyInterface(transform.rz || transform.r)
	        });
	
	        Object.defineProperty(_thisFunction, "xRotation", {
	            get: ExpressionPropertyInterface(transform.rx)
	        });
	
	        Object.defineProperty(_thisFunction, "yRotation", {
	            get: ExpressionPropertyInterface(transform.ry)
	        });
	        Object.defineProperty(_thisFunction, "scale", {
	            get: ExpressionPropertyInterface(transform.s)
	        });
	
	        if(transform.p) {
	            var _transformFactory = ExpressionPropertyInterface(transform.p);
	        }
	        Object.defineProperty(_thisFunction, "position", {
	            get: function () {
	                if(transform.p) {
	                    return _transformFactory();
	                } else {
	                    return [transform.px.v, transform.py.v, transform.pz ? transform.pz.v : 0];
	                }
	            }
	        });
	
	        Object.defineProperty(_thisFunction, "xPosition", {
	            get: ExpressionPropertyInterface(transform.px)
	        });
	
	        Object.defineProperty(_thisFunction, "yPosition", {
	            get: ExpressionPropertyInterface(transform.py)
	        });
	
	        Object.defineProperty(_thisFunction, "zPosition", {
	            get: ExpressionPropertyInterface(transform.pz)
	        });
	
	        Object.defineProperty(_thisFunction, "anchorPoint", {
	            get: ExpressionPropertyInterface(transform.a)
	        });
	
	        Object.defineProperty(_thisFunction, "opacity", {
	            get: ExpressionPropertyInterface(transform.o)
	        });
	
	        Object.defineProperty(_thisFunction, "skew", {
	            get: ExpressionPropertyInterface(transform.sk)
	        });
	
	        Object.defineProperty(_thisFunction, "skewAxis", {
	            get: ExpressionPropertyInterface(transform.sa)
	        });
	
	        Object.defineProperty(_thisFunction, "orientation", {
	            get: ExpressionPropertyInterface(transform.or)
	        });
	
	        return _thisFunction;
	    };
	}());
	var ProjectInterface = (function (){
	
	    function registerComposition(comp){
	        this.compositions.push(comp);
	    }
	
	    return function(){
	        function _thisProjectFunction(name){
	            var i = 0, len = this.compositions.length;
	            while(i<len){
	                if(this.compositions[i].data && this.compositions[i].data.nm === name){
	                    if(this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
	                        this.compositions[i].prepareFrame(this.currentFrame);
	                    }
	                    return this.compositions[i].compInterface;
	                }
	                i+=1;
	            }
	        }
	
	        _thisProjectFunction.compositions = [];
	        _thisProjectFunction.currentFrame = 0;
	
	        _thisProjectFunction.registerComposition = registerComposition;
	
	
	
	        return _thisProjectFunction;
	    };
	}());
	var EffectsExpressionInterface = (function (){
	    var ob = {
	        createEffectsInterface: createEffectsInterface
	    };
	
	    function createEffectsInterface(elem, propertyGroup){
	        if(elem.effectsManager){
	
	            var effectElements = [];
	            var effectsData = elem.data.ef;
	            var i, len = elem.effectsManager.effectElements.length;
	            for(i=0;i<len;i+=1){
	                effectElements.push(createGroupInterface(effectsData[i],elem.effectsManager.effectElements[i],propertyGroup,elem));
	            }
	
	            return function(name){
	                var effects = elem.data.ef || [], i = 0, len = effects.length;
	                while(i<len) {
	                    if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
	                        return effectElements[i];
	                    }
	                    i += 1;
	                }
	            };
	        }
	    }
	
	    function createGroupInterface(data,elements, propertyGroup, elem){
	        var effectElements = [];
	        var i, len = data.ef.length;
	        for(i=0;i<len;i+=1){
	            if(data.ef[i].ty === 5){
	                effectElements.push(createGroupInterface(data.ef[i],elements.effectElements[i],elements.effectElements[i].propertyGroup, elem));
	            } else {
	                effectElements.push(createValueInterface(elements.effectElements[i],data.ef[i].ty, elem, _propertyGroup));
	            }
	        }
	
	        function _propertyGroup(val) {
	            if(val === 1){
	               return groupInterface;
	            } else{
	               return propertyGroup(val-1);
	            }
	        }
	
	        var groupInterface = function(name){
	            var effects = data.ef, i = 0, len = effects.length;
	            while(i<len) {
	                if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
	                    if(effects[i].ty === 5){
	                        return effectElements[i];
	                    } else {
	                        return effectElements[i]();
	                    }
	                }
	                i += 1;
	            }
	            return effectElements[0]();
	        };
	
	        groupInterface.propertyGroup = _propertyGroup;
	
	        if(data.mn === 'ADBE Color Control'){
	            Object.defineProperty(groupInterface, 'color', {
	                get: function(){
	                    return effectElements[0]();
	                }
	            });
	        }
	        Object.defineProperty(groupInterface, 'numProperties', {
	            get: function(){
	                return data.np;
	            }
	        });
	        groupInterface.active = groupInterface.enabled = data.en !== 0;
	        return groupInterface;
	    }
	
	    function createValueInterface(element, type, elem, propertyGroup){
	        var expressionProperty = ExpressionPropertyInterface(element.p);
	        function interfaceFunction(){
	            if(type === 10){
	                return elem.comp.compInterface(element.p.v);
	            }
	            return expressionProperty();
	        }
	
	        if(element.p.setGroupProperty) {
	            element.p.setGroupProperty(propertyGroup);
	        }
	
	        return interfaceFunction;
	    }
	
	    return ob;
	
	}());
	var MaskManagerInterface = (function(){
	
		function MaskInterface(mask, data){
			this._mask = mask;
			this._data = data;
		}
		Object.defineProperty(MaskInterface.prototype, 'maskPath', {
	        get: function(){
	            if(this._mask.prop.k){
	                this._mask.prop.getValue();
	            }
	            return this._mask.prop;
	        }
	    });
		Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
	        get: function(){
	            if(this._mask.op.k){
	                this._mask.op.getValue();
	            }
	            return this._mask.op.v * 100;
	        }
	    });
	
		var MaskManager = function(maskManager, elem){
			var _maskManager = maskManager;
			var _elem = elem;
			var _masksInterfaces = createSizedArray(maskManager.viewData.length);
			var i, len = maskManager.viewData.length;
			for(i = 0; i < len; i += 1) {
				_masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
			}
	
			var maskFunction = function(name){
				i = 0;
			    while(i<len){
			        if(maskManager.masksProperties[i].nm === name){
			            return _masksInterfaces[i];
			        }
			        i += 1;
			    }
			};
			return maskFunction;
		};
		return MaskManager;
	}());
	
	var ExpressionPropertyInterface = (function() {
	
	    var defaultUnidimensionalValue = {pv:0, v:0, mult: 1}
	    var defaultMultidimensionalValue = {pv:[0,0,0], v:[0,0,0], mult: 1}
	
	    function completeProperty(expressionValue, property, type) {
	        Object.defineProperty(expressionValue, 'velocity', {
	            get: function(){
	                return property.getVelocityAtTime(property.comp.currentFrame);
	            }
	        });
	        expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
	        expressionValue.key = function(pos) {
	            if (!expressionValue.numKeys) {
	                return 0;
	            } else {
	                var value = '';
	                if ('s' in property.keyframes[pos-1]) {
	                    value = property.keyframes[pos-1].s;
	                } else if ('e' in property.keyframes[pos-2]) {
	                    value = property.keyframes[pos-2].e;
	                } else {
	                    value = property.keyframes[pos-2].s;
	                }
	                var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value);
	                valueProp.time = property.keyframes[pos-1].t / property.elem.comp.globalData.frameRate;
	                return valueProp;
	            }
	        };
	        expressionValue.valueAtTime = property.getValueAtTime;
	        expressionValue.speedAtTime = property.getSpeedAtTime;
	        expressionValue.velocityAtTime = property.getVelocityAtTime;
	        expressionValue.propertyGroup = property.propertyGroup;
	    }
	
	    function UnidimensionalPropertyInterface(property) {
	        if(!property || !('pv' in property)) {
	            property = defaultUnidimensionalValue;
	        }
	        var mult = 1 / property.mult;
	        var val = property.pv * mult;
	        var expressionValue = new Number(val);
	        expressionValue.value = val;
	        completeProperty(expressionValue, property, 'unidimensional');
	
	        return function() {
	            if (property.k) {
	                property.getValue();
	            }
	            val = property.v * mult;
	            if(expressionValue.value !== val) {
	                expressionValue = new Number(val);
	                expressionValue.value = val;
	                completeProperty(expressionValue, property, 'unidimensional');
	            }
	            return expressionValue;
	        }
	    }
	
	    function MultidimensionalPropertyInterface(property) {
	        if(!property || !('pv' in property)) {
	            property = defaultMultidimensionalValue;
	        }
	        var mult = 1 / property.mult;
	        var len = property.pv.length;
	        var expressionValue = createTypedArray('float32', len);
	        var arrValue = createTypedArray('float32', len);
	        expressionValue.value = arrValue;
	        completeProperty(expressionValue, property, 'multidimensional');
	
	        return function() {
	            if (property.k) {
	                property.getValue();
	            }
	            for (var i = 0; i < len; i += 1) {
	                expressionValue[i] = arrValue[i] = property.v[i] * mult;
	            }
	            return expressionValue;
	        }
	    }
	
	    //TODO: try to avoid using this getter
	    function defaultGetter() {
	        return defaultUnidimensionalValue;
	    }
	    
	    return function(property) {
	        if(!property) {
	            return defaultGetter;
	        } else if (property.propType === 'unidimensional') {
	            return UnidimensionalPropertyInterface(property);
	        } else {
	            return MultidimensionalPropertyInterface(property);
	        }
	    }
	}());
	
	(function(){
	
	    var TextExpressionSelectorProp = (function(){
	
	        function getValueProxy(index,total){
	            this.textIndex = index+1;
	            this.textTotal = total;
	            this.v = this.getValue() * this.mult;
	            return this.v;
	        }
	
	        return function TextExpressionSelectorProp(elem,data){
	            this.pv = 1;
	            this.comp = elem.comp;
	            this.elem = elem;
	            this.mult = 0.01;
	            this.propType = 'textSelector';
	            this.textTotal = data.totalChars;
	            this.selectorValue = 100;
	            this.lastValue = [1,1,1];
	            this.k = true;
	            this.x = true;
	            this.getValue = ExpressionManager.initiateExpression.bind(this)(elem,data,this);
	            this.getMult = getValueProxy;
	            this.getVelocityAtTime = expressionHelpers.getVelocityAtTime;
	            if(this.kf){
	                this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this);
	            } else {
	                this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this);
	            }
	            this.setGroupProperty = expressionHelpers.setGroupProperty;
	        };
	    }());
	
		var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;
		TextSelectorProp.getTextSelectorProp = function(elem, data,arr){
		    if(data.t === 1){
		        return new TextExpressionSelectorProp(elem, data,arr);
		    } else {
		        return propertyGetTextProp(elem,data,arr);
		    }
		};
	}());
	function SliderEffect(data,elem, container){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
	}
	function AngleEffect(data,elem, container){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
	}
	function ColorEffect(data,elem, container){
	    this.p = PropertyFactory.getProp(elem,data.v,1,0,container);
	}
	function PointEffect(data,elem, container){
	    this.p = PropertyFactory.getProp(elem,data.v,1,0,container);
	}
	function LayerIndexEffect(data,elem, container){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
	}
	function MaskIndexEffect(data,elem, container){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
	}
	function CheckboxEffect(data,elem, container){
	    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
	}
	function NoValueEffect(){
	    this.p = {};
	}
	function EffectsManager(){}
	function EffectsManager(data,element){
	    var effects = data.ef || [];
	    this.effectElements = [];
	    var i,len = effects.length;
	    var effectItem;
	    for(i=0;i<len;i++) {
	        effectItem = new GroupEffect(effects[i],element);
	        this.effectElements.push(effectItem);
	    }
	}
	
	function GroupEffect(data,element){
	    this.init(data,element);
	}
	
	extendPrototype([DynamicPropertyContainer], GroupEffect);
	
	GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
	
	GroupEffect.prototype.init = function(data,element){
	    this.data = data;
	    this.effectElements = [];
	    this.initDynamicPropertyContainer(element);
	    var i, len = this.data.ef.length;
	    var eff, effects = this.data.ef;
	    for(i=0;i<len;i+=1){
	        eff = null;
	        switch(effects[i].ty){
	            case 0:
	                eff = new SliderEffect(effects[i],element,this);
	                break;
	            case 1:
	                eff = new AngleEffect(effects[i],element,this);
	                break;
	            case 2:
	                eff = new ColorEffect(effects[i],element,this);
	                break;
	            case 3:
	                eff = new PointEffect(effects[i],element,this);
	                break;
	            case 4:
	            case 7:
	                eff = new CheckboxEffect(effects[i],element,this);
	                break;
	            case 10:
	                eff = new LayerIndexEffect(effects[i],element,this);
	                break;
	            case 11:
	                eff = new MaskIndexEffect(effects[i],element,this);
	                break;
	            case 5:
	                eff = new EffectsManager(effects[i],element,this);
	                break;
	            //case 6:
	            default:
	                eff = new NoValueEffect(effects[i],element,this);
	                break;
	        }
	        if(eff) {
	            this.effectElements.push(eff);
	        }
	    }
	};
	
	    var lottiejs = {};
	
	    var _isFrozen = false;
	
	    function setLocationHref (href) {
	        locationHref = href;
	    }
	
	    function searchAnimations() {
	        if (standalone === true) {
	            animationManager.searchAnimations(animationData, standalone, renderer);
	        } else {
	            animationManager.searchAnimations();
	        }
	    }
	
	    function setSubframeRendering(flag) {
	        subframeEnabled = flag;
	    }
	
	    function loadAnimation(params) {
	        if (standalone === true) {
	            params.animationData = JSON.parse(animationData);
	        }
	        return animationManager.loadAnimation(params);
	    }
	
	    function setQuality(value) {
	        if (typeof value === 'string') {
	            switch (value) {
	                case 'high':
	                    defaultCurveSegments = 200;
	                    break;
	                case 'medium':
	                    defaultCurveSegments = 50;
	                    break;
	                case 'low':
	                    defaultCurveSegments = 10;
	                    break;
	            }
	        } else if (!isNaN(value) && value > 1) {
	            defaultCurveSegments = value;
	        }
	        if (defaultCurveSegments >= 50) {
	            roundValues(false);
	        } else {
	            roundValues(true);
	        }
	    }
	
	    function inBrowser() {
	        return typeof navigator !== 'undefined';
	    }
	
	    function installPlugin(type, plugin) {
	        if (type === 'expressions') {
	            expressionsPlugin = plugin;
	        }
	    }
	
	    function getFactory(name) {
	        switch (name) {
	            case "propertyFactory":
	                return PropertyFactory;
	            case "shapePropertyFactory":
	                return ShapePropertyFactory;
	            case "matrix":
	                return Matrix;
	        }
	    }
	
	    lottiejs.play = animationManager.play;
	    lottiejs.pause = animationManager.pause;
	    lottiejs.setLocationHref = setLocationHref;
	    lottiejs.togglePause = animationManager.togglePause;
	    lottiejs.setSpeed = animationManager.setSpeed;
	    lottiejs.setDirection = animationManager.setDirection;
	    lottiejs.stop = animationManager.stop;
	    lottiejs.searchAnimations = searchAnimations;
	    lottiejs.registerAnimation = animationManager.registerAnimation;
	    lottiejs.loadAnimation = loadAnimation;
	    lottiejs.setSubframeRendering = setSubframeRendering;
	    lottiejs.resize = animationManager.resize;
	    //lottiejs.start = start;
	    lottiejs.goToAndStop = animationManager.goToAndStop;
	    lottiejs.destroy = animationManager.destroy;
	    lottiejs.setQuality = setQuality;
	    lottiejs.inBrowser = inBrowser;
	    lottiejs.installPlugin = installPlugin;
	    lottiejs.freeze = animationManager.freeze;
	    lottiejs.unfreeze = animationManager.unfreeze;
	    lottiejs.getRegisteredAnimations = animationManager.getRegisteredAnimations;
	    lottiejs.__getFactory = getFactory;
	    lottiejs.version = '5.5.4';
	
	    function checkReady() {
	        if (document.readyState === "complete") {
	            clearInterval(readyStateCheckInterval);
	            searchAnimations();
	        }
	    }
	
	    function getQueryVariable(variable) {
	        var vars = queryString.split('&');
	        for (var i = 0; i < vars.length; i++) {
	            var pair = vars[i].split('=');
	            if (decodeURIComponent(pair[0]) == variable) {
	                return decodeURIComponent(pair[1]);
	            }
	        }
	    }
	    var standalone = '__[STANDALONE]__';
	    var animationData = '__[ANIMATIONDATA]__';
	    var renderer = '';
	    if (standalone) {
	        var scripts = document.getElementsByTagName('script');
	        var index = scripts.length - 1;
	        var myScript = scripts[index] || {
	            src: ''
	        };
	        var queryString = myScript.src.replace(/^[^\?]+\??/, '');
	        renderer = getQueryVariable('renderer');
	    }
	    var readyStateCheckInterval = setInterval(checkReady, 100);
	    return lottiejs;
	}));


/***/ }),
/* 433 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD8AAAAWCAYAAAB3/EQhAAACMElEQVRYhb2YPWsUURSGn13jR6JIEoslgkmloGghWggJ2AZRsFIQbCzUUsH/YCO2go1gLf4MsRDBJsEiit/FomsTxDW7x+Ied07GObPreu6+MMzL5Z2nuPPeO5cBQEReiMhnEfkoIksiQsW1opkvIvLUyUSzcjKZIukUhYRqzQIL6o87mWhWTiZNvX83Y7+cbNf4bzXMSFZO5uDNLwM71T8GWqQZvgi81fFnwEmgBxwFXpEmbx24ZJiRrJzMpNJa6EqhY856OWEyX2vWVSQrnNmsmIst49vOfLWM33RnNZYVzmxAevNGy8Ae9deBA+pvABvqZyk2oRZwTf1746NZeZg1Fds09TntZFom050QK4RZVXtPn5zxJeNHqW00a2xmVe2tzgNzQB9YAfYBO4B7wEvNzAHnSDvrNHBWx9vArUysKGZt7e3VNvW54mRmZLsmwRqb+S+1b4yQcSuUkTU2c1jt75B2yz7plNXTZ55Q7KwLwG31W0CHVLEO8DATK4pZW/u+acm8kzljMj8mxAphDqv9T+OPOJnXxu+eECuEOcXfukk6OPSA+6QaNYF3JnMIuEqxzu6qL5+4Ill5mKWaWE07VVo1mbrzeCQrnDms9oed8TfGj1LPaFYI80/tLwN71T+gODvbmhwEVtXvBx6p/1BiRrJyMpNKVdrl1OSCyayNWMv/ZeVkDmpvP/SLzhz1ja9bLpGsnMxB7Z+TDgPC9s+HVYf016RB+kviKZKVk8lv6dVBLmmzswAAAAAASUVORK5CYII="

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e760d74ed5e1c0473be20f2a4d2dbef5.png";

/***/ }),
/* 435 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3ZWUzZDQ1NS1lNzg3LTQ3MTMtODQzZS1jNWQwYjMyMjNmNjAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjJCNEQ5RDg3NUU1MTFFOTgwRDE4Q0U5NDA1OTU3MEMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjJCNEQ5RDc3NUU1MTFFOTgwRDE4Q0U5NDA1OTU3MEMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpjM2VjOGNlMC1lMmUyLTQ1ZTktYTUwNC1kMzhmMGQ0YjVmMWEiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozMjgxNzFhMC04ZTE5LTExN2EtYTk4ZC1mNzVhMWY2OTBiMjMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5Uy6YOAAABc0lEQVR42mL8//8/w1ADTAxDEIw6ml6AhRLNlxkYQZQuEF9CkzoCpW3QxPVA2nQZ/o8mj1FHD8o0DQV/gfg9mthnKP0ei9pB4eiPQLwaTewOlH6MRe2gcLQQEKcRWXpMAeKnoxlxyGdEaMVBE0CM2fgqIHxpWgmN/w+IvwAxH5aSIhdN7AWUXolFLbq5n4CYB0us3yPH0Xex5PxlQJyJJl4BxB1EZkRuLGqnA3EUEPOjiTOOZsRRR1O5ctmDxv8KxDewiD/GInYFSv8gQi3IzAPQ9D4yQ9oFS+nxDIv4HixiHDhKD2xqbwOxA5bSYzQjjjqaHMCIa7AG2D4gthoHifvgqMYl0MS3YAkorNU4sO1xjxxHE+txknvjxBlKRoOJmG4+uS3B0SGEkdQbfwfEs3B0bK9hUTsoHA2qyULRxE5AaQs08YnU6NhSw9HMQCyIJsYLpQWxqB2tEUcdPSDV+GhIjzp61NGjjh519KijyQUAAQYA9rlW2jovFLoAAAAASUVORK5CYII="

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ac91398672b2c15d6727263b2cf060f2.png";

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "16c9db13a4d8ffd12bb1ff6a5c42f05b.png";

/***/ }),
/* 438 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 439 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "03bb43a31bcba610da4e28a44a46aa27.png";

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "fcff8139624f79b2f9eff3313999f024.png";

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "978310079aa1c92231f275cb632afb33.png";

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "98129d09e7c8530c14c4a525a3508f6e.png";

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ab4ec79c8d13157e07414b46f3fceafe.png";

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e6f56df3eed7ecf3fa70778aa9981bf8.png";

/***/ }),
/* 446 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAAA3CAYAAACo29JGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3ZWUzZDQ1NS1lNzg3LTQ3MTMtODQzZS1jNWQwYjMyMjNmNjAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzVGOUJBMkY3NUU1MTFFOTgwRDE4Q0U5NDA1OTU3MEMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzVGOUJBMkU3NUU1MTFFOTgwRDE4Q0U5NDA1OTU3MEMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpjM2VjOGNlMC1lMmUyLTQ1ZTktYTUwNC1kMzhmMGQ0YjVmMWEiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozMjgxNzFhMC04ZTE5LTExN2EtYTk4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"

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "088bcd3123fdac9c74f54173bd8c7520.png";

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ffe9691eab4f508e8b1e133c2ad06068.png";

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0af35d45c0ee3bd1e6830a17fa401090.png";

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "7daba2be04faf96b15441e6f28c5dacd.png";

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8f3741405b5e73c4c5604189346ffaa2.png";

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "023a83dffb3c3a1c0791e812091b0e16.png";

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "13b2a9ec42488f33bb7a0f9c3fc11964.png";

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3d6a4979b391789b20305ddae2f1c661.png";

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d6f4f4d216d4c9a76b4913982a882eef.png";

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "27ba3eae36d96ced08180e079a34b9a9.png";

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "bb80e97f2ba72971028e888f75e493a9.png";

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f1dd7f8e3ae58e697a9ac3ff484ce96b.png";

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "bdd6961cb9bc125d1be2fde5bec36c0b.png";

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8d0baefb58162cf6cc6cae2070484652.png";

/***/ }),
/* 461 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAScAAABpCAYAAAB4f+XpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3BpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplMjNmM2ZjZC02MTE4LTQ1MWMtOTE3YS1jZGJiMTNhOGU4MjciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzExMkQ1MDA3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzExMkQ0RkY3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4OTQxNjI2Rjc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4OTQxNjI3MDc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjdFzN0AABdVSURBVHja7F1tcFzldT7Sale7K60+LVnyF7Zs2WBjG2O+AmYwGSApYdLOFNoM/AiQTEMZfoRMKfRHEqA/4hSaMG3HgUwKZFoYWmgmZSgkgQS72AngT2xsbCPLRpa/JFnWt1ZaadX73H13qqq6z7kjKY7B55l5f9y5j9/7PnvuPXu976NzCvaMyZj8L1Z5Y49waJwWb/yNN14gnP/yxhZvfI9wfuSNcm/cSTh3eeMRb6wknOu98ZqbKwiXeuNDcr7bG7d54x3CgZ4XvbGRcF50c/0l4eCz+5I31hHObe46CwjnC9745TRjudfFQdPU4uIQhA0uRl8inPvXLd6wsbe5J5Bw3XM3yNZ7NlNB12xcJ+/evyXwfHx2QlY8uFJ2PPJ+IKdyZZXUfG62HPrxR4GcBX+8UDL9GTn51vFAzvJvrZSTbx6Xs3s7AzlX/9N1suPh92XEmysI655fL1vu3hR4vqgkKqu/vUbVVH/zXNn/g72BnPqb5krUm6vlP49STe2/a/PG6UDO2g1Xyb4f7pX06cEpawIKxWAwGM5DWHIyGAyWnAwGg8GSk8FgsORkMBgMlpwMBsMFgSJvfH/ccfuE48mgcbq8sV/hHPDGUYXzrjfi3jhGOLjOs96oI5xWbzzl5gpCh7KWtJuHcaBnt8LZ7ebqUXTjM9xKOIclt8VfoaxnurE85Y1dITRhvQWEg/3/g8LtGrvm3jpfhjuHAgmximJpuHMJFVQ8K045RaVRSc4toZxEXVJKLiqlnPLllZIdHpVEbSKQU9ZY7n0oBf42fhDiNXFZeMcib64s0R2jaymMFYbSlGoso5zUkjJvrogUlRRRTRGPk1qUCuRgLbBajPRlpqwpn5waxv+bCceTzqtw8KCXKpwuNxinCToVDq4zT7jfB0lpoZtrqpoG3DyMM+yNZoVzws3FOEg4cxRO0mmepXCmG0vcH2UhNBUqnD3uC4RxytLtaeqNGctkZeDEABWUHRqlnFh5TEbTnFMQLZRYVTHl4AEcVa410j8i6TNpykFSGjw16K8pkKPojsQjoTQl5iQpB4k9UhxRNQ15XyCMg7UgjsPdw1PWlL/57hh3/LcTjieDxoEhb4vCySeKO5QkV65wfu6NW4SbMP/BG38i3IT5mHIdGCd/onCg+aTCybi5GGenN24UbsL8qeQMjSwp/2QGYrnXvaVpmloUzmHRTZhvn9nWLsyEufirjXJq0wkqaOGfNVAOTJg1n6ulHLzp4CFlHCQ5mDAZp+ryaunc2UFNmBfdvkhOv3OKmjCX3L2UXgcmzLr19aqm4upiyikoKvBNmJom6GEmzLlfnCdt756mXzSaJvvNyWAwnLew5GQwGCw5GQwGgyUng8FgyclgMBgsORkMhgsCBXvG/s8W8K8ktzXPoHFgXsAW9NWEgy13WAWYBQDbz1Hh2+XveeNi4TaBtyW3LR+dhibs88IqcCPhQA+21C8nnBY312LCwWdXL9zDtMVdh3m3UHvq+mnGstvFQdM04OIQhAMuRvWEs/Nrf/9qE9tSn3VljXRsa6eCqtbMks5dHYHnYREoW1pOt/dhEyiujlNbQ3JOiWRHspJuC94ux3U0vw/We3ZPp4yNZqesuyBSKBXLK1RNsFH0HOoO5MRrE1JYVCgDJ/qppqEzQ95IB3JgW8B14AObTizhc9ow7njPhOPJoHFgXnhC4SBhbPfGQ4SDYnWwoX6ZcB70xn3eWEY4f+6NR91cQfhAWW+vN76ucKDnVW88TjivurnuIpwnXBK8gnCwFhR3m0M4d89ALA+6OGiaTrg4BOFpFyOW3L/zycvN0n+sL5CQaiiTQ898RAVd9tgVlIOk0/i1ZZRTtqxCqr2kceSlpkBO/c3zZHRgRNq2ngrkLLn3Yv98z8GuQM7qR9dK0/MH/bkCdS8up+uNJIvkkgdWqJpqr6uTpmcPBHJwHnOdfLOVakLyZ18Al/71aml+oYkmME1TPjnNtEMcc2oOcayqQuHMct+2YRzijJN3iLO3q6gyR7foDnE8oJqbuhbPh8ycQ5y9VSZmIJb9ITWlFQ7+fiOUQ5y6qUdCOMQV53F2dEx1UyOBZfoylJPpGvZNmNRNPZCRoY4QDvGTg9SEOabohgkzjCash3GGzg5JdDirawrhEB/03iip2z9ELO03J4PBcF7CkpPBYLDkZDAYDJacDAaDJSeDwWCw5GQwGC4IwIS5ZtwxTBAXK/9G48BxBpPlRYQDdxsMLcynAyNFxBuVhPOJ5LayE4TzseS2sCPT0AQ3GQrJNRIOtt3PSs7aEISzbi5msIQlAbaHEsJpdteJKZyGacYSe8FnQmhCzGcTzmkXozLCaX3gX99sY8a9kgWl0t/SRwWVzCuR/tZgEyFMhvHauFK8rUiipUWS7gj26cDUOJYdk0xvsAUgXpPwz4+mR+h6sRbMNVXdBYUFkqhL6JpSUUm3B2/v4zzmYqZRaIKdAEXngpCck5R0W9q3fkwnlvAk7Rx3vGrC8WTQOJ/Wjr9M02e54y/TfU47/u7+7g7ROv7+9uv/TQV9Vjv+Mt2f1o6/Wiztv3UGg8F+czIYDAZLTgaDwZKTwWAwWHIyGAyWnAwGg+EPBVgJzo47Hp1wPBk0DrbKhxUODA5phTMwyfomAtfpUTgwZKCgTnYamnrcPIyDOk1DCqff6WKctJuLcfL97zTOdGPZE1LToMIZdDFnnCF0moXXJgjw4LDzYTjYKi8oKqScomSR30WXcQrjESkazXJOtNCfi2qKFPieqgLymuBzlPWG0hRVOJ4m6FI1JTjHXwvKuKRGpqzJ5+wZk5vGHaMV9jXKDa1x8HChStelhNPhEgbrR9zqkhNrNY721gslV9cpCCgCd5mba6qa8Cmj7TYrAAc9qDzGTI2n3FzM1IjPDiZN1mp8t7tOXOFcNs1Y9rk4aJrSLg5BOOpixMynB77x9OvHRgeDb+iK5ZXStZ/nWxRVY8Xd0G4bBsDepuCKkGhZDpPlwPFgMyfMiGOjYzLUGWzULFmQ8s+zttxYb29TD62EqelGJczSRSlVU3FVXPpbegM5OI+kwYya0ASTZqY7uG18akm5b7BEu/bpxBLJabw1Faa8PcoNrXE+rSbMD5W3wc+qCZPF8pyaMNct3rBRM2FuvWczFfRZNWFuuXtTcOL5lJowmSb7zclgMJy3sORkMBgsORkMBoMlJ4PBYMnJYDAYLDkZDIYLAvD+vDXuuG/C8WTQOG2S874wDjw4RxUOCqGVKBxcB16d04QD08sm4cXb+pXr9Lt5GAdWhNYQHO1a+FzgzUoTDnxi2C+vJZzOGYjlkZCa2hQOvFswvRQTTiu61sYqgylFiSKpXlvDb+gk58QqYxItj1FOqiHlF29jnJKLSgWerGHCgReq/OIK31sVhGhpVKrWVHtzBXuCIokIXQvOh9GE9VDOopQ3F//8MEfZkjK/316gJm8tsC4MzxuesqbfV3LqCZGcDoe46Q+4mzkbIjkdDpGciqeRnIZCJKfWEJr2u7kSSnKKOG1acir7PSen9pCaekIkJ/i7etnnV76iUhJzS8gN7T04V8ziN3QqSjlwoccqYpSDBzBRn6QcGDnRwFMKC8g8cd9kGasiCRfJ6bLq3FxBuuNcN1zbYTRhPYxTujDlz1VNqpFijuyScr8zcOAXgLeWylVVtFqmpimfnMa3o35d9BbWGqfF3YiMM1MmzGPe+KZwE+ZWybUjZybM15T1dru3GcbJmzAZZ6ZMmHhbgemRmTB3zUAs8yZMTdNMmDB7Pnn5CK2EWXNNrdrCump1NeXAhJmoTVDOTJkwkQg1Eyau1fTcIWrCrMVayHphwkS5X00TTJiME8aECU2aCRNvYGhHzkyYmib7zclgMJy3sORkMBgsORkMBoMlJ4PBYMnJYDAYLDkZDIYLArASjN8CPiV8SzgMB3vBuxVO3ufEONgKh0GE1RvCdZ7yBnNzHZWclYD5nNqUtQy5eRgHevYrnLzP6RPCQcEiWCReIxx4wLA9z3xOTTMQy3YXB00TYt5FOPCi7RBeD+vdi+5YJMNdwcY9FENb+o1LqCBYBRgHW+EwUDIOPEHJuUnKKWss971JqcXBIUBBtaJkVGquDW6GnKhLypJ7llKfE4ypbC3wJoXRVLqQc/I+p3hdgmqKlRf7PqYgYC0Ndy2hPidNUz45ja+E+e8TjieDxsGDflDhpCa59kTAJAFH3ucJZ5vkKjkuIhx4qtYLd4j/m7KWvEmTcT50D+lNyptqv8JB4kLFTVZJdJPkfFDMIf7rGYjlEZegNE1tCqfDxehqluS6952VgZPB3pj6G+fIme0dVBD8M4wDhzgSC+PATY2yuYwTKY74DvEzO8/Qhx1VOXube+l6O3efoQ7x+s9z3XBbV6yoVDUhMdPPLzvmG10ZB5pQcbNrf/B3EUylZ/d0yvDZ4Slrmiw5lYa4oTVOi0sINylvIn0K52PJGScZ5zmXnJgJs8IlJ2bCLFGu0+3mYRyUzD0UInF3K5xfu+TETJhPufPMhPnEDMRyr3tz0jS1KJztLkaM8zPc8MyEOYJksKOdChoZ4By8Wc25aS7loLwsvtkZB6ZHmDAZZ/YNddJ9oIuaMDN9GencdYaaMJG42HVgwpx/2wJVU3J+CeX4f9rjzaVp6mnqoZyF3hswNDMTpqbJfnMyGAznLSw5GQwGS04Gg8FgyclgMFhyMhgMBktOBoPhgoB1/A2nyTr+ck3W8XcSWMff6Xf8HW/CgHdmi3JDaxzczI9748eE8yv3YHyHcJ6VnAP6dsL5C8kVm1tOOLd64yXhbuprvfFbch7mm69Irjgbe9Bf8caThPOKm+tewsFnd4uSNL7irsOS3J964z+mGcv9Lg6aplYXhyA85WJ0C+H81fpVT/5z39Hghwfdcd97YCsVdMUT18j2h96lSWXZ/cvlg8d20Aen+soaOfzTQ4GcubcukNH+jJzafDKQg+uc3nSSPoRr/+5q+eDRHb4/KwhaF2OUJl7x0GpV0+z19XJw4/5ATt0N9RIpicrx11uopjPb2qVjW7BHafV31/rXYUlO0yTubaJy3HFkwvFk0Di4u2IKp9R96zNOUnLmSMaJuaRTqWjEW0j5NDQVTvJZ/b8vDMn9iQzjlLg3J8aJu7kYJ+r0aJzpxrIspKaEwkm4mDNOMf7cIdMb/JYxlh2j58NwUF52bCRLOUgUqJHNONn0qIx4g3IyWX8uqsl7+8r0jVATps+hn4uE05RROJ4evIWpmga5bn8tnh5VtxJL+83JYDCcl7DkZDAYLDkZDAaDJSeDwWDJyWAwGCw5GQyGCwLwOd047hjF265U/o3GgSsNRcpYmTtU6IJjrIFwTkhu+54VVENXPtQ0YoXkUI9opXATpqYJ2/+obbSGcKAHnQaXEk6bm2sO4TR7o1q49QFraRRuwtwrvM5VGN1wIR4PoSktvLZUi4tRNeEcuu+ZN1pH08F+H7T2Rn0khlRjufR+HGxGhAkzOa9E+kjdKNRHQkvtwRPBJszi6ri/HT7cFWxGTM4vleHOIWoTwHr7mnupCVPTje1/VJ/UNKHz8MCxvkBOrKLYN2EOnUlTTRmYMHuCC8mVNpTJQGs/NWGGiSWS09i441XCy+KG4eBGRNfaFwhnpjr+3iW5ErLsIbxeciVv2cMON/uHSuK5TXiZ2XzH342EM1Mdf29z12EJ4Qve+OU0Y5nv+KtpmomOv/evW7xhIys2d91zN8jWezZTQZq5D8XmVjy4UnY88n4gZ6Y6/i7/1kq14y+MpTsefp8msHXPr5ctd2+iiWf1t9eomtDxd/8P9gZywnT8hSat4+/aDVfJvh/upcXmNE323zqDwWC/ORkMBoMlJ4PBYMnJYDAYLDkZDAZLTgaDwfCHBLw/zeOOhyccTwaNA39Sn8JBgbIuhYOCdEMKJ18MjfmcYNo4KrkyJEHIKNfpdfNounsUTpubi3G63FyMMyC57fsRwhmcgVi2htTUqXA6XcwZpydeExfmcyosKpTknCT/to1yDvxJkXiEc2bFJVoapZxoRUwKY/xa6PaLuRgHcyTqEzI6EA3kFCi6UQYmjCash3Iqi/25VE1VxXw93loStQkpjBRMWZPP2TPmF2zLA4XDblduaI2DhAHDBevU2+Ju1qsIB1WxUK+JVcv8jeSqPVYRzqve+KKba6qa8BD/whtfVhIuqlgyf1KTm4sVx8NnB/8SqwD6C3cdVgH0DW/80TRj2enioGnqE151c7eLEfNlbfnq4z/bl+kNNvfV3TBHTm0+QQXVXlcnbVtPBT9ciSLf89P+flvwQ+o9fPHZSen+KLhIHDrforYRq5aJ6+D8UOcQXW/He22SHclOWTeSdvXls1RNybkl1HOF80jurOAfNKXbBmWQeJhqrqr1rzNCqpqGiSXenJ4Zd/y7CceTQePkTZiMcy5NmHi4nhJuwtyqrDdvwmScc23C/J7oJszpxvKcmjBReZKZMNFye9+T3COcaiijnLwJk3HOpQkTSe6jf9xHTZiVl1bR9eZNmJqmc2nCPOh9dsyEqWmy35wMBsN5C0tOBoPBkpPBYDBYcjIYDJacDAaDwZKTwWC4IAArwffHHbdPOJ4MGgcmwv0K54DkjJGMg86IKKZ2jHDyTR+ZJwhGwqeEF2brUNaSdvMwDvTsVji73Vw9im58hqx75GHJbfFXKOuZbixhGNoVQhPWW0A4KMJ0UHjNrF1zb53vF2cLAoqhNdy5hAqC2ZBx0PkWfh7GSdQl/eJtjFO+vNIvpgazYRDKGsu9D6XA38YPAoynC+9Y5PfJC9Ydo2vxzaAhNKUayygntaTML8ZXVFJENUU8TmpRsKcZa4HVgnU61jTZm5PBYDiv35weHnf8woTjyaBxWtxgnLwJk3HCmDDh4kJrb2bCRBXMbwo3Yf6LshYYJ99SOFvc2wPjhDFh4i1EM2G+4+ZgJszfzEAs4dgbCqFJi/eY6CbMT46/foyaMGEibH6xiQqqXVdHOTBhphpSlJM3YTJOGBNmvC6hmjBrrp0tR18+Qk2Yc26ZR9cCEybK3mqa6oV/fmFMmNCkmTArV1X5czATpqbJ3pwMBsN5C0tOBoPBkpPBYDBYcjIYDJacDAaDwZKTwWC4IGDF5sJpsmJzXJMVm5sEVmxu+sXmxvtTNovujdE4+TK9jPO2N7Z74yHCgQcnFSIhwOe0jHB2Ss7nxMr0blLWi2h9qHC2u0T4sJIoMdddhPOEN9Ai/grC+VhyPifW1vyjGYjlQdG9UK+6mN9HOE+7GN1IOP3HX2+RftIuu2p1tRxRvDHlyyooB2V6i6uLKafMm6N6zSw58hLxBN08T0YHRmgijNx7sX++52Bw2+2ypeVy9JVmf65A3ZfNoutFad1EXULVhETIODiPuU6+2Uo1de7q8EcQSuaVSMvPj9K25pqmfHJqGHccm3A8GTROkftGb1AenAqFM0tyxknGwXXmKRz82cpC4SbMqDJHt5unQUnKZQqnFs+HwqlwSYdxku4thL2JJGYglv0hNaUVTpV7E2ScsnR7WgZODAQS8HbBzvucDOdkR8dkND1KOUhgmb4M5WS6hn0TJuOMDGRkqEPRNJyVwZOD1IQ5puiGCTOMJqyHcYbODkl0OKtr8t4EGQdrGfTerpgJcyxELO03J4PBcF7CkpPBYLDkZDAYDJacDAaDJSeDwWCw5GQwGC4IwIQ53nuyzRtXKv9G42Bb+Yg3LiGcM5Lbnte25mFLqCUcWBKwnc7akaOS40o311Q1wYSC2kZrCAd6UORmKeG0ubmYPwktu6uFWx+wlkbh1T33Cq9zFUY3rATHQ2hKC7c1tLgYVRPOofueeaOVtSNHzaLuA11UUKqxXHo/7g7+No5FJDmvRPpI3ShszUfLYzJ4Ithgia35sdExGe4KNlgm55f6lT2ZTQDr7Wvu9ebKTll3QaTQr9ypaYpVFcsA8ZGh0mhBpID6k6Ap0z0smZ5gs2xpQ5kMtPb7lUKnE8v/EWAAtFuvGtYH6VEAAAAASUVORK5CYII="

/***/ }),
/* 462 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKoAAAC+CAYAAAClMZQPAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3BpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplMjNmM2ZjZC02MTE4LTQ1MWMtOTE3YS1jZGJiMTNhOGU4MjciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEY2M0I2RkQ3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEY2M0I2RkM3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4OTQxNjI2Rjc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4OTQxNjI3MDc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIvPiA8L3Jk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"

/***/ }),
/* 463 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIIAAAAyCAYAAACQyQOIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3BpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplMjNmM2ZjZC02MTE4LTQ1MWMtOTE3YS1jZGJiMTNhOGU4MjciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEY2Q0JEOTA3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEY2M0I3MDQ3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4OTQxNjI2Rjc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4OTQxNjI3MDc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PihWeRsAAAOISURBVHja7FzLahRBFK3uGeNrdEQUY0aSKPoHLgSJCoKgGzciiuDKCIJLl26ELNzoDwju/ATd68q9G8U34iM+iDLRmJie9l5Sg+VYt6erumoSzDlw6XBn+taZ5KTq3OpKkjzPFQAkEAIAIQAQAgAhABACACEAEAJQQQgnHjy8S5d9FJmRTilOUTxyHOc2xQTFYndc/fVRimnHWuBVEfcOHfgnVy94/0GKpiXf9Bh7P8VeS36tRy3wioC04LX3Qn7BY5yPllzW89tTFuA1YCEAqwhFQqgJ+Y7HODUhlwWqBV4RhbBTyM94jLNdyPsYH/AacNdwjC6bDUXnOo5TDBuOlpU6SzFJMSeMM6HvyYxafN9JioYxRqLFeYXimVALvNx4leoaioQg1XlNMWrJb6H45ihEaRPjCMV9x1rgVUEIPmbxgyXX9lgLWeFvhdfmwCs6L3QNQBgh1IXcYqBaytMdg9eAhbDVklvvOT1J7rgNXtF5lVJYEU5rd2xiiD2IvvYq9RzFZ6G/Pqzs26ZXKUZ6cj8ozugreFXnVblrcHW049o5u+AVxVhkp71qeYXqGmzYJExPmedaOB3IaYMXugZgudrHRMjlqLXya6UBBdUQ8u886u225Lj+LHjF4RXKLLL7ndRtUWZ8qI7hZmtGnnfbrhfUO6uWtmUXjHuYaEtfUyPPDnsKvMrzIrM4FbNrcHHHuedslDtMjeAl8CIhJIM2i9L++JOAnclL8KrOC10DMBAhdIQxUtRaWbViC4HXKNvJnVGPWt8pNlryY+BVnVc90A98HcUNPXDvk7BL6u+TvLwOfulTj/fO+W8EzF02rnuxpz7X+gpe1XmF6hqaBR/cxzl/otgWoBZ42buGaEtDR8l75y2Pei8subZ2wuAVgRe6BgBCAMILQZqG2Jys8ag3ImyQpOAVh5dP19Dd1543yLPjvKn+nL/vGhVe82YKTNEFtXR44peRY/J3dJ26keejXT/BKxivyl1DKOdcU/IhDP7GvVkmR//f8wrVNdj2qvlxZ8OjlvTIdRi8ovOqLATp6VioJ21KhX1qB17oGoCYQtgVyDkXbZ5sAK/ovEp3DZcFk3PLkpvv41DPU+yx5K8J738KXsF4Ve4apPWopdzP1bFhGo+45oKXA1y7hscOU10/PHec6hR4BeMFswhACEBAIewQ8kMe49hMVE3J/4BKgVcwXqXwW4ABADf71xDNWVnIAAAAAElFTkSuQmCC"

/***/ }),
/* 464 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAABBCAYAAACO98lFAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3BpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplMjNmM2ZjZC02MTE4LTQ1MWMtOTE3YS1jZGJiMTNhOGU4MjciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEY2M0I3MDE3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEY2M0I3MDA3N0Y4MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4OTQxNjI2Rjc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4OTQxNjI3MDc3RjQxMUU5QjUyN0M2MTJDQjdFNDVCMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pl83FZsAAAHqSURBVHja7Ju9S8NQFMUTERXBwYLgouAqCILg5OQkuAkudVecXXRKM+l/ILiKXYSigquTLoIQEBwV0kUQUkTxa4nnlVcoNMl9ktdi9Fw4FMrJu+mvyc3lvtaN49j579HnMAhBRX/Sm77vN19XvEre9cvQkeCZhELBswZVf5q85neev+d5vBJ4OxACIRACIRBCjj7BYgTQtuB5NvAERYZQguYEz4CB56rIEFQ3uCp4tgw8J6wJLIyEQAiEQAh/q1mKoBvB82Xgibp5km7SoPXWcdeF466hcd0HpMUjdActCmupiVFZ8FxA0zpnWoQ653zWQjNOfGAKQRpB70AL0HKG5xLad+yN1zZ1zrQ41zl3BQguawILIyEQAiEQAiHkapamhOMa0CA0nOH5gF6gMWGtOjQheJ6gEWgow/MGfUKjQp/wYNo23/e4WZLyWWuW1BfP24E1gRAIgRAIgRCMIq1P2BCOU5MltT94luFpTZaktRqG+V6hwwxPa7IUWYFQ8yvNEZSFH24tQdKo7tTAEwrA2yNo+xydHaNnfiXYClsbsiXWBBZGQiAEQiCE39Es2Qr1fD8WPO8GnrDIEAqxIdttCLPQnuCpGnjqugVnTSAEQiAEQiAEQuhduPyHLK8EQiAEQiAEQkiKbwEGANzOa5ZlJ4fOAAAAAElFTkSuQmCC"

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4c0c79c3a67f23476aa523b60d863da1.png";

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "936ced023429c6c59d475460cabbd68e.png";

/***/ }),
/* 467 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 468 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "5d608a0cb61464691a835b01d15089ea.png";

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "7531621c82242c167f75fe1a9f75b0f7.png";

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "43a7ab65df5d416068da803bfa99865e.png";

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4b39305f352184394f079f90bd310659.png";

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9f6f3dbc0b2f81bc5f8510ff381a3f27.png";

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "1a2718e9a146ed3423ef77bb2e3fc682.png";

/***/ }),
/* 475 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFUAAABVCAIAAAC3lz8NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplMjNmM2ZjZC02MTE4LTQ1MWMtOTE3YS1jZGJiMTNhOGU4MjciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkYyQjYwNTY3N0Y5MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QkYyQjYwNTU3N0Y5MTFFOUI1MjdDNjEyQ0I3RTQ1QjEiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowN2UwMjBmYS00OTJjLTRiMzItYjkyYi1hOGJjNDJmY2JkOWQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZTIzZjNmY2QtNjExOC00NTFjLTkxN2EtY2RiYjEzYThlODI3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"

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "790838f14df445f34d9e2c0798829712.png";

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "77228533218a0d365c33a16523daed98.png";

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9e789e8a99d6f8deec87ac6ab112255e.png";

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "c3188074f65082c25b4dac73905bf5a8.png";

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "96a30a3bf997029a1e38b0b766130604.png";

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "c74ea5c41989b83f3ed4d892ecaf38cc.png";

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e8bf60715d7b681bc5063d990be29c27.png";

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "640033ccd296783c2490472bda3c26fe.png";

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "1b8cb9487ab64f2ac9efd40ce3f9e1bf.png";

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ebee1c7ce462a33fef9c3af1bcad7aa1.png";

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9eda7873adb5f0bb7f215c7dbf95b3a4.png";

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0ed48106a473fd5b166d8c1a754f4763.png";

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "fe158cbbdd0f8492f140be21e652bb86.png";

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f12a77cffacf47fa018e331fd399eec2.png";

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f62677254e5832ea693b0a346fc2f25e.png";

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "cf1256c776902795c778e728899b8cb9.png";

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "61208e9bbdda466094966b7d87c9c547.png";

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TerminalOutput = undefined;
	
	var _getPrototypeOf = __webpack_require__(304);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(309);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(310);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(314);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(348);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(24);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(494);
	
	var _lottieWeb = __webpack_require__(432);
	
	var _lottieWeb2 = _interopRequireDefault(_lottieWeb);
	
	var _IsPcOrNot = __webpack_require__(385);
	
	var _IsPcOrNot2 = _interopRequireDefault(_IsPcOrNot);
	
	var _Header = __webpack_require__(375);
	
	var _Header2 = _interopRequireDefault(_Header);
	
	var _reactRouter = __webpack_require__(224);
	
	var _Footer = __webpack_require__(406);
	
	var _Footer2 = _interopRequireDefault(_Footer);
	
	var _Constant = __webpack_require__(389);
	
	var _Constant2 = _interopRequireDefault(_Constant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TerminalInput = function (_Component) {
	    (0, _inherits3.default)(TerminalInput, _Component);
	
	    function TerminalInput(props) {
	        (0, _classCallCheck3.default)(this, TerminalInput);
	
	        var _this = (0, _possibleConstructorReturn3.default)(this, (TerminalInput.__proto__ || (0, _getPrototypeOf2.default)(TerminalInput)).call(this, props));
	
	        _this.InputOnFocus = function () {
	            _this.refs.clipboard.focus();
	            _this.isOnFocus = true;
	            _this.setState({
	                isOnFocus: _this.isOnFocus
	            });
	        };
	
	        _this.InputOnBlur = function () {
	            _this.refs.clipboard.blur();
	            _this.isOnFocus = false;
	            _this.setState({
	                isOnFocus: _this.isOnFocus
	            });
	            _IsPcOrNot2.default.get() ? null : window.scroll(0, 0);
	        };
	
	        _this.KeyUpHandle = function (e) {
	            //回车
	            if (e.keyCode === 13) {
	                _this.props.enterHandle(_this.inputValue);
	                _this.inputValue = '';
	                _this.setState({
	                    inputValue: _this.inputValue
	                });
	            }
	        };
	
	        _this.inputValue = '';
	        _this.isOnFocus = false;
	        _this.now = 0;
	        _this.initData = [{ name: 'login:', value: 'root' }, { name: 'password:', value: '******' }, { name: 'AI-DEV', ip: 'BaiDu:', symbol: '~', value: '#' }];
	        _this.descList = ['Welcome to Create 2019 LTS (GNU/Linux 3.11.0-26-generic x86_64)', '', '170+ AI ability can be updated', '', 'New release \'2019.07.03 LTS\' available. Run \'create\' to upgrade to it', ''];
	        return _this;
	    }
	
	    (0, _createClass3.default)(TerminalInput, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var _this2 = this;
	
	            this.inputValue = '';
	            var str = this.initData[this.now].value;
	            if (str) {
	                var length = str.length;
	                var now = 0;
	                var initTimeLine = setInterval(function () {
	                    if (now <= length - 1) {
	                        _this2.inputValue += str[now];
	                        _this2.setState({
	                            inputValue: _this2.inputValue
	                        });
	                        now++;
	                    } else {
	                        now = 0;
	                        _this2.props.outPutList.push({ result: _this2.initData[_this2.now].name + _this2.initData[_this2.now].value });
	                        _this2.now++;
	                        _this2.props.changeOutPut();
	                        _this2.setState({
	                            now: _this2.now
	                        });
	                        if (_this2.now == _this2.initData.length - 1) {
	                            _this2.inputValue = '';
	                            _this2.setState({
	                                inputValue: _this2.inputValue
	                            });
	                            _this2.props.renderSlowLine(_this2.descList);
	                            clearTimeout(initTimeLine);
	                        }
	                    }
	                }, 100);
	            }
	        }
	    }, {
	        key: 'inputOnChange',
	        value: function inputOnChange(event) {
	            this.inputValue = event.target.value;
	            this.setState({
	                inputValue: this.inputValue
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'cmd', onClick: this.InputOnFocus, ref: 'cmdView',
	                    style: { width: '100%', overflow: 'hidden' } },
	                this.props.nameFlag ? _react2.default.createElement(
	                    'span',
	                    { className: 'prompt' },
	                    _react2.default.createElement(
	                        'span',
	                        { style: {
	                                fontWeight: 'blod',
	                                color: this.now == this.initData.length - 1 ? '#73c9e3' : '#fff'
	                            } },
	                        this.initData[this.now].name
	                    ),
	                    this.now == this.initData.length - 1 ? _react2.default.createElement(
	                        'span',
	                        null,
	                        _react2.default.createElement(
	                            'span',
	                            null,
	                            '@'
	                        ),
	                        _react2.default.createElement(
	                            'span',
	                            { style: { color: '#78d065' } },
	                            this.initData[this.now].ip
	                        ),
	                        _react2.default.createElement(
	                            'span',
	                            { style: { color: '#fced78' } },
	                            this.initData[this.now].symbol
	                        ),
	                        _react2.default.createElement(
	                            'span',
	                            null,
	                            '#'
	                        )
	                    ) : null
	                ) : null,
	                _react2.default.createElement(
	                    'span',
	                    null,
	                    this.inputValue
	                ),
	                _react2.default.createElement(
	                    'span',
	                    { className: this.isOnFocus ? 'cursor blink' : 'cursor' },
	                    '\xA0\xA0'
	                ),
	                _react2.default.createElement('span', null),
	                _react2.default.createElement('textarea', {
	                    ref: 'clipboard',
	                    onChange: this.inputOnChange.bind(this),
	                    onFocus: this.InputOnFocus,
	                    onBlur: this.InputOnBlur,
	                    value: this.inputValue,
	                    onKeyUp: this.KeyUpHandle.bind(this),
	                    style: {
	                        backgroundColor: "#000"
	                    },
	                    className: 'clipboard' })
	            );
	        }
	    }]);
	    return TerminalInput;
	}(_react.Component);
	
	var TerminalOutput = function (_Component2) {
	    (0, _inherits3.default)(TerminalOutput, _Component2);
	
	    function TerminalOutput(props) {
	        (0, _classCallCheck3.default)(this, TerminalOutput);
	
	        var _this3 = (0, _possibleConstructorReturn3.default)(this, (TerminalOutput.__proto__ || (0, _getPrototypeOf2.default)(TerminalOutput)).call(this, props));
	
	        _this3.changeOutPut = function () {
	            _this3.setState({
	                outPutList: _this3.outPutList
	            });
	        };
	
	        _this3.intoView = function () {
	            var container = void 0;
	            setTimeout(function () {
	                container = _this3.refs.terminal;
	                container.scrollTop = container.scrollHeight;
	            });
	        };
	
	        _this3.enterHandle = function (cmd) {
	            cmd = cmd.trim();
	            var hasCmd = false;
	            for (var i = 0; i < _this3.cmdList.length; i++) {
	                if (_this3.cmdList[i] == cmd) {
	                    hasCmd = true;
	                }
	            }
	            if (cmd != 'createStart') {
	                var cmdLog = { name: 'AI-DEV', ip: 'BaiDu:', symbol: '~', value: cmd };
	                _this3.outPutList.push({ cmdLog: cmdLog });
	            }
	            if (!hasCmd && cmd != 'createStart' && cmd !== '' && cmd !== 'ls' && cmd !== 'll' && cmd !== 'pwd') {
	                _this3.outPutList.push({ result: cmd + ' : command not found, type \'help\' for more info' });
	            }
	            if (cmd == 'createStart') {
	                _this3.nameFlag = false;
	                _this3.setState({
	                    nameFlag: _this3.nameFlag
	                }, function () {
	                    _this3.lottieRender('createStartBox', '/json/createJson/CREATE.json');
	                });
	            }
	            if (cmd == 'create') {
	                _this3.nameFlag = false;
	                _this3.setState({
	                    nameFlag: _this3.nameFlag
	                }, function () {
	                    _this3.lottieRender('create-box', _IsPcOrNot2.default.get() ? '/json/hengban/hengban.json' : '/json/shuban/shuban.json');
	                });
	            }
	            if (cmd == 'info') {
	                _this3.nameFlag = false;
	                _this3.setState({
	                    nameFlag: _this3.nameFlag
	                }, function () {
	                    _this3.lottieRender('infoBox', '/json/info.json');
	                });
	            }
	            if (cmd == 'register' || cmd == 'exit' || cmd == 'AI') {
	                _this3.outPutList.push({ progress: 'register' });
	                _this3.nameFlag = false;
	                _this3.setState({
	                    nameFlag: _this3.nameFlag
	                });
	                if (_this3.props.flag) {
	                    _this3.props.flag.value = false;
	                    _this3.setState(_this3.props.flag);
	                }
	                var n = 0;
	                var progressTimeLine = setInterval(function () {
	                    n = n + 4;
	                    _this3.progressSymbol += '#';
	                    _this3.progressNumber += 4;
	                    _this3.setState({
	                        progressSymbol: _this3.progressSymbol,
	                        progressNumber: _this3.progressNumber
	                    });
	                    if (_this3.progressSymbol.length == 26) {
	                        clearTimeout(progressTimeLine);
	                        _this3.progressSymbol = '';
	                        _this3.progressNumber = 0;
	                        _this3.outPutList.pop();
	                        _this3.nameFlag = true;
	                        _this3.setState({
	                            progressSymbol: _this3.progressSymbol,
	                            progressNumber: _this3.progressNumber,
	                            outPutList: _this3.outPutList,
	                            nameFlag: _this3.nameFlag
	                        });
	                        if (cmd == 'register') {
	                            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + '/ticket_type');
	                        }
	                        if (cmd == 'exit') {
	                            _reactRouter.browserHistory.push(_Constant2.default.router_preffix + '/');
	                        }
	                        if (cmd == 'AI') {
	                            location.href = 'https://ai.baidu.com';
	                        }
	                    }
	                }, 20);
	            }
	            if (cmd == 'speakers') {
	                $.get('json/speakers.json' + "?timestamp=" + new Date().getTime(), function (data) {
	                    _this3.showInfo(data, cmd);
	                });
	            }
	            if (cmd == 'agenda') {
	                $.get('json/agenda.json' + "?timestamp=" + new Date().getTime(), function (data) {
	                    _this3.showInfo(data[0].agendaDetailEntities, cmd);
	                });
	            }
	            if (cmd == 'courses') {
	                $.get('json/agenda.json' + "?timestamp=" + new Date().getTime(), function (data) {
	                    var opens = [];
	                    for (var i = 0; i < data.length; i++) {
	                        if (data[i].forum_type == 2) {
	                            opens.push(data[i]);
	                        }
	                    }
	                    _this3.showInfo(opens, cmd);
	                });
	            }
	            if (cmd == 'where') {
	                _this3.showInfo([{
	                    ch: '北京市朝阳区天辰东路7号国家会议中心',
	                    en: 'China National Convention Center (CNCC): No. 7 Tiancheng East Rd'
	                }], cmd);
	            }
	            if (cmd == 'help') {
	                _this3.outPutList.push({
	                    help: 'Ticket, invoice and related service, please email to create_help@baidu.com'
	                });
	            }
	            if (cmd == 'whoami') {
	                _this3.outPutList.push({
	                    developer: 'developer'
	                });
	            }
	            if (cmd == 'ls') {
	                _this3.outPutList.push({
	                    ls: ['create2017', 'create2018', 'create2019']
	                });
	            }
	            if (cmd == 'pwd') {
	                _this3.outPutList.push({
	                    pwd: '/home/developer/'
	                });
	            }
	            if (cmd == 'll') {
	                var data = ['drwxrwxr-x 5 developer baidu 4096 May  7 10:24 ./', 'drwxr-xr-x 3 developer baidu 4096 May  7 10:24 ../', 'drwxrwxr-x 2 developer baidu 4096 Jul  5 10:24 create2017/', 'drwxrwxr-x 2 developer baidu 4096 Jul  4 10:24 create2018/', 'drwxrwxr-x 2 developer baidu 4096 Jul  3 10:24 create2019/'];
	                _this3.showInfo(data, cmd);
	            }
	            _this3.setState({
	                outPutList: _this3.outPutList
	            }, function () {
	                // this.refs.TerminalInput.intoView();
	                _this3.intoView();
	            });
	        };
	
	        _this3.showInfo = function (data, cmd) {
	            var n = 0;
	            var animate = setInterval(function () {
	                if (cmd == 'speakers') {
	                    if (n == 0) {
	                        _this3.outPutList.push({
	                            speakers: data[n], speakersFirst: '\n  ____  ____  _____    _    _  _______ ____  ____  \n / ___||  _ \\| ____|  / \\  | |/ / ____|  _ \\/ ___| \n \\___ \\| |_) |  _|   / _ \\ | \' /|  _| | |_) \\___ \\ \n  ___) |  __/| |___ / ___ \\| . \\| |___|  _ < ___) |\n |____/|_|   |_____/_/   \\_\\_|\\_\\_____|_| \\_\\____/ \n                    '
	                        });
	                    } else {
	                        _this3.outPutList.push({ speakers: data[n] });
	                    }
	                }
	                if (cmd == 'agenda') {
	                    if (n == 0) {
	                        _this3.outPutList.push({
	                            agenda: data[n], agendaFirst: '\n     _    ____ _____ _   _ ____    _    \n    / \\  / ___| ____| \\ | |  _ \\  / \\   \n   / _ \\| |  _|  _| |  \\| | | | |/ _ \\  \n  / ___ \\ |_| | |___| |\\  | |_| / ___ \\ \n /_/   \\_\\____|_____|_| \\_|____/_/   \\_\\\n                    '
	                        });
	                    } else {
	                        _this3.outPutList.push({ agenda: data[n] });
	                    }
	                }
	                if (cmd == 'courses') {
	                    if (n == 0) {
	                        _this3.outPutList.push({
	                            courses: data[n], coursesFirst: '\n   ____ ___  _   _ ____  _____ ____  \n  / ___/ _ \\| | | |  _ \\| ____/ ___| \n | |  | | | | | | | |_) |  _| \\___ \\ \n | |__| |_| | |_| |  _ <| |___ ___) |\n  \\____\\___/ \\___/|_| \\_\\_____|____/ \n                        \n                    '
	                        });
	                    } else {
	                        _this3.outPutList.push({ courses: data[n] });
	                    }
	                }
	                if (cmd == 'where') {
	                    _this3.outPutList.push({
	                        where: data[n], whereFirst: '\n  _     ___   ____    _  _____ ___ ___  _   _ \n | |   / _ \\ / ___|  / \\|_   _|_ _/ _ \\| \\ | |\n | |  | | | | |     / _ \\ | |  | | | | |  \\| |\n | |__| |_| | |___ / ___ \\| |  | | |_| | |\\  |\n |_____\\___/ \\____/_/   \\_\\_| |___\\___/|_| \\_|\n                    '
	                    });
	                }
	                if (cmd == 'll') {
	                    _this3.outPutList.push({
	                        ll: data[n]
	                    });
	                }
	                _this3.nameFlag = false;
	                _this3.setState({
	                    outPutList: _this3.outPutList,
	                    nameFlag: _this3.nameFlag
	                }, function () {
	                    // this.refs.TerminalInput.intoView();
	                    _this3.intoView();
	                    if (n == data.length - 1) {
	                        _this3.nameFlag = true;
	                        _this3.setState({
	                            nameFlag: _this3.nameFlag
	                        });
	                        clearTimeout(animate);
	                    }
	                    n++;
	                });
	            }, 200);
	        };
	
	        _this3.lottieRender = function (box, path) {
	            _this3.outPutList.push({ className: box });
	            _this3.setState({
	                outPutList: _this3.outPutList
	            }, function () {
	                var element = _this3.refs[box];
	                var create = _lottieWeb2.default.loadAnimation({
	                    container: element, // the dom element that will contain the animation
	                    renderer: 'svg',
	                    loop: true,
	                    autoplay: true,
	                    path: path });
	                var delay = setTimeout(function () {
	                    _this3.nameFlag = true;
	                    _this3.setState({
	                        nameFlag: true
	                    });
	                    clearTimeout(delay);
	                    // this.refs.TerminalInput.intoView();
	                    _this3.intoView();
	                }, 200);
	            });
	        };
	
	        _this3.renderSlowLine = function (a) {
	            var n = 0;
	            var f = setInterval(function () {
	                if (n < a.length) {
	                    _this3.outPutList.push({ desc: a[n] });
	                    n++;
	                    _this3.setState({
	                        outPutList: _this3.outPutList
	                    });
	                } else {
	                    clearTimeout(f);
	                    _this3.enterHandle('createStart');
	                }
	            }, 200);
	        };
	
	        _this3.showMoreCmd = function () {
	            _this3.showMoreFlag = !_this3.showMoreFlag;
	            _this3.setState({
	                showMoreFlag: _this3.showMoreFlag
	            });
	        };
	
	        _this3.toolBoxClick = function (cmd) {
	            _this3.showMoreFlag = false;
	            _this3.setState({
	                showMoreFlag: _this3.showMoreFlag
	            });
	            if (_this3.nameFlag) {
	                _this3.enterHandle(cmd);
	            }
	        };
	
	        _this3.renderDoms = function (item, key) {
	            if (item.result) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key, className: 'terminal-output', style: {
	                            height: _IsPcOrNot2.default.get() ? '30px' : 'auto',
	                            display: "flex",
	                            alignItems: "center"
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'command' },
	                        _react2.default.createElement(
	                            'span',
	                            null,
	                            item.result
	                        )
	                    )
	                );
	            }
	            if (item.desc || item.desc == '') {
	                return _react2.default.createElement(
	                    'p',
	                    { key: key, style: {
	                            margin: '0',
	                            lineHeight: _IsPcOrNot2.default.get() ? '30px' : '.4rem',
	                            height: item.desc == '' ? _IsPcOrNot2.default.get() ? '15px' : '.2rem' : 'auto'
	                        } },
	                    item.desc
	                );
	            }
	            if (item.cmdLog) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key, style: { width: '100%' } },
	                    _react2.default.createElement(
	                        'span',
	                        { style: { color: '#73c9e3' } },
	                        item.cmdLog.name
	                    ),
	                    _react2.default.createElement(
	                        'span',
	                        null,
	                        '@'
	                    ),
	                    _react2.default.createElement(
	                        'span',
	                        { style: { color: '#78d065' } },
	                        item.cmdLog.ip
	                    ),
	                    _react2.default.createElement(
	                        'span',
	                        { style: { color: '#fced78' } },
	                        item.cmdLog.symbol
	                    ),
	                    '#',
	                    _react2.default.createElement(
	                        'span',
	                        null,
	                        item.cmdLog.value
	                    )
	                );
	            }
	            if (item.className) {
	                if (item.className == 'createStartBox') {
	                    return _react2.default.createElement('div', { key: key, style: {
	                            width: _IsPcOrNot2.default.get() ? '90%' : '100%',
	                            height: _IsPcOrNot2.default.get() ? 'auto' : 'auto',
	                            margin: '0 auto'
	                        }, ref: item.className });
	                }
	                if (item.className == 'create-box') {
	                    return _react2.default.createElement('div', { key: key, ref: item.className, style: {
	                            width: 'auto',
	                            height: '100%',
	                            margin: '0 auto'
	                        }, className: 'create-box' });
	                }
	                if (item.className == 'infoBox') {
	                    return _react2.default.createElement('div', { key: key, ref: item.className, style: {
	                            width: _IsPcOrNot2.default.get() ? '450px' : 'auto',
	                            height: _IsPcOrNot2.default.get() ? 'auto' : '100%',
	                            margin: '0 auto'
	                        } });
	                }
	            }
	
	            if (item.progress == 'register') {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key, ref: item.progress, style: {
	                            width: '100%',
	                            padding: _IsPcOrNot2.default.get() ? '15px 0' : '.1rem 0',
	                            fontSize: _IsPcOrNot2.default.get() ? '20px' : '12px'
	                        } },
	                    '[',
	                    _this3.progressSymbol,
	                    ']',
	                    _this3.progressNumber,
	                    '%'
	                );
	            }
	
	            if (item.speakers) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key, style: {
	                            padding: '.3rem 0',
	                            borderBottom: '1px dashed #fff'
	                        } },
	                    item.speakersFirst ? _react2.default.createElement(
	                        'div',
	                        { style: {
	                                borderTop: '1px dashed #fff',
	                                borderBottom: '1px dashed #fff'
	                            } },
	                        _react2.default.createElement(
	                            'pre',
	                            { style: _IsPcOrNot2.default.get() ? {} : {
	                                    transform: 'scale(0.75)',
	                                    transformOrigin: 'left'
	                                } },
	                            item.speakersFirst
	                        )
	                    ) : null,
	                    _react2.default.createElement(
	                        'div',
	                        {
	                            style: { padding: '.15rem 0' } },
	                        'Name: ',
	                        localStorage['language'] == 'en' ? item.speakers.name_en : item.speakers.name_ch
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        null,
	                        'Title: ',
	                        localStorage['language'] == 'en' ? item.speakers.desc_en : item.speakers.desc_ch
	                    )
	                );
	            }
	            if (item.agenda) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key, style: {
	                            padding: '.3rem 0',
	                            borderBottom: '1px dashed #fff'
	                        } },
	                    item.agendaFirst ? _react2.default.createElement(
	                        'div',
	                        { style: {
	                                borderTop: '1px dashed #fff',
	                                borderBottom: '1px dashed #fff'
	                            } },
	                        _react2.default.createElement(
	                            'pre',
	                            { style: _IsPcOrNot2.default.get() ? {} : {
	                                    transform: 'scale(0.9)',
	                                    transformOrigin: 'left'
	                                } },
	                            item.agendaFirst
	                        )
	                    ) : null,
	                    _react2.default.createElement(
	                        'div',
	                        { style: { padding: '.15rem 0' } },
	                        item.agenda.agenda_time
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { style: { padding: '.15rem 0' } },
	                        localStorage['language'] == 'en' ? item.agenda.title_en : item.agenda.title_ch
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { style: { padding: '.15rem 0' } },
	                        localStorage['language'] == 'en' ? item.agenda.speaker_en : item.agenda.speaker_ch
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { style: { padding: '.15rem 0' } },
	                        localStorage['language'] == 'en' ? item.agenda.desc_en : item.agenda.desc_ch
	                    )
	                );
	            }
	            if (item.courses) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key, style: {
	                            padding: '.3rem 0',
	                            borderBottom: '1px dashed #fff'
	                        } },
	                    item.coursesFirst ? _react2.default.createElement(
	                        'div',
	                        { style: {
	                                borderTop: '1px dashed #fff',
	                                borderBottom: '1px dashed #fff'
	                            } },
	                        _react2.default.createElement(
	                            'pre',
	                            null,
	                            item.coursesFirst
	                        )
	                    ) : null,
	                    _react2.default.createElement(
	                        'div',
	                        { style: { padding: '.15rem 0' } },
	                        'Title: ',
	                        localStorage['language'] == 'en' ? item.courses.title_en : item.courses.title_ch
	                    )
	                );
	            }
	            if (item.where) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key, style: {
	                            padding: '.3rem 0 0 0',
	                            borderBottom: '1px dashed #fff'
	                        } },
	                    item.whereFirst ? _react2.default.createElement(
	                        'div',
	                        { style: {
	                                borderTop: '1px dashed #fff',
	                                borderBottom: '1px dashed #fff'
	                            } },
	                        _react2.default.createElement(
	                            'pre',
	                            { style: _IsPcOrNot2.default.get() ? {} : {
	                                    transform: "scale(0.8)",
	                                    transformOrigin: "left"
	                                } },
	                            item.whereFirst
	                        )
	                    ) : null,
	                    _react2.default.createElement(
	                        'div',
	                        { style: { padding: '.15rem 0' } },
	                        localStorage['language'] == 'en' ? item.where.en : item.where.ch
	                    )
	                );
	            }
	            if (item.help) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key },
	                    item.help
	                );
	            }
	            if (item.developer) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key },
	                    item.developer
	                );
	            }
	            if (item.ls) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key },
	                    _react2.default.createElement(
	                        'span',
	                        { style: { padding: '0 .2rem 0 0' } },
	                        item.ls[0]
	                    ),
	                    _react2.default.createElement(
	                        'span',
	                        { style: { padding: '0 .2rem' } },
	                        item.ls[1]
	                    ),
	                    _react2.default.createElement(
	                        'span',
	                        { style: { padding: '0 .2rem' } },
	                        item.ls[2]
	                    )
	                );
	            }
	            if (item.pwd) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key },
	                    item.pwd
	                );
	            }
	            if (item.ll) {
	                return _react2.default.createElement(
	                    'div',
	                    { key: key },
	                    item.ll
	                );
	            }
	        };
	
	        _this3.outPutList = [];
	        _this3.cmdList = ['create', 'info', 'agenda', 'courses', 'speakers', 'where', 'register', 'AI', 'help', 'whoami', 'exit'];
	        _this3.showMoreFlag = false;
	        _this3.nameFlag = false;
	        _this3.progressSymbol = '';
	        _this3.progressNumber = 0;
	
	        return _this3;
	    }
	
	    (0, _createClass3.default)(TerminalOutput, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {}
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this4 = this;
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'terminal-c', ref: 'container', style: {
	                        width: '100%',
	                        height: '100%'
	                    } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'terminal', ref: 'terminal', style: {
	                            position: 'absolute',
	                            top: _IsPcOrNot2.default.get() ? '0' : '.2rem',
	                            bottom: _IsPcOrNot2.default.get() ? '35px' : '1rem',
	                            left: 0,
	                            right: 0,
	                            padding: '0 .31rem',
	                            overflow: 'auto'
	                        } },
	                    this.outPutList.map(function (item, key) {
	                        return _this4.renderDoms(item, key);
	                    }),
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                position: 'relative',
	                                marginTop: _IsPcOrNot2.default.get() ? '5px' : ''
	                            } },
	                        _react2.default.createElement(TerminalInput, { ref: 'TerminalInput', outPutList: this.outPutList,
	                            changeOutPut: this.changeOutPut,
	                            nameFlag: this.nameFlag,
	                            renderSlowLine: this.renderSlowLine,
	                            enterHandle: this.enterHandle })
	                    )
	                ),
	                _react2.default.createElement(
	                    'div',
	                    { style: {
	                            position: _IsPcOrNot2.default.get() ? 'absolute' : 'fixed',
	                            bottom: '.31rem',
	                            right: '.31rem',
	                            borderTop: "1px solid #fff",
	                            background: 'rgba(0,0,0,0.8)',
	                            cursor: 'pointer',
	                            zIndex: "9999999"
	                        } },
	                    _react2.default.createElement(
	                        'div',
	                        { style: {
	                                display: this.showMoreFlag ? 'block' : 'none'
	                            } },
	                        this.cmdList.map(function (item, key) {
	                            return _react2.default.createElement(
	                                'div',
	                                { onClick: _this4.toolBoxClick.bind(_this4, item), key: key, style: {
	                                        width: _IsPcOrNot2.default.get() ? '100px' : '1.4rem',
	                                        height: _IsPcOrNot2.default.get() ? '35px' : '.6rem',
	                                        border: '1px solid #fff',
	                                        boxSizing: 'border-box',
	                                        borderTop: item == 0 ? '1px solid #fff' : '0',
	                                        display: 'flex',
	                                        alignItems: 'center',
	                                        justifyContent: 'center'
	                                    } },
	                                item
	                            );
	                        })
	                    ),
	                    _react2.default.createElement(
	                        'div',
	                        { onClick: this.showMoreCmd, style: {
	                                width: _IsPcOrNot2.default.get() ? '100px' : '1.4rem',
	                                height: _IsPcOrNot2.default.get() ? '35px' : '.6rem',
	                                border: '1px solid #fff',
	                                boxSizing: 'border-box',
	                                zIndex: '999',
	                                display: 'flex',
	                                alignItems: 'center',
	                                justifyContent: 'center',
	                                flexWrap: "wrap",
	                                fontSize: _IsPcOrNot2.default.get() ? '15px' : "14px",
	                                borderTop: '0'
	                            } },
	                        _react2.default.createElement(
	                            'span',
	                            null,
	                            'toolbox'
	                        ),
	                        _react2.default.createElement('span', { style: _IsPcOrNot2.default.get() ? {
	                                width: "0",
	                                height: '0',
	                                borderRight: "10px solid transparent",
	                                borderLeft: '10px solid transparent',
	                                borderTop: this.showMoreFlag ? '10px solid white' : '',
	                                borderBottom: this.showMoreFlag ? '' : '10px solid white',
	                                marginLeft: '.05rem'
	                            } : {
	                                width: "0",
	                                height: '0',
	                                borderRight: ".14rem solid transparent",
	                                borderLeft: '.14rem solid transparent',
	                                borderTop: this.showMoreFlag ? '.14rem solid white' : '',
	                                borderBottom: this.showMoreFlag ? '' : '.14rem solid white',
	                                marginLeft: '.05rem'
	                            } })
	                    )
	                )
	            );
	        }
	    }]);
	    return TerminalOutput;
	}(_react.Component);
	
	var PC = function (_Component3) {
	    (0, _inherits3.default)(PC, _Component3);
	
	    function PC(props) {
	        (0, _classCallCheck3.default)(this, PC);
	        return (0, _possibleConstructorReturn3.default)(this, (PC.__proto__ || (0, _getPrototypeOf2.default)(PC)).call(this, props));
	    }
	
	    (0, _createClass3.default)(PC, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { style: { backgroundColor: '#000000', minHeight: "100%" } },
	                _react2.default.createElement(_Header2.default, null),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'pc' },
	                    _react2.default.createElement(TerminalOutput, null)
	                )
	            );
	        }
	    }]);
	    return PC;
	}(_react.Component);
	
	var Phone = function (_Component4) {
	    (0, _inherits3.default)(Phone, _Component4);
	
	    function Phone(props) {
	        (0, _classCallCheck3.default)(this, Phone);
	        return (0, _possibleConstructorReturn3.default)(this, (Phone.__proto__ || (0, _getPrototypeOf2.default)(Phone)).call(this, props));
	    }
	
	    (0, _createClass3.default)(Phone, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { ref: 'phone', style: { backgroundColor: '#000000', minHeight: '100%' } },
	                _react2.default.createElement(_Header2.default, null),
	                _react2.default.createElement(
	                    'div',
	                    { className: 'phone' },
	                    _react2.default.createElement(TerminalOutput, null)
	                )
	            );
	        }
	    }]);
	    return Phone;
	}(_react.Component);
	
	var Terminal = function (_Component5) {
	    (0, _inherits3.default)(Terminal, _Component5);
	
	    function Terminal() {
	        (0, _classCallCheck3.default)(this, Terminal);
	        return (0, _possibleConstructorReturn3.default)(this, (Terminal.__proto__ || (0, _getPrototypeOf2.default)(Terminal)).apply(this, arguments));
	    }
	
	    (0, _createClass3.default)(Terminal, [{
	        key: 'render',
	        value: function render() {
	            return _IsPcOrNot2.default.get() ? _react2.default.createElement(PC, null) : _react2.default.createElement(Phone, null);
	        }
	    }]);
	    return Terminal;
	}(_react.Component);
	
	exports.TerminalOutput = TerminalOutput;
	exports.default = Terminal;

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(495);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(379)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(495, function() {
				var newContent = __webpack_require__(495);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(378)();
	// imports
	
	
	// module
	exports.push([module.id, "@keyframes terminal-blink{0%,to{background-color:#000;color:#aaa}50%{background-color:#bbb;color:#000}}@font-face{font-family:century;src:url(" + __webpack_require__(496) + ")}.phone{width:100%;min-height:100%;background:#000;padding:0 .31rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.phone .word-desc{color:#fff;font-size:15px;margin-bottom:20px}.phone .word-desc p{margin:0;margin-top:.45rem;line-height:.4rem}.phone .terminal-c{width:100%;color:#fff;min-height:100%;font-size:15px;line-height:18px;background:#000}.phone .terminal-c .terminal span{display:inline-block;word-wrap:break-word}.phone .terminal-c .terminal .cmd{width:100%;position:relative}.phone .terminal-c .terminal .cmd span{float:left;display:block}.phone .terminal-c .terminal .cmd .clipboard{position:absolute;left:-100px;top:0;width:10px;height:16px;background:0 0;border:0;color:transparent;outline:0;padding:0;resize:none;z-index:-1;overflow:hidden}.phone .terminal-c .terminal .cmd .blink{background-color:#aaa;color:#000;animation:terminal-blink 1s infinite step-start;float:left}.phone .terminal-c .terminal ::-webkit-scrollbar{width:0;background:#000}.phone .terminal-c pre{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;margin:0;white-space:pre;font-family:Courier New,Monospace}.pc{width:100%;min-height:100%;background:#000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.pc .word-desc{color:#fff;font-size:25px;margin-bottom:20px}.pc .word-desc p{margin:0;margin-top:.45rem;line-height:.4rem}.pc .terminal-c{width:100%;color:#fff;min-height:100%;font-size:16px;line-height:16px;background:#000}.pc .terminal-c .terminal span{display:inline-block;word-wrap:break-word}.pc .terminal-c .terminal .cmd{width:100%;position:relative}.pc .terminal-c .terminal .cmd span{float:left;display:block}.pc .terminal-c .terminal .cmd .clipboard{position:absolute;left:-16px;top:0;width:10px;height:16px;background:0 0;border:0;color:transparent;outline:0;padding:0;resize:none;z-index:0;overflow:hidden}.pc .terminal-c .terminal .cmd .blink{background-color:#aaa;color:#000;animation:terminal-blink 1s infinite step-start;float:left}.pc .terminal-c pre{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;margin:0;white-space:pre;font-family:Courier New,Monospace}", "", {"version":3,"sources":["/Users/baidu/Desktop/project/ai-web-2019/src/routes/terminal/components/src/routes/terminal/components/terminal.scss"],"names":[],"mappings":"AAAA,0BACE,MACE,sBAAsB,UACX,CAAA,IAGX,sBAAsB,UACX,CAAA,CAAA,WAKb,oBAAsB,iCACyB,CAAA,OAI/C,WAAW,gBACK,gBACG,iBACF,yBACjB,sBAAA,qBAAA,gBAAiB,CALnB,kBAOI,WAAc,eACC,kBACI,CATvB,oBAWM,SAAS,kBACS,iBACA,CAbxB,mBAiBI,WAAW,WACG,gBACE,eACD,iBACE,eACD,CAtBpB,kCAyBQ,qBAAqB,oBACA,CA1B7B,kCA6BQ,WAAW,iBACO,CA9B1B,uCAgCU,WAAW,aACG,CAjCxB,6CAoCU,kBAAkB,YACN,MACN,WACK,YACC,eACG,SACN,kBACS,UACR,UACA,YACE,WACD,eACK,CAhD1B,yCAmDU,sBAAsB,WACX,gDAC0C,UAEvD,CAvDR,iDA2DM,QAAO,eACW,CA5DxB,uBA+DM,oBAAA,aAAa,sBACb,mBAAmB,SACV,gBACO,iCACqB,CAEtC,IAIH,WAAW,gBACK,gBACG,yBACnB,sBAAA,qBAAA,gBAAiB,CAJnB,eAMI,WAAc,eACC,kBACI,CARvB,iBAUM,SAAS,kBACS,iBACA,CAZxB,gBAgBI,WAAW,WACG,gBACE,eACD,iBACE,eACD,CArBpB,+BAwBQ,qBAAqB,oBACA,CAzB7B,+BA4BQ,WAAW,iBACO,CA7B1B,oCA+BU,WAAW,aACG,CAhCxB,0CAmCU,kBAAkB,WACP,MACL,WACK,YACC,eACG,SACN,kBACS,UACR,UACA,YACE,UACF,eACM,CA/C1B,sCAkDU,sBAAsB,WACX,gDAC0C,UAEvD,CAtDR,oBA0DM,oBAAA,aAAa,sBACb,mBAAmB,SACV,gBACO,iCACqB,CAEtC","file":"terminal.scss","sourcesContent":["@keyframes terminal-blink {\n  0%, 100% {\n    background-color: #000;\n    color: #aaa;\n  }\n  50% {\n    background-color: #bbb;\n    color: #000;\n  }\n}\n\n@font-face {\n  font-family: 'century';\n  src: url('../../../components/lib/Century.ttf');\n}\n\n.phone {\n  width: 100%;\n  min-height: 100%;\n  background: #000000;\n  padding: 0 .31rem;\n  user-select: none;\n  .word-desc {\n    color: #ffffff;\n    font-size: 15px;\n    margin-bottom: 20px;\n    p {\n      margin: 0;\n      margin-top: .45rem;\n      line-height: .4rem;\n    }\n  }\n  .terminal-c {\n    width: 100%;\n    color: #ffffff;\n    min-height: 100%;\n    font-size: 15px;\n    line-height: 18px;\n    background: #000;\n    .terminal {\n      span {\n        display: inline-block;\n        word-wrap: break-word;\n      }\n      .cmd {\n        width: 100%;\n        position: relative;\n        span {\n          float: left;\n          display: block;\n        }\n        .clipboard {\n          position: absolute;\n          left: -100px;\n          top: 0;\n          width: 10px;\n          height: 16px;\n          background: 0 0;\n          border: 0;\n          color: transparent;\n          outline: 0;\n          padding: 0;\n          resize: none;\n          z-index: -1;\n          overflow: hidden;\n        }\n        .blink {\n          background-color: #aaa;\n          color: #000;\n          animation: terminal-blink 1s infinite steps(1, start);\n          float: left\n        }\n      }\n    }\n    .terminal ::-webkit-scrollbar{\n      width:0;\n      background:#000000;\n    }\n    pre {\n      display: flex;\n      align-items: center;\n      margin: 0;\n      white-space: pre;\n      font-family: \"Courier New\", Monospace;\n\n    }\n  }\n}\n.pc {\n  width: 100%;\n  min-height: 100%;\n  background: #000000;\n  user-select: none;\n  .word-desc {\n    color: #ffffff;\n    font-size: 25px;\n    margin-bottom: 20px;\n    p {\n      margin: 0;\n      margin-top: .45rem;\n      line-height: .4rem;\n    }\n  }\n  .terminal-c {\n    width: 100%;\n    color: #ffffff;\n    min-height: 100%;\n    font-size: 16px;\n    line-height: 16px;\n    background: #000;\n    .terminal {\n      span {\n        display: inline-block;\n        word-wrap: break-word;\n      }\n      .cmd {\n        width: 100%;\n        position: relative;\n        span {\n          float: left;\n          display: block;\n        }\n        .clipboard {\n          position: absolute;\n          left: -16px;\n          top: 0;\n          width: 10px;\n          height: 16px;\n          background: 0 0;\n          border: 0;\n          color: transparent;\n          outline: 0;\n          padding: 0;\n          resize: none;\n          z-index: 0;\n          overflow: hidden;\n        }\n        .blink {\n          background-color: #aaa;\n          color: #000;\n          animation: terminal-blink 1s infinite steps(1, start);\n          float: left\n        }\n      }\n    }\n    pre {\n      display: flex;\n      align-items: center;\n      margin: 0;\n      white-space: pre;\n      font-family: \"Courier New\", Monospace;\n\n    }\n  }\n}\n"],"sourceRoot":""}]);
	
	// exports


/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2JB6hvaZTnFNALlMaWIL.ttf";

/***/ }),
/* 497 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 498 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 499 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 500 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 501 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 502 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIwAAACCCAYAAACUyiBOAAANPUlEQVR4nO2dedgVVR3HP4ii9gaK5KMgRm4oYJCa9lqaSehLGCq5ZmYiuT3Jk2iuPWUupZWampVroGFZpoKSaYIgmrjiAoZIuPRq5C6IisjSH9975fV658yZuXNm5uLv8zzzz50zZ86d+c3M+f3ObwHDMAzDMAzDMAzDMAzDMAzDMAzDMAzDMAzDMAzDMAwjYzrV/fVXK1N3uPL41IeGZgOgD7Al0BPYBOgBbAR0Bd6rtOkEvAasAywGXgZeBRZUtrlAO/BKvsMPT6dO9cWhI2vmMI6i6At8sbJtBQwCumfU91vAE0h4HgamAXMy6rvUrG4CsycwAtgB2DHgeboCX6psR1R+ewKYCdwM3A4sDXj+wlgdBGY74CDga8DAAscxsLIdjt48dwLjgQcKHFPmNLPADAe+C+xd9EDqsHVlOw64AxgL/LnQEWXEGkUPIAV7oaf2FsopLLW0AdcDs4BDCh5LwzSTwOwJTAEmATsVPJY0bAtcB8xAb8empBk+SS3ABcDRGfT1ElKNnwL+A7wAfAdNkutxaaVtT6A3MIBVKnlaWtHb8QbgeOC/DfSVO2UXmG8AFyL7SRrmAI8AdwNPArORStyR7YgWmBuRytyRtdHkdlt081tJN9k+ABgMnApcleL4QiizwJwHnJLiuEeBW4GpfPRm16ObY1/POr+9BzxU2cZWftsZ+DKwLxIgX3oAV6JP7DHAigTHFkIZBaYb0iiGJjjmHeCPlW1qiEHFMKOy/RzZfw4BDkOWYx+OBD4LHIisyKWlbJPe3sC9+AvLIuBcoB+66EUISy0PAWOA/uhz4ztHaQX+iQSntJRJYLZET6nvBbsI3ZTT0QS2bLyE3jj9gB8D73scsym6BiGt1A1RFoHZBL1Zenu0nYy++WOAF0MOKiMWAWejtaybPdq3oEn6gJCDSksZBKYFuAutGsdxOrAHeu03G3OQ1nc0sCym7brAPfg9QLlSBoG5Fa0su2hHC33nhh9OcK5AavjjMe26o2WFMtyjDyh6MD8Bdo9p8xCaEN4XfDT5MQfYBa1qu+gPXBZ+OP4UKTCtwBkxbaajC9tU1lBPFqMV9hti2h0J7BN+OH4UKTDjY/Y/CAxhNfUr6cCBaH3MxVhkYS6cogTm+8AWjv2voFVeH1V0dWBftGYVRXfgZzmNxUkRAtOCzP4uhgFv5jCWsrAcaX/vONqcQPo1tcwoQmCOQQ7WUZyB/GQ/brwAHBvT5qQ8BuIib4FZAy3pRzEXOCunsZSRa5FNKoqRwHo5jaUueQvMUNzGqB/kNZASc7Jj3yeAb+Y1kHrkLTD7OvbNIV5b+DjwCFr+iKJQFTtPgemM/HGj+G1eA2kCLnHsGwx8Kq+B1JKnwAwEekXsW4YcpQ3xNxR9WY8uyGGrEPIUGNfq6yQUjloEbzv2vZzbKD7MCuQwHsU2eQ2kljw97rZy7NsaXaD44N7s2cWx7yxgVF4DqcG1INsvt1HUkIfA7IYMcYc52vSjwIvgoBqbXTZGoLWo21DoTW4W8VDZG3qj8I2DkXe9EY6nUXTD1cD8Rjryyd6Q9RxmYzTDfxI4BxOWPOgLnIZCaK7C/elvmCwF5nto0KNxh24YYVgHzbf+hXyIg5CFwGyBDE2Xojgbo1jWBM4E7kdBepnSqMB8HXnEfTWDsRjZ8gUkNN/KstNGtKRRpAvxfB0l35mPQjFeQYa7ot1Fy8ZKdE2qadW2QC6b9aIxo+iCHNU2Q3PKhkkrMCcBv0jQ/lVknLsFpepYHV0u86AHsvIOR6YK36iCs1EU5gmNDiCNwByFv7DMA36DzP4vpTiX8WFeQw/eJGB9YH+kZPgkAxiDnNIach9J+hnYE7jco90ytEw/ALgYE5YQvImmBIPQQxy19tSRM5F9LDVJBKYXMMGj3Qxge+CXfHx8covmSqQR3ebRdhwNxG8nEZibUESei6uRKX1W2gEZqWlH7iM+zuITSLlu5yswo5Ga5uIilKTQKJYfIsuvi81RooDE+AjMhsR7+V+BJlVGOTiPeGvvSchLIBE+AnMG8iWNYirZ5J8zsuVs4p3SLkjaaZzA9EIz8CjeQkvtRjn5NgpfiWIvEubnixOY0cBajv2jgIVJTmjkyjLicwMninVyCcxauHX2B4gPJDeK5x7c5pCD0DzVC5fADMW9bpEmw6VRDK54r7WQxdgLl8C40rLPRGm1jOZgPm6j3jDfjlwC8xXHvrGOfUY5GefYtxue6USiBGYzlNWyHstRmjGjubgdeCNiX1c86zdECYzr4NnA8z6dG6XiLdxp3z7v00mUwLiS/dzv07FRSlzFvjbz6SBKYDZ3HGMLi82LK8uV655/QJTAuHLmljoXvuHElTHdJ09ypMC4wkRqy8cYzcMixz6vREVRLprLHcd09uk4IX1QqGwLWr9aivyAX0UO41Gz+9WBfuhzUP3vb6LllgVIwVic4blc984r3LXI8jcdnZk3R6pdPaoV1CZWtufyGFxg2tD/HoIiFaPW69rRnPEmVKfg9YBjKq3ADAFOxL/ETc/KtjtKHf8H4HzkYN5sjEBLKnHOaFU2rWzDkOP9OHQNikqNkmssUDcUI3MnyYpndWRd5G4xmwxCJnKkL/AP9KbwFZZaqmEis9CCYSHkJTA7ofWnrKLwuiDnn4no219m9kHRoXtk1N/GyDHq1xn1l4g8BGYPtMTuMgamZW9Uxax7gL6z4FDkWhAiOcFx6IHJldAC04pKuHQJeI5BKLdt2epX7ofmWyHZG33mciPkRV6fZOEM7cBjrFIje6LywFHaU0c+B/wFFbAqAwOAvyZoPw/Ny5ag69UHxRm5MqZXGYFCS05POMZUhBSY8fhZD69DgVgz+ahRsKodHY3K/LoYgTwEr0k2zCDc6NFmMfA7VEF3Nipv3JGqdnQUCgx0cRryIJiRbJjJCfVJasOdkxdUT6AVfefvpr4FeQEqLbwbyoDtslSCwnh93kghOYH48I2J6FN6MkrkXCssoDfu5egt60q3X2Wc/xDTE0pgLozZPwFpTq7V01quR0vwCxxt1kaBXEXxSRTe4eISlBH9mQT9XozsV/UEq0pfckgrH0JgBqM8JlE8gD4faTIvzkNvm3cdbY5FN64IRuKO4RqPakWlYQpK4OTi1JR9exNCYFzhsktpPI5pHiqhE0U3isvH70ot+zyKE2qEySjJQRQDCZCmrCNpBMb1SQB30c/zPY734Vr07Y/C5cAeih64vdZOzOg8p+G+hm2Ofa6gNi9tNkpLcmlPw5H2UrvyuRypkxtHHLeU+LlNEi5AE+J67II0jGXkk118OcqdE0U7fpqT77nGEq1G748eptqXwQrcTlJeL48owXDl309bO/pu/JLe+HIHmgTW83bvhQo8lIWbM+5vAtECswNat0qKlxtFlFQ9meKEcTyYcX+vA49m3GcosvaDnkv2PkIu980PiBKYqFd9IzwboE/XN7lMZPlmBdmjso7c8FrGiBKYmcCfshsLECZ9mcszsEysCNBnnBEzCdPwS3fmnOgcTrafkRBZwgurG5QQl20mDRuQXR2HZ0ngX+MSmKXISJZVWGzWhSr6I/N6MxAVRZqWwUhoGmUiyknoXUgsbvFxCXAEqsd4APrjXaj/KXgXLZJFFYYa4jsoT1z9vY80hSXk4/awBNiV6BKFbWRrUnCl6l+INMh62mNn9CJoR5rWtKQnzrpeUtvK47ndsX8o+jNZ8DjR2ZNmkH9hrNFEF/dcCXyabCbpnZDhLsoT4GpSJqcsol7Sg+hpi8InJagP++FOteUqFh6KaY59nXCb9JNwCm63EdcD2zBZC8wbuA1m25N+8a1KV+CymDYhzAJxzMJtvzqYBHlYItgG+Klj/2Kye4PXJcTio6vmMiif7/CUfXdGefZddZunoyJTRRDnmH0T8c5QUfRAqq/rnl1D4MjUEAIznXh1/BaSf2c/g5b44zzvfpSw3ywZh8r5RLE2uj5J3zTV2kdxGRbOT9hvYkI5UPnk7b0SuSfuGNNuPeTn8QRS811MQjekKN4j3juuBX22LyVe3d4Urd3d59H2PHKICg1VVRaUmvxkz8OmI5/Up1Dlk27oaWpFTkM+vsHvovpBIcNJffk7fsF6S1lVSvhpNAfcEP2Pwei/+8RdzUcht+lvHH5aUkiBAcUM5aXeDkM3qgy0IOH3LYDVCEuQW0kSl8+6FKFW19JGPgmIRlEeYQG5h+xMPoujw8lAWHwJLTCLkTPTlIDnGAn8PmD/aXkBWX/nBup/IbL4Tg7Uf13yCJVdhMz4F2Xc73x0Q8Zl3G+WPIeiI+KKRCTlXqQs5G6gzDN7wxgUq/Rwg/28jSzG26ELV3YWofCPkcC/G+zrf8jSuysFpTsJPemN4mDkQd+Gf0arZ5AF9yqaN+3rOig681D0qfblMVb992DZuMqgJcXRB32HByEH5Y2QRfMdtOT+InqS7kJvJlcgV7OxNXIc74+MkhuhLBQLkWmhHanak5FDW3B8BMYwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMPInP8DeLBWTjK+icgAAAAASUVORK5CYII="

/***/ }),
/* 503 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 504 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 505 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 506 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 507 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 508 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 509 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 510 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 511 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIwAAACCCAYAAACUyiBOAAAImUlEQVR4nO2d8XHqOBDGP91cAUdKICWQEkgJZF4Bb5ISQgmhhHD3/92EEkIJcQmhhOcS9v7QKvFx2FiyJMvw/WaYeXmAMebz7mpXKwGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEJIQkzzj/rHz8EHnP3z1+BjTBERWQBYAJgBWOp/L1teXgOo9N9V4++DMeYw4By+/m2M6XhlOL+fef5RH4u+B2yedCL2AHbGmG3qD+pCROYAVrDXZgkrlL60ikpEDrDi2QPYDxFQCroE8wzgJdeJeLAEsBSRhTHmKecHN0TyCGCe6GPm+ljpZ1YAtrA3SZ3oM3vzW8dzz9nOIoxHEclyjiKyFJE3AJ+wN1EqsZxiAeAVwKeIPIuIjyWLTptgnC8unaSCUaG8A3iH3vEjMoMV62euG+UUbYKZglgAYCYibYFlMCIyE5FXWKFEP/5AZgBeRORdXWRWulzSVOgdkPdBRFawrucx5nETsATwoaOzbFyCYKKhVuUNE7KwAN5ziuYSBFOdf0k36oI+UL5VOUVW0UxdMLUxZj/kADrqeEdk15YZ9x2SW8apC2Y95M0XIhbHDHb4nZRzmd5SqQGsI2R7U4jFZWqbqf9TzGF/5JBMcRsrPdYgq9tFLMEcYLOROaiGuiHgK8CNJZYdvksWQdlYjUFcFnmIeF4B3A54fycxBbMB0hW9YqJD56EBbg37nbcxUvbGmApAJSIbPbdnhAnHlRV2Q8/pFFOPYbzRuGWor18DuDXGbGLXd4wxtTFmA2slQi1psoTe1QkGViyhJr8CcJdCKMeocO6Rz9X34qoEo2WE0JrQHsC9uo5saEXedzSYLOi9KsEgvFi5NcbcjzW9QF3UE2zcdI4NIiQz27gawah1CSkkVrnn3ZxCUwj36BbDBgNzU+eYah4mhBDrUsP+SEWg7vBORB6hE8lgz3EPK5bks/OuQjA6DSDEujyUMMvtGLU2/wuGM0yPvRqXFJJz2cZIEF4a1yIY35GRS8qRIy5eMJpy901kbUubrV8KsQRT8oSjkNilqGRZScQKet3M9jWOcgV6h7cJqsoQVPq6ox2tSzsxR0mPsK0fXm/S1++hzVsxA02tG/lWpBnodlBKDLOEzZO8i0jM/puQ6QtJqryXQimCaTJHvP4bb+tSYt6lJEoUjMP133wM6L+hO4pMyYJxLBDef+MrtKyV6CkyldKAa6XwnV7gJbJUmV2Nx1z9JzYV7GgzS+w1FcEAVjRvInLXJ84ICJqTWBedDjpk0tY5lvo5FWyhNGkMNgWX1GSO/tMrfV1Y9AutsVdKsTRZwHZBJGVqggGAld61sUnhjkIncoeyQOLuzSkKBui30FEJzWljLBGS9Hu3Cab04eVcJxHFJGo5QN3RGDW2pEuAdAW9W/iZNzfzq9n19zXyaNSU3OKBQ+++FeIWCWPHMNnXblGSWpguwazx/eO2UUPXX4OKpK2RrTEcdgJyQ81QP78UkXnBhcKxcjpJrVpXDOPms566i/f63A2ssLwvTqNh6x7h7mDsZcRa0aF/6a7dm3NBbw3b3nAD4AFWHPf6iHIx3MRmhLmErkSYr4hTuJCkM/jHoG/irkbCKq4xphaRB/jnEWJmTqObcmNMJSL3sLmYsWKaqBST6TXG7EVkD08RiMiyJaXv6+aS+H49t1vNHc0RtkJpMauaFiMYZQt/q3HyzjXGHDwncyUdXQyp9ejSr0Ws5llU4k4vqm8s03XnJStUXitFCUbxDaa77jwftzQbY93bqVGiYGLmL3yPVYTZL5kSBRMz4+ob+NItnaFEwcTM3Pq6t2ITgaVQomCiodlW3ziGbqmDixaM4jucpZXp4BoE4xv4Po69J1HJlCgY38CzUxCBCbMp7jmQhRIF40ufUZWvaJ6ZkzlNl2DcRpa5zbNv0JlCMG73M3JEm2BeAPyCrR7/0keuiquvSzo7CgosOawSTAOdPKcE84r/LyDoZsd9IOEoQiu6XhbNo/ksZEWpl9w7npXOsWCW6A743LLrqS6irzvyybGEBL+u43LsUVMx8dSxYPpYjyT+Xe9kXxfQO5Orc39DJo1n3ybvBMUKpu8dPmQJ9jZCNozwzbFsEFarWsCKJnsWOKBpL+nk82PB+Cg5WhA8YO8ir1qRWpnQ1TGdpcm9Z7Sv1S22t3qGCDuwqlhCRiNVSIuJdioMKXC+6CpZya1N4HL3WQUTMh3gAwHWQUTmOvUwdOg6pIlt6N4Bc1hr85Fq6K0x01vAW7O6pJDWkTmsaF7Qw0WJyFKtyifCJywN6mLQoXiMFpAFgFcR+SUiryIyuA6lWyI/I3yX2KSNff9pU6x//FwhTNVf/PH3nxXsj9mcWuAWV14iTtyzVtcyCBF5Q5q8UnOj0L5TLNw18s5FHXEDuz3zgEO0c9w1sIP9ckN+1HPttUNx7bkxeMJ360dM5vj+8XMSktH24lTQW/oa+9G2z9PjnNuDaEokX8H8lGC2KPcC7mO4oiYXJJo9MvRytw2r+24Xl5Matr87Og3RTHmPgSyeoU0wFcpqJK9hN+hMJmJdTSJkQ84SWOfa26krcbfF8HxFDJxYsrgMdXl3mM5SHdvYbrqLc5neLawbGMs9VRhn699K94x+QoZ9FAewzb2BaZ/SwA72jsu9acMGI4iliTFma4y5RXnCqQE8jbHbbd9a0gHW0kRbSKiDLYBbY8y6lI0iGsJ5wPiBsbs+o5yHb/HRLVV2i7gbarsq8q0x5qnUdeuMMTu9q92KXFvksTxuEHKj12e0Gyl0fZgDvkcTLlPqUv/nNrWqYS/AQR/7Md1OCPqD7fTR3MjLXYfmw5ev64Lv61OEpQXiLCjkviBgs7BfT2irxhy2tjEpUfjQWADxpLtuXIc2cmxlSAghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGkJ/8Cv9jVmCdjckMAAAAASUVORK5CYII="

/***/ }),
/* 512 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 513 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ }),
/* 514 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,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"

/***/ })
]));
//# sourceMappingURL=1.7e6305fdfd4521e62721.js.map